package net.tsz.afinal.utils;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.List;
import net.tsz.afinal.annotation.sqlite.Id;
import net.tsz.afinal.annotation.sqlite.Table;
import net.tsz.afinal.db.sqlite.ManyToOneLazyLoader;
import net.tsz.afinal.db.table.ManyToOne;
import net.tsz.afinal.db.table.OneToMany;
import net.tsz.afinal.db.table.Property;
import net.tsz.afinal.exception.DbException;

public class ClassUtils
{
  public ClassUtils() {}
  
  public static List<ManyToOne> getManyToOneList(Class<?> paramClass)
  {
    ArrayList localArrayList = new ArrayList();
    for (;;)
    {
      int j;
      int i;
      try
      {
        arrayOfField = paramClass.getDeclaredFields();
        j = arrayOfField.length;
        i = 0;
      }
      catch (Exception paramClass)
      {
        Field[] arrayOfField;
        Field localField;
        ManyToOne localManyToOne;
        Class localClass;
        throw new RuntimeException(paramClass.getMessage(), paramClass);
      }
      localField = arrayOfField[i];
      if ((!FieldUtils.isTransient(localField)) && (FieldUtils.isManyToOne(localField)))
      {
        localManyToOne = new ManyToOne();
        if (localField.getType() == ManyToOneLazyLoader.class)
        {
          localClass = (Class)((ParameterizedType)localField.getGenericType()).getActualTypeArguments()[1];
          if (localClass != null) {
            localManyToOne.setManyClass(localClass);
          }
          localManyToOne.setColumn(FieldUtils.getColumnByField(localField));
          localManyToOne.setFieldName(localField.getName());
          localManyToOne.setDataType(localField.getType());
          localManyToOne.setSet(FieldUtils.getFieldSetMethod(paramClass, localField));
          localManyToOne.setGet(FieldUtils.getFieldGetMethod(paramClass, localField));
          localArrayList.add(localManyToOne);
        }
        else
        {
          localManyToOne.setManyClass(localField.getType());
          continue;
        }
      }
      while (i >= j)
      {
        return localArrayList;
        i += 1;
      }
    }
  }
  
  public static List<OneToMany> getOneToManyList(Class<?> paramClass)
  {
    int i = 0;
    ArrayList localArrayList = new ArrayList();
    for (;;)
    {
      int j;
      try
      {
        arrayOfField = paramClass.getDeclaredFields();
        j = arrayOfField.length;
      }
      catch (Exception paramClass)
      {
        Field[] arrayOfField;
        OneToMany localOneToMany;
        Object localObject;
        throw new RuntimeException(paramClass.getMessage(), paramClass);
      }
      Field localField = arrayOfField[i];
      if ((!FieldUtils.isTransient(localField)) && (FieldUtils.isOneToMany(localField)))
      {
        localOneToMany = new OneToMany();
        localOneToMany.setColumn(FieldUtils.getColumnByField(localField));
        localOneToMany.setFieldName(localField.getName());
        if ((localField.getGenericType() instanceof ParameterizedType))
        {
          localObject = (ParameterizedType)localField.getGenericType();
          if (((ParameterizedType)localObject).getActualTypeArguments().length == 1)
          {
            localObject = (Class)localObject.getActualTypeArguments()[0];
            if (localObject != null) {
              localOneToMany.setOneClass((Class)localObject);
            }
            localOneToMany.setDataType(localField.getType());
            localOneToMany.setSet(FieldUtils.getFieldSetMethod(paramClass, localField));
            localOneToMany.setGet(FieldUtils.getFieldGetMethod(paramClass, localField));
            localArrayList.add(localOneToMany);
          }
          else
          {
            localObject = (Class)localObject.getActualTypeArguments()[1];
            if (localObject == null) {
              continue;
            }
            localOneToMany.setOneClass((Class)localObject);
            continue;
          }
        }
        else
        {
          throw new DbException("getOneToManyList Exception:" + localField.getName() + "'s type is null");
        }
      }
      while (i >= j)
      {
        return localArrayList;
        i += 1;
      }
    }
  }
  
  public static String getPrimaryKeyColumn(Class<?> paramClass)
  {
    int j = 0;
    String str = null;
    Field[] arrayOfField = paramClass.getDeclaredFields();
    if (arrayOfField != null)
    {
      paramClass = null;
      Object localObject = null;
      int k = arrayOfField.length;
      int i = 0;
      for (;;)
      {
        if (i >= k) {}
        for (;;)
        {
          if (paramClass == null) {
            break label106;
          }
          str = paramClass.column();
          if (str != null)
          {
            paramClass = str;
            if (str.trim().length() != 0) {}
          }
          else
          {
            paramClass = localObject.getName();
          }
          return paramClass;
          Field localField = arrayOfField[i];
          paramClass = (Id)localField.getAnnotation(Id.class);
          if (paramClass == null) {
            break;
          }
          localObject = localField;
        }
        i += 1;
      }
      label106:
      k = arrayOfField.length;
      i = 0;
      label112:
      if (i >= k)
      {
        k = arrayOfField.length;
        i = j;
      }
      for (;;)
      {
        paramClass = str;
        if (i >= k) {
          break;
        }
        if ("id".equals(arrayOfField[i].getName()))
        {
          return "id";
          if ("_id".equals(arrayOfField[i].getName())) {
            return "_id";
          }
          i += 1;
          break label112;
        }
        i += 1;
      }
    }
    throw new RuntimeException("this model[" + paramClass + "] has no field");
  }
  
  public static Field getPrimaryKeyField(Class<?> paramClass)
  {
    int j = 0;
    Class<?> localClass = null;
    Field[] arrayOfField = paramClass.getDeclaredFields();
    if (arrayOfField != null)
    {
      int k = arrayOfField.length;
      int i = 0;
      if (i >= k)
      {
        paramClass = localClass;
        label30:
        localClass = paramClass;
        if (paramClass == null)
        {
          k = arrayOfField.length;
          i = 0;
          label43:
          if (i < k) {
            break label94;
          }
          localClass = paramClass;
        }
        label51:
        if (localClass == null)
        {
          k = arrayOfField.length;
          i = j;
        }
      }
      for (;;)
      {
        if (i >= k)
        {
          return localClass;
          paramClass = arrayOfField[i];
          if (paramClass.getAnnotation(Id.class) != null) {
            break label30;
          }
          i += 1;
          break;
          label94:
          localClass = arrayOfField[i];
          if ("_id".equals(localClass.getName())) {
            break label51;
          }
          i += 1;
          break label43;
        }
        paramClass = arrayOfField[i];
        if ("id".equals(paramClass.getName())) {
          return paramClass;
        }
        i += 1;
      }
    }
    throw new RuntimeException("this model[" + paramClass + "] has no field");
  }
  
  public static String getPrimaryKeyFieldName(Class<?> paramClass)
  {
    paramClass = getPrimaryKeyField(paramClass);
    if (paramClass == null) {
      return null;
    }
    return paramClass.getName();
  }
  
  public static Object getPrimaryKeyValue(Object paramObject)
  {
    return FieldUtils.getFieldValue(paramObject, getPrimaryKeyField(paramObject.getClass()));
  }
  
  public static List<Property> getPropertyList(Class<?> paramClass)
  {
    ArrayList localArrayList = new ArrayList();
    for (;;)
    {
      int j;
      int i;
      try
      {
        arrayOfField = paramClass.getDeclaredFields();
        str = getPrimaryKeyFieldName(paramClass);
        j = arrayOfField.length;
        i = 0;
      }
      catch (Exception paramClass)
      {
        Field[] arrayOfField;
        String str;
        Field localField;
        Property localProperty;
        throw new RuntimeException(paramClass.getMessage(), paramClass);
      }
      localField = arrayOfField[i];
      if ((!FieldUtils.isTransient(localField)) && (FieldUtils.isBaseDateType(localField)) && (!localField.getName().equals(str)))
      {
        localProperty = new Property();
        localProperty.setColumn(FieldUtils.getColumnByField(localField));
        localProperty.setFieldName(localField.getName());
        localProperty.setDataType(localField.getType());
        localProperty.setDefaultValue(FieldUtils.getPropertyDefaultValue(localField));
        localProperty.setSet(FieldUtils.getFieldSetMethod(paramClass, localField));
        localProperty.setGet(FieldUtils.getFieldGetMethod(paramClass, localField));
        localProperty.setField(localField);
        localArrayList.add(localProperty);
      }
      while (i >= j)
      {
        return localArrayList;
        i += 1;
      }
    }
  }
  
  public static String getTableName(Class<?> paramClass)
  {
    Table localTable = (Table)paramClass.getAnnotation(Table.class);
    if ((localTable == null) || (localTable.name().trim().length() == 0)) {
      return paramClass.getName().replace('.', '_');
    }
    return localTable.name();
  }
}
