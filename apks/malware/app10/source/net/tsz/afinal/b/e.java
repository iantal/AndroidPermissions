package net.tsz.afinal.b;

import android.os.Message;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class e<Params, Progress, Result>
{
  public static final Executor a = new ThreadPoolExecutor(5, 128, 1L, TimeUnit.SECONDS, e, d, new ThreadPoolExecutor.DiscardOldestPolicy());
  public static final Executor b = new k(null);
  public static final Executor c = Executors.newFixedThreadPool(3, d);
  private static final ThreadFactory d = new f();
  private static final BlockingQueue<Runnable> e = new LinkedBlockingQueue(10);
  private static final j f = new j(null);
  private static volatile Executor g = b;
  private final n<Params, Result> h = new g(this);
  private final FutureTask<Result> i = new h(this, this.h);
  private volatile m j = m.a;
  private final AtomicBoolean k = new AtomicBoolean();
  private final AtomicBoolean l = new AtomicBoolean();
  
  public e() {}
  
  private void c(Result paramResult)
  {
    if (!this.l.get()) {
      d(paramResult);
    }
  }
  
  private Result d(Result paramResult)
  {
    f.obtainMessage(1, new i(this, new Object[] { paramResult })).sendToTarget();
    return paramResult;
  }
  
  private void e(Result paramResult)
  {
    if (c()) {
      b(paramResult);
    }
    for (;;)
    {
      this.j = m.c;
      return;
      a(paramResult);
    }
  }
  
  protected abstract Result a(Params... paramVarArgs);
  
  public final e<Params, Progress, Result> a(Executor paramExecutor, Params... paramVarArgs)
  {
    if (this.j != m.a) {}
    switch (d()[this.j.ordinal()])
    {
    default: 
      this.j = m.b;
      a();
      this.h.b = paramVarArgs;
      paramExecutor.execute(this.i);
      return this;
    case 2: 
      throw new IllegalStateException("Cannot execute task: the task is already running.");
    }
    throw new IllegalStateException("Cannot execute task: the task has already been executed (a task can be executed only once)");
  }
  
  protected void a() {}
  
  protected void a(Result paramResult) {}
  
  protected void b() {}
  
  protected void b(Result paramResult)
  {
    b();
  }
  
  protected void b(Progress... paramVarArgs) {}
  
  protected final void c(Progress... paramVarArgs)
  {
    if (!c()) {
      f.obtainMessage(2, new i(this, paramVarArgs)).sendToTarget();
    }
  }
  
  public final boolean c()
  {
    return this.k.get();
  }
}
