package com.eden.sdk.unluac.parse;

import com.eden.sdk.unluac.Version;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class BHeader
{
  private static final byte[] luacTail = { 25, -109, 13, 10, 26, 10 };
  private static final byte[] signature = { 27, 76, 117, 97 };
  public final LBooleanType bool;
  public final LConstantType constant;
  public final boolean debug = false;
  public final LFunctionType function;
  public final BIntegerType integer;
  public final LLocalType local;
  public final LNumberType number;
  public final BSizeTType sizeT;
  public final LStringType string;
  public final LUpvalueType upvalue;
  public final Version version;
  
  public BHeader(ByteBuffer paramByteBuffer)
  {
    int i = 0;
    for (;;)
    {
      if (i >= signature.length) {
        i = paramByteBuffer.get() & 0xFF;
      }
      switch (i)
      {
      default: 
        throw new IllegalStateException("The input chunk's Lua version is " + (i >> 4) + "." + (i & 0xF) + "; unluac can only handle Lua 5.1 and Lua 5.2.");
        if (paramByteBuffer.get() != signature[i]) {
          throw new IllegalStateException("The input file does not have the signature of a valid Lua file.");
        }
        i += 1;
      }
    }
    for (this.version = Version.LUA51;; this.version = Version.LUA52)
    {
      i = paramByteBuffer.get() & 0xFF;
      if (i == 0) {
        break;
      }
      throw new IllegalStateException("The input chunk reports a non-standard lua format: " + i);
    }
    i = paramByteBuffer.get() & 0xFF;
    switch (i)
    {
    default: 
      throw new IllegalStateException("The input chunk reports an invalid endianness: " + i);
    case 0: 
      paramByteBuffer.order(ByteOrder.BIG_ENDIAN);
    }
    for (;;)
    {
      this.integer = new BIntegerType(paramByteBuffer.get() & 0xFF);
      this.sizeT = new BSizeTType(paramByteBuffer.get() & 0xFF);
      i = paramByteBuffer.get() & 0xFF;
      if (i == 4) {
        break;
      }
      throw new IllegalStateException("The input chunk reports an unsupported instruction size: " + i + " bytes");
      paramByteBuffer.order(ByteOrder.LITTLE_ENDIAN);
    }
    i = paramByteBuffer.get();
    int k = paramByteBuffer.get() & 0xFF;
    if (k > 1) {
      throw new IllegalStateException("The input chunk reports an invalid code for lua number integralness: " + k);
    }
    boolean bool1;
    if (k == 1)
    {
      bool1 = true;
      this.number = new LNumberType(i & 0xFF, bool1);
      this.bool = new LBooleanType();
      this.string = new LStringType();
      this.constant = new LConstantType();
      this.local = new LLocalType();
      this.upvalue = new LUpvalueType();
      this.function = this.version.getLFunctionType();
      if (this.version.hasHeaderTail()) {
        i = j;
      }
    }
    for (;;)
    {
      if (i >= luacTail.length)
      {
        return;
        bool1 = false;
        break;
      }
      if (paramByteBuffer.get() != luacTail[i]) {
        throw new IllegalStateException("The input file does not have the header tail of a valid Lua file.");
      }
      i += 1;
    }
  }
}
