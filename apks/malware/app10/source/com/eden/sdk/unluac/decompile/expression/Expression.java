package com.eden.sdk.unluac.decompile.expression;

import com.eden.sdk.unluac.decompile.Constant;
import com.eden.sdk.unluac.decompile.Output;
import com.eden.sdk.unluac.decompile.target.Target;
import com.eden.sdk.unluac.parse.LNil;
import java.util.Iterator;
import java.util.List;

public abstract class Expression
{
  public static final int ASSOCIATIVITY_LEFT = 1;
  public static final int ASSOCIATIVITY_NONE = 0;
  public static final int ASSOCIATIVITY_RIGHT = 2;
  public static final Expression NIL = new ConstantExpression(new Constant(LNil.NIL), -1);
  public static final int PRECEDENCE_ADD = 5;
  public static final int PRECEDENCE_AND = 2;
  public static final int PRECEDENCE_ATOMIC = 9;
  public static final int PRECEDENCE_COMPARE = 3;
  public static final int PRECEDENCE_CONCAT = 4;
  public static final int PRECEDENCE_MUL = 6;
  public static final int PRECEDENCE_OR = 1;
  public static final int PRECEDENCE_POW = 8;
  public static final int PRECEDENCE_UNARY = 7;
  public final int precedence;
  
  public Expression(int paramInt)
  {
    this.precedence = paramInt;
  }
  
  public static BinaryExpression makeADD(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("+", paramExpression1, paramExpression2, 5, 1);
  }
  
  public static BinaryExpression makeCONCAT(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("..", paramExpression1, paramExpression2, 4, 2);
  }
  
  public static BinaryExpression makeDIV(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("/", paramExpression1, paramExpression2, 6, 1);
  }
  
  public static UnaryExpression makeLEN(Expression paramExpression)
  {
    return new UnaryExpression("#", paramExpression, 7);
  }
  
  public static BinaryExpression makeMOD(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("%", paramExpression1, paramExpression2, 6, 1);
  }
  
  public static BinaryExpression makeMUL(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("*", paramExpression1, paramExpression2, 6, 1);
  }
  
  public static UnaryExpression makeNOT(Expression paramExpression)
  {
    return new UnaryExpression("not ", paramExpression, 7);
  }
  
  public static BinaryExpression makePOW(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("^", paramExpression1, paramExpression2, 8, 2);
  }
  
  public static BinaryExpression makeSUB(Expression paramExpression1, Expression paramExpression2)
  {
    return new BinaryExpression("-", paramExpression1, paramExpression2, 5, 1);
  }
  
  public static UnaryExpression makeUNM(Expression paramExpression)
  {
    return new UnaryExpression("-", paramExpression, 7);
  }
  
  protected static void printBinary(Output paramOutput, String paramString, Expression paramExpression1, Expression paramExpression2)
  {
    paramExpression1.print(paramOutput);
    paramOutput.print(" ");
    paramOutput.print(paramString);
    paramOutput.print(" ");
    paramExpression2.print(paramOutput);
  }
  
  public static void printSequence(Output paramOutput, List<Expression> paramList, boolean paramBoolean1, boolean paramBoolean2)
  {
    int k = paramList.size();
    paramList = paramList.iterator();
    int j = 1;
    if (!paramList.hasNext()) {
      return;
    }
    Expression localExpression = (Expression)paramList.next();
    if (j == k) {}
    for (int i = 1;; i = 0)
    {
      if (localExpression.isMultiple()) {
        i = 1;
      }
      if (i == 0) {
        break label89;
      }
      if (!paramBoolean2) {
        break;
      }
      localExpression.printMultiple(paramOutput);
      return;
    }
    localExpression.print(paramOutput);
    return;
    label89:
    localExpression.print(paramOutput);
    paramOutput.print(",");
    if (paramBoolean1) {
      paramOutput.println();
    }
    for (;;)
    {
      j += 1;
      break;
      paramOutput.print(" ");
    }
  }
  
  protected static void printUnary(Output paramOutput, String paramString, Expression paramExpression)
  {
    paramOutput.print(paramString);
    paramExpression.print(paramOutput);
  }
  
  public void addEntry(TableLiteral.Entry paramEntry)
  {
    throw new IllegalStateException();
  }
  
  public int asInteger()
  {
    throw new IllegalStateException();
  }
  
  public String asName()
  {
    throw new IllegalStateException();
  }
  
  public boolean beginsWithParen()
  {
    return false;
  }
  
  public int closureUpvalueLine()
  {
    throw new IllegalStateException();
  }
  
  public abstract int getConstantIndex();
  
  public String getField()
  {
    throw new IllegalStateException();
  }
  
  public Expression getTable()
  {
    throw new IllegalStateException();
  }
  
  public boolean isBoolean()
  {
    return false;
  }
  
  public boolean isBrief()
  {
    return false;
  }
  
  public boolean isClosure()
  {
    return false;
  }
  
  public boolean isConstant()
  {
    return false;
  }
  
  public boolean isDotChain()
  {
    return false;
  }
  
  public boolean isIdentifier()
  {
    return false;
  }
  
  public boolean isInteger()
  {
    return false;
  }
  
  public boolean isMemberAccess()
  {
    return false;
  }
  
  public boolean isMultiple()
  {
    return false;
  }
  
  public boolean isNil()
  {
    return false;
  }
  
  public boolean isString()
  {
    return false;
  }
  
  public boolean isTableLiteral()
  {
    return false;
  }
  
  public boolean isUpvalueOf(int paramInt)
  {
    throw new IllegalStateException();
  }
  
  public abstract void print(Output paramOutput);
  
  public void printClosure(Output paramOutput, Target paramTarget)
  {
    throw new IllegalStateException();
  }
  
  public void printMultiple(Output paramOutput)
  {
    print(paramOutput);
  }
}
