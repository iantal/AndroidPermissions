package com.xs.mm;

import android.content.Context;
import com.xs.mm.util.Base64;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class RSAUtils
{
  private static RSAPrivateKey rsaPrivateKey;
  private static RSAPublicKey rsaPublicKey;
  
  public RSAUtils() {}
  
  public static byte[] decryptByPrivateKey(byte[] paramArrayOfByte, String paramString)
  {
    if (paramString == null) {
      return null;
    }
    paramString = new PKCS8EncodedKeySpec(MMBase64.decode(paramString));
    paramString = KeyFactory.getInstance("RSA").generatePrivate(paramString);
    Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    localCipher.init(2, paramString);
    int k = paramArrayOfByte.length;
    ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
    int i = 0;
    int j = 0;
    if (k - i <= 0)
    {
      paramArrayOfByte = localByteArrayOutputStream.toByteArray();
      localByteArrayOutputStream.close();
      return paramArrayOfByte;
    }
    if (k - i > 128) {}
    for (paramString = localCipher.doFinal(paramArrayOfByte, i, 128);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
    {
      j += 1;
      localByteArrayOutputStream.write(paramString, 0, paramString.length);
      i = j * 128;
      break;
    }
  }
  
  public static byte[] desEncrypt(byte[] paramArrayOfByte1, byte[] paramArrayOfByte2, boolean paramBoolean)
  {
    Cipher localCipher = Cipher.getInstance("DES/ECB/NoPadding");
    paramArrayOfByte2 = new SecretKeySpec(paramArrayOfByte2, "DES");
    if (!paramBoolean) {
      localCipher.init(2, paramArrayOfByte2);
    }
    for (;;)
    {
      paramArrayOfByte2 = new byte[(paramArrayOfByte1.length + 7) / 8 * 8];
      System.arraycopy(paramArrayOfByte1, 0, paramArrayOfByte2, 0, paramArrayOfByte1.length);
      return localCipher.doFinal(paramArrayOfByte2);
      localCipher.init(1, paramArrayOfByte2);
    }
  }
  
  public static String encryptStackMark(String paramString1, String paramString2, String paramString3, String paramString4)
  {
    paramString2 = getMD5(paramString2 + paramString3 + paramString4);
    paramString3 = new byte[8];
    System.arraycopy(paramString2, 0, paramString3, 0, 8);
    try
    {
      paramString1 = Base64.encodeToString(desEncrypt(paramString1.getBytes(), paramString3, true), 0);
      return paramString1;
    }
    catch (Exception paramString1)
    {
      paramString1.printStackTrace();
    }
    return "";
  }
  
  public static String gerPrivateKey()
  {
    return MMBase64.encodeToString(rsaPrivateKey.getEncoded());
  }
  
  private static byte[] getMD5(String paramString)
  {
    try
    {
      paramString = MessageDigest.getInstance("MD5").digest(paramString.getBytes());
      return paramString;
    }
    catch (NoSuchAlgorithmException paramString)
    {
      paramString.printStackTrace();
    }
    return null;
  }
  
  public static String getRSAPubKey()
  {
    return MMBase64.encodeToString(rsaPublicKey.getEncoded());
  }
  
  public static void initRSAKey()
  {
    if ((rsaPublicKey == null) || (rsaPrivateKey == null))
    {
      Object localObject = KeyPairGenerator.getInstance("RSA");
      ((KeyPairGenerator)localObject).initialize(1024, new SecureRandom());
      localObject = ((KeyPairGenerator)localObject).generateKeyPair();
      rsaPublicKey = (RSAPublicKey)((KeyPair)localObject).getPublic();
      rsaPrivateKey = (RSAPrivateKey)((KeyPair)localObject).getPrivate();
    }
  }
  
  public static String method_455(byte[] paramArrayOfByte, String paramString)
  {
    paramString = new PKCS8EncodedKeySpec(MMBase64.decode(paramString));
    paramString = KeyFactory.getInstance("RSA").generatePrivate(paramString);
    Signature localSignature = Signature.getInstance("MD5withRSA");
    localSignature.initSign(paramString);
    localSignature.update(paramArrayOfByte);
    return MMBase64.encodeToString(localSignature.sign());
  }
  
  public static boolean method_457(byte[] paramArrayOfByte, String paramString1, String paramString2)
  {
    paramString1 = new X509EncodedKeySpec(MMBase64.decode(paramString1));
    paramString1 = KeyFactory.getInstance("RSA").generatePublic(paramString1);
    Signature localSignature = Signature.getInstance("MD5withRSA");
    localSignature.initVerify(paramString1);
    localSignature.update(paramArrayOfByte);
    return localSignature.verify(MMBase64.decode(paramString2));
  }
  
  public static byte[] method_459(byte[] paramArrayOfByte, String paramString)
  {
    paramString = new PKCS8EncodedKeySpec(MMBase64.decode(paramString));
    paramString = KeyFactory.getInstance("RSA").generatePrivate(paramString);
    Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    localCipher.init(1, paramString);
    int k = paramArrayOfByte.length;
    ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
    int i = 0;
    int j = 0;
    if (k - i <= 0)
    {
      paramArrayOfByte = localByteArrayOutputStream.toByteArray();
      localByteArrayOutputStream.close();
      return paramArrayOfByte;
    }
    if (k - i > 117) {}
    for (paramString = localCipher.doFinal(paramArrayOfByte, i, 117);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
    {
      j += 1;
      localByteArrayOutputStream.write(paramString, 0, paramString.length);
      i = j * 117;
      break;
    }
  }
  
  public static byte[] rasEncryptByPublicKey(byte[] paramArrayOfByte, String paramString)
  {
    paramString = new X509EncodedKeySpec(MMBase64.decode(paramString));
    paramString = KeyFactory.getInstance("RSA").generatePublic(paramString);
    Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    localCipher.init(2, paramString);
    int k = paramArrayOfByte.length;
    ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
    int i = 0;
    int j = 0;
    if (k - i <= 0)
    {
      paramArrayOfByte = localByteArrayOutputStream.toByteArray();
      localByteArrayOutputStream.close();
      return paramArrayOfByte;
    }
    if (k - i > 128) {}
    for (paramString = localCipher.doFinal(paramArrayOfByte, i, 128);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
    {
      j += 1;
      localByteArrayOutputStream.write(paramString, 0, paramString.length);
      i = j * 128;
      break;
    }
  }
  
  public static String[] readSecerityTimestamp(Context paramContext)
  {
    return null;
  }
  
  public static byte[] rsaEncrypt(byte[] paramArrayOfByte, String paramString)
  {
    if ((paramArrayOfByte != null) && (paramString != null))
    {
      paramString = new X509EncodedKeySpec(MMBase64.decode(paramString));
      paramString = KeyFactory.getInstance("RSA").generatePublic(paramString);
      Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
      localCipher.init(1, paramString);
      int k = paramArrayOfByte.length;
      ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
      int i = 0;
      int j = 0;
      if (k - i <= 0)
      {
        paramArrayOfByte = localByteArrayOutputStream.toByteArray();
        localByteArrayOutputStream.close();
        return paramArrayOfByte;
      }
      if (k - i > 117) {}
      for (paramString = localCipher.doFinal(paramArrayOfByte, i, 117);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
      {
        j += 1;
        localByteArrayOutputStream.write(paramString, 0, paramString.length);
        i = j * 117;
        break;
      }
    }
    return null;
  }
}
