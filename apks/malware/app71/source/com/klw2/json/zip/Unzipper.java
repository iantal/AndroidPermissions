package com.klw2.json.zip;

import com.klw2.json.JSONArray;
import com.klw2.json.JSONException;
import com.klw2.json.JSONObject;
import com.klw2.json.Kim;
import java.io.UnsupportedEncodingException;

public class Unzipper
  extends JSONzip
{
  BitReader bitreader;
  
  public Unzipper(BitReader paramBitReader)
  {
    this.bitreader = paramBitReader;
  }
  
  private boolean bit()
  {
    try
    {
      boolean bool = this.bitreader.bit();
      return bool;
    }
    catch (Throwable localThrowable)
    {
      throw new JSONException(localThrowable);
    }
  }
  
  private Object getAndTick(b paramB, BitReader paramBitReader)
  {
    int i;
    try
    {
      i = paramBitReader.read(paramB.a());
      paramBitReader = paramB.b(i);
      if (i >= paramB.a) {
        throw new JSONException("Deep error.");
      }
    }
    catch (Throwable paramB)
    {
      throw new JSONException(paramB);
    }
    paramB.a(i);
    return paramBitReader;
  }
  
  private int read(int paramInt)
  {
    try
    {
      paramInt = this.bitreader.read(paramInt);
      return paramInt;
    }
    catch (Throwable localThrowable)
    {
      throw new JSONException(localThrowable);
    }
  }
  
  private String read(Huff paramHuff1, Huff paramHuff2, b paramB)
  {
    Object localObject = new byte['Ā'];
    int k;
    int m;
    if (bit())
    {
      return getAndTick(paramB, this.bitreader).toString();
      while ((m & 0x80) == 128)
      {
        localObject[k] = ((byte)m);
        k += 1;
        m = paramHuff2.read(this.bitreader);
      }
      localObject[k] = ((byte)m);
    }
    for (int i = k + 1;; i = 0)
    {
      if (i >= j)
      {
        j *= 2;
        byte[] arrayOfByte = new byte[j];
        System.arraycopy(localObject, 0, arrayOfByte, 0, j);
        localObject = arrayOfByte;
      }
      for (;;)
      {
        int n = paramHuff1.read(this.bitreader);
        m = n;
        k = i;
        if (n != 256) {
          break;
        }
        if (i == 0) {
          return "";
        }
        paramHuff1 = new Kim((byte[])localObject, i);
        paramB.b(paramHuff1);
        return paramHuff1.toString();
      }
      int j = 256;
    }
  }
  
  private JSONArray readArray(boolean paramBoolean)
  {
    JSONArray localJSONArray = new JSONArray();
    if (paramBoolean) {}
    for (Object localObject = read(this.stringhuff, this.stringhuffext, this.stringkeep);; localObject = readValue())
    {
      localJSONArray.put(localObject);
      if (bit()) {
        break label97;
      }
      if (bit()) {
        break;
      }
      return localJSONArray;
    }
    if (paramBoolean) {}
    for (localObject = readValue();; localObject = read(this.stringhuff, this.stringhuffext, this.stringkeep))
    {
      localJSONArray.put(localObject);
      break;
    }
    label97:
    if (paramBoolean) {}
    for (localObject = read(this.stringhuff, this.stringhuffext, this.stringkeep);; localObject = readValue())
    {
      localJSONArray.put(localObject);
      break;
    }
  }
  
  private Object readJSON()
  {
    switch (read(3))
    {
    case 4: 
    default: 
      return JSONObject.NULL;
    case 5: 
      return readObject();
    case 6: 
      return readArray(true);
    case 7: 
      return readArray(false);
    case 0: 
      return new JSONObject();
    case 1: 
      return new JSONArray();
    case 2: 
      return Boolean.TRUE;
    }
    return Boolean.FALSE;
  }
  
  private JSONObject readObject()
  {
    JSONObject localJSONObject = new JSONObject();
    String str = read(this.namehuff, this.namehuffext, this.namekeep);
    if (localJSONObject.opt(str) != null) {
      throw new JSONException("Duplicate key.");
    }
    if (!bit()) {}
    for (Object localObject = read(this.stringhuff, this.stringhuffext, this.stringkeep);; localObject = readValue())
    {
      localJSONObject.put(str, localObject);
      if (bit()) {
        break;
      }
      return localJSONObject;
    }
  }
  
  private Object readValue()
  {
    int i = 4;
    int j = 0;
    switch (read(2))
    {
    default: 
      throw new JSONException("Impossible.");
    case 0: 
      if (!bit())
      {
        j = read(i);
        switch (i)
        {
        default: 
          i = j;
        }
      }
      for (;;)
      {
        return Integer.valueOf(i);
        if (!bit())
        {
          i = 7;
          break;
        }
        i = 14;
        break;
        i = j + 16;
        continue;
        i = j + 144;
      }
    case 1: 
      Object localObject = new byte['Ā'];
      i = j;
      for (;;)
      {
        j = read(4);
        if (j == endOfNumber) {}
        try
        {
          localObject = JSONObject.stringToValue(new String((byte[])localObject, 0, i, "US-ASCII"));
          this.valuekeep.b(localObject);
          return localObject;
        }
        catch (UnsupportedEncodingException localUnsupportedEncodingException)
        {
          throw new JSONException(localUnsupportedEncodingException);
        }
        localObject[i] = bcd[j];
        i += 1;
      }
    case 2: 
      return getAndTick(this.valuekeep, this.bitreader);
    }
    return readJSON();
  }
  
  public Object decode()
  {
    generate();
    return readJSON();
  }
  
  public boolean pad(int paramInt)
  {
    try
    {
      boolean bool = this.bitreader.pad(paramInt);
      return bool;
    }
    catch (Throwable localThrowable)
    {
      throw new JSONException(localThrowable);
    }
  }
}
