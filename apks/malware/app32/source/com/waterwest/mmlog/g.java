package com.waterwest.mmlog;

import android.util.Base64;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;

public final class g
{
  private static RSAPrivateKey a;
  private static RSAPublicKey b;
  
  public g() {}
  
  private static void a()
  {
    if ((b == null) || (a == null)) {
      localObject = null;
    }
    try
    {
      KeyPairGenerator localKeyPairGenerator = KeyPairGenerator.getInstance("RSA");
      localObject = localKeyPairGenerator;
    }
    catch (NoSuchAlgorithmException localNoSuchAlgorithmException)
    {
      for (;;)
      {
        localNoSuchAlgorithmException.printStackTrace();
      }
    }
    ((KeyPairGenerator)localObject).initialize(1024, new SecureRandom());
    Object localObject = ((KeyPairGenerator)localObject).generateKeyPair();
    b = (RSAPublicKey)((KeyPair)localObject).getPublic();
    a = (RSAPrivateKey)((KeyPair)localObject).getPrivate();
  }
  
  public static byte[] a(byte[] paramArrayOfByte, String paramString)
  {
    if ((paramArrayOfByte != null) && (paramString != null))
    {
      paramString = new X509EncodedKeySpec(Base64.decode(paramString, 0));
      paramString = KeyFactory.getInstance("RSA").generatePublic(paramString);
      Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
      localCipher.init(1, paramString);
      int k = paramArrayOfByte.length;
      ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
      int i = 0;
      int j = 0;
      if (k - i <= 0)
      {
        paramArrayOfByte = localByteArrayOutputStream.toByteArray();
        localByteArrayOutputStream.close();
        return paramArrayOfByte;
      }
      if (k - i > 117) {}
      for (paramString = localCipher.doFinal(paramArrayOfByte, i, 117);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
      {
        localByteArrayOutputStream.write(paramString, 0, paramString.length);
        j += 1;
        i = j * 117;
        break;
      }
    }
    throw new IllegalArgumentException("encryptByPublicKey data||publicKey is null");
  }
  
  private static String b()
  {
    return Base64.encodeToString(a.getEncoded(), 2);
  }
  
  private static byte[] b(byte[] paramArrayOfByte, String paramString)
  {
    Object localObject2 = null;
    int i = 0;
    if (paramString == null) {
      return null;
    }
    Object localObject1 = localObject2;
    Cipher localCipher;
    int k;
    ByteArrayOutputStream localByteArrayOutputStream;
    int j;
    try
    {
      paramString = new PKCS8EncodedKeySpec(Base64.decode(paramString, 0));
      localObject1 = localObject2;
      paramString = KeyFactory.getInstance("RSA").generatePrivate(paramString);
      localObject1 = localObject2;
      localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
      localObject1 = localObject2;
      localCipher.init(2, paramString);
      localObject1 = localObject2;
      k = paramArrayOfByte.length;
      localObject1 = localObject2;
      localByteArrayOutputStream = new ByteArrayOutputStream();
      j = 0;
      if (k - i <= 0)
      {
        localObject1 = localObject2;
        paramArrayOfByte = localByteArrayOutputStream.toByteArray();
        localObject1 = paramArrayOfByte;
        localByteArrayOutputStream.close();
        return paramArrayOfByte;
      }
    }
    catch (Exception paramArrayOfByte)
    {
      paramArrayOfByte.printStackTrace();
      return localObject1;
    }
    if (k - i > 128) {
      localObject1 = localObject2;
    }
    for (paramString = localCipher.doFinal(paramArrayOfByte, i, 128);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
    {
      localObject1 = localObject2;
      localByteArrayOutputStream.write(paramString, 0, paramString.length);
      j += 1;
      i = j * 128;
      break;
      localObject1 = localObject2;
    }
  }
  
  private static String c()
  {
    return Base64.encodeToString(b.getEncoded(), 2);
  }
}
