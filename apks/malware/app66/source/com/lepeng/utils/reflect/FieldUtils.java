package com.lepeng.utils.reflect;

import android.annotation.SuppressLint;
import com.lepeng.data.UtilApplication;
import com.lepeng.utils.StrUtil;
import com.lepeng.utils.annotation.sqlite.Id;
import com.lepeng.utils.annotation.sqlite.ManyToOne;
import com.lepeng.utils.annotation.sqlite.OneToMany;
import com.lepeng.utils.annotation.sqlite.Property;
import com.lepeng.utils.annotation.sqlite.Transient;
import com.lepeng.utils.exception.CheckedExceptionHandler;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.text.SimpleDateFormat;

@SuppressLint({"DefaultLocale", "SimpleDateFormat"})
public class FieldUtils
{
  private static SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
  
  public FieldUtils() {}
  
  private static Object a(Object paramObject, Method paramMethod)
  {
    if ((paramObject == null) || (paramMethod == null)) {
      return null;
    }
    try
    {
      paramObject = paramMethod.invoke(paramObject, new Object[0]);
      return paramObject;
    }
    catch (IllegalArgumentException paramObject)
    {
      CheckedExceptionHandler.handleException(paramObject);
      return null;
    }
    catch (IllegalAccessException paramObject)
    {
      CheckedExceptionHandler.handleException(paramObject);
      return null;
    }
    catch (InvocationTargetException paramObject)
    {
      CheckedExceptionHandler.handleException(paramObject);
    }
    return null;
  }
  
  private static String a(String paramString1, String paramString2)
  {
    if (paramString1.length() == 1) {
      return paramString2 + paramString1.toUpperCase(UtilApplication.getInstance().getDefaultLocale());
    }
    char c1 = paramString1.charAt(0);
    char c2 = paramString1.charAt(1);
    if ((StrUtil.isLowerChar(c1)) && (StrUtil.isUpperChar(c2))) {
      return paramString2 + paramString1;
    }
    if (StrUtil.isUpperChar(c1)) {
      return paramString2 + paramString1;
    }
    if ((StrUtil.isLowerChar(c1)) && (StrUtil.isLowerChar(c2))) {
      return paramString2 + paramString1.substring(0, 1).toUpperCase(UtilApplication.getInstance().getDefaultLocale()) + paramString1.substring(1);
    }
    return paramString2 + paramString1;
  }
  
  private static java.util.Date a(String paramString)
  {
    if (paramString != null) {
      try
      {
        paramString = a.parse(paramString);
        return paramString;
      }
      catch (ParseException paramString)
      {
        CheckedExceptionHandler.handleException(paramString);
      }
    }
    return null;
  }
  
  private static Method getBooleanFieldGetMethod(Class paramClass, String paramString)
  {
    paramString = parIsName(paramString);
    try
    {
      Method localMethod = paramClass.getDeclaredMethod(paramString, new Class[0]);
      return localMethod;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      try
      {
        paramClass = paramClass.getSuperclass().getDeclaredMethod(paramString, new Class[0]);
        return paramClass;
      }
      catch (Exception paramClass)
      {
        CheckedExceptionHandler.handleException(paramClass);
      }
    }
    return null;
  }
  
  private static Method getBooleanFieldSetMethod(Class paramClass, Field paramField)
  {
    String str = parSetName(paramField.getName());
    try
    {
      Method localMethod = paramClass.getDeclaredMethod(str, new Class[] { paramField.getType() });
      return localMethod;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      try
      {
        paramClass = paramClass.getSuperclass().getDeclaredMethod(str, new Class[] { paramField.getType() });
        return paramClass;
      }
      catch (Exception paramClass)
      {
        CheckedExceptionHandler.handleException(paramClass);
      }
    }
    return null;
  }
  
  public static String getColumnByField(Field paramField)
  {
    Object localObject = (Property)paramField.getAnnotation(Property.class);
    if ((localObject != null) && (((Property)localObject).column().trim().length() != 0)) {
      return ((Property)localObject).column();
    }
    localObject = (ManyToOne)paramField.getAnnotation(ManyToOne.class);
    if ((localObject != null) && (((ManyToOne)localObject).column().trim().length() != 0)) {
      return ((ManyToOne)localObject).column();
    }
    localObject = (OneToMany)paramField.getAnnotation(OneToMany.class);
    if ((localObject != null) && (((OneToMany)localObject).manyColumn() != null) && (((OneToMany)localObject).manyColumn().trim().length() != 0)) {
      return ((OneToMany)localObject).manyColumn();
    }
    localObject = (Id)paramField.getAnnotation(Id.class);
    if ((localObject != null) && (((Id)localObject).column().trim().length() != 0)) {
      return ((Id)localObject).column();
    }
    return paramField.getName();
  }
  
  private static Method getFieldGetMethod(Class paramClass, String paramString)
  {
    paramString = parGetName(paramString);
    try
    {
      Method localMethod = paramClass.getDeclaredMethod(paramString, new Class[0]);
      return localMethod;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      try
      {
        paramClass = paramClass.getSuperclass().getDeclaredMethod(paramString, new Class[0]);
        return paramClass;
      }
      catch (Exception paramClass)
      {
        CheckedExceptionHandler.handleException(paramClass);
      }
    }
    return null;
  }
  
  public static Method getFieldGetMethod(Class paramClass, Field paramField)
  {
    String str = paramField.getName();
    Method localMethod = null;
    if (paramField.getType() == Boolean.TYPE) {
      localMethod = getBooleanFieldGetMethod(paramClass, str);
    }
    paramField = localMethod;
    if (localMethod == null) {
      paramField = getFieldGetMethod(paramClass, str);
    }
    return paramField;
  }
  
  public static Method getFieldSetMethod(Class paramClass, Field paramField)
  {
    String str = parSetName(paramField.getName());
    try
    {
      Method localMethod = paramClass.getDeclaredMethod(str, new Class[] { paramField.getType() });
      return localMethod;
    }
    catch (NoSuchMethodException localNoSuchMethodException)
    {
      if (paramField.getType() == Boolean.TYPE) {
        return getBooleanFieldSetMethod(paramClass, paramField);
      }
      try
      {
        paramClass = paramClass.getSuperclass().getDeclaredMethod(str, new Class[] { paramField.getType() });
        return paramClass;
      }
      catch (Exception paramClass)
      {
        CheckedExceptionHandler.handleException(paramClass);
      }
    }
    return null;
  }
  
  public static Object getFieldValue(Object paramObject, Field paramField)
  {
    return a(paramObject, getFieldGetMethod(paramObject.getClass(), paramField));
  }
  
  public static String getPropertyDefaultValue(Field paramField)
  {
    paramField = (Property)paramField.getAnnotation(Property.class);
    if ((paramField != null) && (paramField.defaultValue().trim().length() != 0)) {
      return paramField.defaultValue();
    }
    return null;
  }
  
  public static boolean isBaseDateType(Field paramField)
  {
    paramField = paramField.getType();
    return (paramField.equals(String.class)) || (paramField.equals(Integer.class)) || (paramField.equals(Byte.class)) || (paramField.equals(Long.class)) || (paramField.equals(Double.class)) || (paramField.equals(Float.class)) || (paramField.equals(Character.class)) || (paramField.equals(Short.class)) || (paramField.equals(Boolean.class)) || (paramField.equals(java.util.Date.class)) || (paramField.equals(java.util.Date.class)) || (paramField.equals(java.sql.Date.class)) || (paramField.isPrimitive());
  }
  
  public static boolean isManyToOne(Field paramField)
  {
    return paramField.getAnnotation(ManyToOne.class) != null;
  }
  
  public static boolean isManyToOneOrOneToMany(Field paramField)
  {
    return (isManyToOne(paramField)) || (isOneToMany(paramField));
  }
  
  public static boolean isOneToMany(Field paramField)
  {
    return paramField.getAnnotation(OneToMany.class) != null;
  }
  
  public static boolean isTransient(Field paramField)
  {
    return paramField.getAnnotation(Transient.class) != null;
  }
  
  public static String parGetName(String paramString)
  {
    if (StrUtil.isEmptyOrNull(paramString)) {
      return null;
    }
    return a(paramString, "get");
  }
  
  public static String parIsName(String paramString)
  {
    if (StrUtil.isEmptyOrNull(paramString)) {
      return null;
    }
    return a(paramString, "is");
  }
  
  public static String parSetName(String paramString)
  {
    if (StrUtil.isEmptyOrNull(paramString)) {
      return null;
    }
    return a(paramString, "set");
  }
  
  public static void setFieldValue(Object paramObject1, Field paramField, Object paramObject2)
  {
    Object localObject3 = null;
    Method localMethod;
    for (;;)
    {
      try
      {
        localMethod = getFieldSetMethod(paramObject1.getClass(), paramField);
        if (localMethod == null) {
          return;
        }
        localMethod.setAccessible(true);
        paramField = paramField.getType();
        if (paramField == String.class)
        {
          localMethod.invoke(paramObject1, new Object[] { paramObject2.toString() });
          return;
        }
        if ((paramField != Integer.TYPE) && (paramField != Integer.class)) {
          break;
        }
        if (paramObject2 != null) {
          break label105;
        }
        throw new NullPointerException();
      }
      catch (Exception paramObject1)
      {
        CheckedExceptionHandler.handleException(paramObject1);
        return;
      }
      localMethod.invoke(paramObject1, new Object[] { Integer.valueOf(i) });
      return;
      label105:
      int i = Integer.parseInt(paramObject2.toString());
    }
    if ((paramField == Float.TYPE) || (paramField == Float.class))
    {
      if (paramObject2 == null) {
        throw new NullPointerException();
      }
      for (;;)
      {
        Object localObject1;
        localMethod.invoke(paramObject1, new Object[] { Float.valueOf(localObject1) });
        return;
        float f = Float.parseFloat(paramObject2.toString());
      }
    }
    if ((paramField == Long.TYPE) || (paramField == Long.class))
    {
      if (paramObject2 == null) {
        throw new NullPointerException();
      }
      for (;;)
      {
        Object localObject2;
        localMethod.invoke(paramObject1, new Object[] { Long.valueOf(localObject2) });
        return;
        long l = Long.parseLong(paramObject2.toString());
      }
    }
    if (paramField == java.util.Date.class)
    {
      if (paramObject2 == null) {}
      for (paramField = localObject3;; paramField = a(paramObject2.toString()))
      {
        localMethod.invoke(paramObject1, new Object[] { paramField });
        return;
      }
    }
    localMethod.invoke(paramObject1, new Object[] { paramObject2 });
  }
}
