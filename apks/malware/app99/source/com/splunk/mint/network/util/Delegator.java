package com.splunk.mint.network.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;
import java.util.Set;

public class Delegator
{
  private final Object delegate;
  private final Object source;
  private final Class superclass;
  
  public Delegator(Object paramObject1, Class paramClass, Object paramObject2)
  {
    this.source = paramObject1;
    this.superclass = paramClass;
    this.delegate = paramObject2;
  }
  
  public Delegator(Object paramObject, Class paramClass, String paramString)
  {
    try
    {
      this.source = paramObject;
      this.superclass = paramClass;
      paramObject = Class.forName(paramString).getDeclaredConstructor(new Class[0]);
      paramObject.setAccessible(true);
      this.delegate = paramObject.newInstance(new Object[0]);
      return;
    }
    catch (RuntimeException paramObject)
    {
      throw paramObject;
    }
    catch (Exception paramObject)
    {
      throw new DelegationException("Could not make delegate object", paramObject);
    }
  }
  
  private Class<?> convertPrimitiveClass(Class<?> paramClass)
  {
    Object localObject = paramClass;
    if (paramClass.isPrimitive())
    {
      if (paramClass != Integer.TYPE) {
        break label21;
      }
      localObject = Integer.class;
    }
    label21:
    do
    {
      return localObject;
      if (paramClass == Boolean.TYPE) {
        return Boolean.class;
      }
      if (paramClass == Float.TYPE) {
        return Float.class;
      }
      if (paramClass == Long.TYPE) {
        return Long.class;
      }
      if (paramClass == Double.TYPE) {
        return Double.class;
      }
      if (paramClass == Short.TYPE) {
        return Short.class;
      }
      if (paramClass == Byte.TYPE) {
        return Byte.class;
      }
      localObject = paramClass;
    } while (paramClass != Character.TYPE);
    return Character.class;
  }
  
  private String extractMethodName()
  {
    return new Throwable().getStackTrace()[2].getMethodName();
  }
  
  private Method findMethod(String paramString, Object[] paramArrayOfObject)
    throws NoSuchMethodException
  {
    Object localObject2 = this.superclass;
    if (paramArrayOfObject.length == 0) {
      paramArrayOfObject = ((Class)localObject2).getDeclaredMethod(paramString, new Class[0]);
    }
    Object localObject1;
    label121:
    do
    {
      return paramArrayOfObject;
      localObject1 = null;
      Iterator localIterator = ReflectionUtil.getAllMethods((Class)localObject2).iterator();
      while (localIterator.hasNext())
      {
        localObject2 = (Method)localIterator.next();
        if (((Method)localObject2).getName().equals(paramString))
        {
          Class[] arrayOfClass = ((Method)localObject2).getParameterTypes();
          if (arrayOfClass.length == paramArrayOfObject.length)
          {
            int i = 0;
            for (;;)
            {
              if (i >= arrayOfClass.length) {
                break label121;
              }
              if (!convertPrimitiveClass(arrayOfClass[i]).isInstance(paramArrayOfObject[i])) {
                break;
              }
              i += 1;
            }
            if (localObject1 == null) {
              localObject1 = localObject2;
            } else {
              throw new DelegationException("Duplicate matches");
            }
          }
        }
      }
      paramArrayOfObject = localObject1;
    } while (localObject1 != null);
    throw new DelegationException("Could not find method: " + paramString);
  }
  
  private Object invoke0(Method paramMethod, Object[] paramArrayOfObject)
  {
    try
    {
      writeFields(this.superclass, this.source, this.delegate);
      paramMethod.setAccessible(true);
      paramMethod = paramMethod.invoke(this.delegate, paramArrayOfObject);
      writeFields(this.superclass, this.delegate, this.source);
      return paramMethod;
    }
    catch (RuntimeException paramMethod)
    {
      throw paramMethod;
    }
    catch (InvocationTargetException paramMethod)
    {
      throw new DelegationException(paramMethod.getCause());
    }
    catch (Exception paramMethod)
    {
      throw new DelegationException(paramMethod);
    }
  }
  
  private void writeFields(Class paramClass, Object paramObject1, Object paramObject2)
    throws Exception
  {
    paramClass = paramClass.getDeclaredFields();
    int j = paramClass.length;
    int i = 0;
    while (i < j)
    {
      Object localObject = paramClass[i];
      localObject.setAccessible(true);
      localObject.set(paramObject2, localObject.get(paramObject1));
      i += 1;
    }
  }
  
  public DelegatorMethodFinder delegateTo(String paramString, Class<?>... paramVarArgs)
  {
    return new DelegatorMethodFinder(paramString, paramVarArgs);
  }
  
  public final <T> T invoke(Object... paramVarArgs)
  {
    try
    {
      paramVarArgs = invoke0(findMethod(extractMethodName(), paramVarArgs), paramVarArgs);
      return paramVarArgs;
    }
    catch (NoSuchMethodException paramVarArgs)
    {
      throw new DelegationException(paramVarArgs);
    }
  }
  
  public class DelegatorMethodFinder
  {
    private final Method method;
    
    public DelegatorMethodFinder(Class<?>... paramVarArgs)
    {
      try
      {
        Class[] arrayOfClass;
        this.method = Delegator.this.superclass.getDeclaredMethod(paramVarArgs, arrayOfClass);
        return;
      }
      catch (RuntimeException this$1)
      {
        throw Delegator.this;
      }
      catch (Exception this$1)
      {
        throw new DelegationException(Delegator.this);
      }
    }
    
    public <T> T invoke(Object... paramVarArgs)
    {
      return Delegator.this.invoke0(this.method, paramVarArgs);
    }
  }
}
