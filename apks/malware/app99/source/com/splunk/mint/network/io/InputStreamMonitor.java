package com.splunk.mint.network.io;

import com.splunk.mint.network.Counter;
import com.splunk.mint.network.MonitorRegistry;
import com.splunk.mint.network.socket.MonitoringSocketImpl;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public final class InputStreamMonitor
  extends InputStream
{
  private static final String IN_POSTFIX = "-bytes-in";
  private static final int MAX_POSSIBLE_HEADER_LENGTH = 90;
  private StringBuffer body;
  private List<Byte> chars;
  boolean contentLengthFound = false;
  private final Counter counter;
  private boolean finishedReadingHeaders = false;
  HashMap<String, List<String>> headers = new HashMap(2);
  MonitoringSocketImpl monSocIm;
  private final InputStream original;
  boolean statusCodeFound = false;
  
  public InputStreamMonitor(String paramString, MonitorRegistry paramMonitorRegistry, InputStream paramInputStream, MonitoringSocketImpl paramMonitoringSocketImpl)
  {
    this.original = paramInputStream;
    this.counter = new Counter(paramString + "-bytes-in");
    this.chars = new ArrayList();
    this.body = new StringBuffer();
    this.monSocIm = paramMonitoringSocketImpl;
    this.finishedReadingHeaders = false;
    paramMonitorRegistry.add(this.counter);
  }
  
  private void updateBody()
  {
    byte[] arrayOfByte = new byte[this.chars.size()];
    int i = 0;
    while (i < arrayOfByte.length)
    {
      arrayOfByte[i] = ((Byte)this.chars.get(i)).byteValue();
      i += 1;
    }
    this.chars.clear();
    this.body.append(new String(arrayOfByte));
    if (this.body.toString().contains("\r\n\r\n"))
    {
      this.finishedReadingHeaders = true;
      tryToReadHeaders();
    }
  }
  
  public void close()
    throws IOException
  {
    this.original.close();
  }
  
  public HashMap<String, List<String>> getHeaders()
  {
    return this.headers;
  }
  
  public int read()
    throws IOException
  {
    int i = this.original.read();
    if (i > -1) {
      this.counter.inc();
    }
    if (!this.finishedReadingHeaders)
    {
      this.chars.add(Byte.valueOf((byte)i));
      updateBody();
    }
    return i;
  }
  
  public int read(byte[] paramArrayOfByte)
    throws IOException
  {
    int j = this.original.read(paramArrayOfByte);
    if (j > -1) {
      this.counter.inc(j);
    }
    if (!this.finishedReadingHeaders)
    {
      int i = 0;
      while (i < paramArrayOfByte.length)
      {
        this.chars.add(Byte.valueOf(paramArrayOfByte[i]));
        i += 1;
      }
      updateBody();
    }
    return j;
  }
  
  public int read(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
    throws IOException
  {
    int i = this.original.read(paramArrayOfByte, paramInt1, paramInt2);
    if (i > -1) {
      this.counter.inc(i);
    }
    if (!this.finishedReadingHeaders)
    {
      while (paramInt1 < paramInt2)
      {
        this.chars.add(Byte.valueOf(paramArrayOfByte[paramInt1]));
        paramInt1 += 1;
      }
      updateBody();
    }
    return i;
  }
  
  public void tryToReadHeaders()
  {
    BufferedReader localBufferedReader = new BufferedReader(new StringReader(this.body.toString()));
    try
    {
      str1 = localBufferedReader.readLine();
      if (str1 != null) {
        if ((!this.statusCodeFound) && (str1.contains("HTTP/")))
        {
          i = str1.length();
          if (i >= 90) {}
        }
      }
    }
    catch (IOException localIOException)
    {
      try
      {
        for (;;)
        {
          String str1;
          int i;
          String str2 = str1.split(" ")[1].trim();
          this.headers.put("splk-statuscode", Arrays.asList(new String[] { str2 }));
          this.statusCodeFound = true;
          boolean bool;
          if ((!this.contentLengthFound) && (str1.contains(":")) && (str1.length() < 90))
          {
            i = str1.indexOf(":");
            if (i > -1)
            {
              str2 = str1.substring(0, i).trim();
              bool = str2.equals("Content-Length");
              if (!bool) {}
            }
          }
          try
          {
            str1 = str1.substring(i + 1, str1.length()).trim();
            this.headers.put(str2, Arrays.asList(new String[] { str1 }));
            this.contentLengthFound = true;
            if (!this.statusCodeFound) {
              continue;
            }
            bool = this.contentLengthFound;
            if (!bool) {
              continue;
            }
            for (;;)
            {
              if (this.monSocIm != null) {
                this.monSocIm.readingDone();
              }
              return;
              localIOException = localIOException;
              localIOException.printStackTrace();
            }
          }
          catch (ArrayIndexOutOfBoundsException localArrayIndexOutOfBoundsException1)
          {
            for (;;) {}
          }
        }
      }
      catch (ArrayIndexOutOfBoundsException localArrayIndexOutOfBoundsException2)
      {
        for (;;) {}
      }
    }
  }
}
