package org.apache.http.impl.conn;

import android.util.Log;
import java.io.IOException;
import java.net.ConnectException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.Arrays;
import org.apache.http.HttpHost;
import org.apache.http.annotation.Immutable;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.config.Lookup;
import org.apache.http.config.SocketConfig;
import org.apache.http.conn.ConnectTimeoutException;
import org.apache.http.conn.DnsResolver;
import org.apache.http.conn.HttpHostConnectException;
import org.apache.http.conn.ManagedHttpClientConnection;
import org.apache.http.conn.SchemePortResolver;
import org.apache.http.conn.UnsupportedSchemeException;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.LayeredConnectionSocketFactory;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.Args;

@Immutable
class HttpClientConnectionOperator
{
  static final String SOCKET_FACTORY_REGISTRY = "http.socket-factory-registry";
  private static final String TAG = "HttpClient";
  private final DnsResolver dnsResolver;
  private final SchemePortResolver schemePortResolver;
  private final Lookup<ConnectionSocketFactory> socketFactoryRegistry;
  
  HttpClientConnectionOperator(Lookup<ConnectionSocketFactory> paramLookup, SchemePortResolver paramSchemePortResolver, DnsResolver paramDnsResolver)
  {
    Args.notNull(paramLookup, "Socket factory registry");
    this.socketFactoryRegistry = paramLookup;
    if (paramSchemePortResolver != null)
    {
      this.schemePortResolver = paramSchemePortResolver;
      if (paramDnsResolver == null) {
        break label42;
      }
    }
    for (;;)
    {
      this.dnsResolver = paramDnsResolver;
      return;
      paramSchemePortResolver = DefaultSchemePortResolver.INSTANCE;
      break;
      label42:
      paramDnsResolver = SystemDefaultDnsResolver.INSTANCE;
    }
  }
  
  private static String getConnectTimeoutMessage(IOException paramIOException, HttpHost paramHttpHost, InetAddress... paramVarArgs)
  {
    StringBuilder localStringBuilder = new StringBuilder().append("Connect to ");
    if (paramHttpHost != null)
    {
      paramHttpHost = paramHttpHost.toHostString();
      localStringBuilder = localStringBuilder.append(paramHttpHost);
      if ((paramVarArgs == null) || (paramVarArgs.length <= 0)) {
        break label115;
      }
      paramHttpHost = " " + Arrays.asList(paramVarArgs);
      label60:
      paramHttpHost = localStringBuilder.append(paramHttpHost);
      if ((paramIOException == null) || (paramIOException.getMessage() == null)) {
        break label121;
      }
    }
    label115:
    label121:
    for (paramIOException = " failed: " + paramIOException.getMessage();; paramIOException = " timed out")
    {
      return paramIOException;
      paramHttpHost = "remote host";
      break;
      paramHttpHost = "";
      break label60;
    }
  }
  
  private Lookup<ConnectionSocketFactory> getSocketFactoryRegistry(HttpContext paramHttpContext)
  {
    Lookup localLookup = (Lookup)paramHttpContext.getAttribute("http.socket-factory-registry");
    paramHttpContext = localLookup;
    if (localLookup == null) {
      paramHttpContext = this.socketFactoryRegistry;
    }
    return paramHttpContext;
  }
  
  public void connect(ManagedHttpClientConnection paramManagedHttpClientConnection, HttpHost paramHttpHost, InetSocketAddress paramInetSocketAddress, int paramInt, SocketConfig paramSocketConfig, HttpContext paramHttpContext)
    throws IOException
  {
    ConnectionSocketFactory localConnectionSocketFactory = (ConnectionSocketFactory)getSocketFactoryRegistry(paramHttpContext).lookup(paramHttpHost.getSchemeName());
    if (localConnectionSocketFactory == null) {
      throw new UnsupportedSchemeException(paramHttpHost.getSchemeName() + " protocol is not supported");
    }
    InetAddress[] arrayOfInetAddress = this.dnsResolver.resolve(paramHttpHost.getHostName());
    int k = this.schemePortResolver.resolve(paramHttpHost);
    int i = 0;
    for (;;)
    {
      Object localObject;
      int j;
      label113:
      Socket localSocket;
      boolean bool;
      if (i < arrayOfInetAddress.length)
      {
        localObject = arrayOfInetAddress[i];
        if (i != arrayOfInetAddress.length - 1) {
          break label307;
        }
        j = 1;
        localSocket = localConnectionSocketFactory.createSocket(paramHttpContext);
        localSocket.setSoTimeout(paramSocketConfig.getSoTimeout());
        localSocket.setReuseAddress(paramSocketConfig.isSoReuseAddress());
        localSocket.setTcpNoDelay(paramSocketConfig.isTcpNoDelay());
        localSocket.setKeepAlive(paramSocketConfig.isSoKeepAlive());
        int m = paramSocketConfig.getSoLinger();
        if (m >= 0)
        {
          if (m <= 0) {
            break label313;
          }
          bool = true;
          localSocket.setSoLinger(bool, m);
        }
        paramManagedHttpClientConnection.bind(localSocket);
        localObject = new InetSocketAddress((InetAddress)localObject, k);
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Connecting to " + localObject);
        }
      }
      try
      {
        paramManagedHttpClientConnection.bind(localConnectionSocketFactory.connectSocket(paramInt, localSocket, paramHttpHost, (InetSocketAddress)localObject, paramInetSocketAddress, paramHttpContext));
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Connection established " + paramManagedHttpClientConnection);
        }
        return;
        label307:
        j = 0;
        break label113;
        label313:
        bool = false;
      }
      catch (SocketTimeoutException localSocketTimeoutException)
      {
        if (j != 0) {
          new ConnectTimeoutException(getConnectTimeoutMessage(localSocketTimeoutException, paramHttpHost, arrayOfInetAddress)).initCause(localSocketTimeoutException);
        }
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Connect to " + localObject + " timed out. " + "Connection will be retried using another IP address");
        }
        i += 1;
      }
      catch (ConnectException localConnectException)
      {
        while (j == 0) {}
        if ("Connection timed out".equals(localConnectException.getMessage()))
        {
          paramManagedHttpClientConnection = new ConnectTimeoutException(getConnectTimeoutMessage(localConnectException, paramHttpHost, arrayOfInetAddress));
          paramManagedHttpClientConnection.initCause(localConnectException);
          throw paramManagedHttpClientConnection;
        }
        throw new HttpHostConnectException(paramHttpHost, localConnectException);
      }
    }
  }
  
  public void upgrade(ManagedHttpClientConnection paramManagedHttpClientConnection, HttpHost paramHttpHost, HttpContext paramHttpContext)
    throws IOException
  {
    Object localObject = (ConnectionSocketFactory)getSocketFactoryRegistry(HttpClientContext.adapt(paramHttpContext)).lookup(paramHttpHost.getSchemeName());
    if (localObject == null) {
      throw new UnsupportedSchemeException(paramHttpHost.getSchemeName() + " protocol is not supported");
    }
    if (!(localObject instanceof LayeredConnectionSocketFactory)) {
      throw new UnsupportedSchemeException(paramHttpHost.getSchemeName() + " protocol does not support connection upgrade");
    }
    localObject = (LayeredConnectionSocketFactory)localObject;
    Socket localSocket = paramManagedHttpClientConnection.getSocket();
    int i = this.schemePortResolver.resolve(paramHttpHost);
    paramManagedHttpClientConnection.bind(((LayeredConnectionSocketFactory)localObject).createLayeredSocket(localSocket, paramHttpHost.getHostName(), i, paramHttpContext));
  }
}
