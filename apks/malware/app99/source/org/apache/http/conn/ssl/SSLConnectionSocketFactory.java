package org.apache.http.conn.ssl;

import android.annotation.TargetApi;
import android.os.Build.VERSION;
import android.util.Log;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.security.auth.x500.X500Principal;
import org.apache.http.HttpHost;
import org.apache.http.annotation.ThreadSafe;
import org.apache.http.conn.socket.LayeredConnectionSocketFactory;
import org.apache.http.protocol.HttpContext;
import org.apache.http.util.Args;
import org.apache.http.util.TextUtils;

@ThreadSafe
public class SSLConnectionSocketFactory
  implements LayeredConnectionSocketFactory
{
  public static final X509HostnameVerifier ALLOW_ALL_HOSTNAME_VERIFIER = new AllowAllHostnameVerifierHC4();
  public static final X509HostnameVerifier BROWSER_COMPATIBLE_HOSTNAME_VERIFIER = new BrowserCompatHostnameVerifierHC4();
  public static final String SSL = "SSL";
  public static final String SSLV2 = "SSLv2";
  public static final X509HostnameVerifier STRICT_HOSTNAME_VERIFIER = new StrictHostnameVerifierHC4();
  private static final String TAG = "HttpClient";
  public static final String TLS = "TLS";
  private final X509HostnameVerifier hostnameVerifier;
  private final SSLSocketFactory socketfactory;
  private final String[] supportedCipherSuites;
  private final String[] supportedProtocols;
  
  public SSLConnectionSocketFactory(SSLContext paramSSLContext)
  {
    this(paramSSLContext, BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
  }
  
  public SSLConnectionSocketFactory(SSLContext paramSSLContext, X509HostnameVerifier paramX509HostnameVerifier)
  {
    this(((SSLContext)Args.notNull(paramSSLContext, "SSL context")).getSocketFactory(), null, null, paramX509HostnameVerifier);
  }
  
  public SSLConnectionSocketFactory(SSLContext paramSSLContext, String[] paramArrayOfString1, String[] paramArrayOfString2, X509HostnameVerifier paramX509HostnameVerifier)
  {
    this(((SSLContext)Args.notNull(paramSSLContext, "SSL context")).getSocketFactory(), paramArrayOfString1, paramArrayOfString2, paramX509HostnameVerifier);
  }
  
  public SSLConnectionSocketFactory(SSLSocketFactory paramSSLSocketFactory, X509HostnameVerifier paramX509HostnameVerifier)
  {
    this(paramSSLSocketFactory, null, null, paramX509HostnameVerifier);
  }
  
  public SSLConnectionSocketFactory(SSLSocketFactory paramSSLSocketFactory, String[] paramArrayOfString1, String[] paramArrayOfString2, X509HostnameVerifier paramX509HostnameVerifier)
  {
    this.socketfactory = ((SSLSocketFactory)Args.notNull(paramSSLSocketFactory, "SSL socket factory"));
    this.supportedProtocols = paramArrayOfString1;
    this.supportedCipherSuites = paramArrayOfString2;
    if (paramX509HostnameVerifier != null) {}
    for (;;)
    {
      this.hostnameVerifier = paramX509HostnameVerifier;
      return;
      paramX509HostnameVerifier = BROWSER_COMPATIBLE_HOSTNAME_VERIFIER;
    }
  }
  
  public static SSLConnectionSocketFactory getSocketFactory()
    throws SSLInitializationException
  {
    return new SSLConnectionSocketFactory((SSLSocketFactory)SSLSocketFactory.getDefault(), BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
  }
  
  public static SSLConnectionSocketFactory getSystemSocketFactory()
    throws SSLInitializationException
  {
    return new SSLConnectionSocketFactory((SSLSocketFactory)SSLSocketFactory.getDefault(), split(System.getProperty("https.protocols")), split(System.getProperty("https.cipherSuites")), BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
  }
  
  private static String[] split(String paramString)
  {
    if (TextUtils.isBlank(paramString)) {
      return null;
    }
    return paramString.split(" *, *");
  }
  
  private void verifyHostname(SSLSocket paramSSLSocket, String paramString)
    throws IOException
  {
    for (;;)
    {
      Object localObject3;
      try
      {
        boolean bool = Log.isLoggable("HttpClient", 3);
        if (bool) {
          try
          {
            Object localObject1 = paramSSLSocket.getSession();
            Log.d("HttpClient", "Secure session established");
            Log.d("HttpClient", " negotiated protocol: " + ((SSLSession)localObject1).getProtocol());
            Log.d("HttpClient", " negotiated cipher suite: " + ((SSLSession)localObject1).getCipherSuite());
            localObject1 = (X509Certificate)localObject1.getPeerCertificates()[0];
            localObject2 = ((X509Certificate)localObject1).getSubjectX500Principal();
            Log.d("HttpClient", " peer principal: " + ((X500Principal)localObject2).toString());
            localObject3 = ((X509Certificate)localObject1).getSubjectAlternativeNames();
            if (localObject3 == null) {
              continue;
            }
            localObject2 = new ArrayList();
            localObject3 = ((Collection)localObject3).iterator();
            if (!((Iterator)localObject3).hasNext()) {
              continue;
            }
            List localList = (List)((Iterator)localObject3).next();
            if (localList.isEmpty()) {
              continue;
            }
            ((List)localObject2).add((String)localList.get(1));
            continue;
            this.hostnameVerifier.verify(paramString, paramSSLSocket);
          }
          catch (Exception localException) {}
        }
        return;
      }
      catch (IOException paramString) {}
      Log.d("HttpClient", " peer alternative names: " + localObject2);
      Object localObject2 = localException.getIssuerX500Principal();
      Log.d("HttpClient", " issuer principal: " + ((X500Principal)localObject2).toString());
      localObject2 = localException.getIssuerAlternativeNames();
      if (localObject2 == null) {
        continue;
      }
      ArrayList localArrayList = new ArrayList();
      localObject2 = ((Collection)localObject2).iterator();
      if (((Iterator)localObject2).hasNext())
      {
        localObject3 = (List)((Iterator)localObject2).next();
        if (((List)localObject3).isEmpty()) {
          continue;
        }
        localArrayList.add((String)((List)localObject3).get(1));
        continue;
      }
      try
      {
        paramSSLSocket.close();
        throw paramString;
        Log.d("HttpClient", " issuer alternative names: " + localArrayList);
      }
      catch (Exception paramSSLSocket)
      {
        for (;;) {}
      }
    }
  }
  
  public Socket connectSocket(int paramInt, Socket paramSocket, HttpHost paramHttpHost, InetSocketAddress paramInetSocketAddress1, InetSocketAddress paramInetSocketAddress2, HttpContext paramHttpContext)
    throws IOException
  {
    Args.notNull(paramHttpHost, "HTTP host");
    Args.notNull(paramInetSocketAddress1, "Remote address");
    if (paramSocket != null) {}
    for (;;)
    {
      if (paramInetSocketAddress2 != null) {
        paramSocket.bind(paramInetSocketAddress2);
      }
      if (paramInt > 0) {}
      try
      {
        if (paramSocket.getSoTimeout() == 0) {
          paramSocket.setSoTimeout(paramInt);
        }
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Connecting socket to " + paramInetSocketAddress1 + " with timeout " + paramInt);
        }
        paramSocket.connect(paramInetSocketAddress1, paramInt);
        if (!(paramSocket instanceof SSLSocket)) {
          break;
        }
        paramInetSocketAddress1 = (SSLSocket)paramSocket;
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Starting handshake");
        }
        paramInetSocketAddress1.startHandshake();
        verifyHostname(paramInetSocketAddress1, paramHttpHost.getHostName());
        return paramSocket;
      }
      catch (IOException paramHttpHost) {}
      paramSocket = createSocket(paramHttpContext);
    }
    try
    {
      paramSocket.close();
      throw paramHttpHost;
      return createLayeredSocket(paramSocket, paramHttpHost.getHostName(), paramInetSocketAddress1.getPort(), paramHttpContext);
    }
    catch (IOException paramSocket)
    {
      for (;;) {}
    }
  }
  
  @TargetApi(17)
  public Socket createLayeredSocket(Socket paramSocket, String paramString, int paramInt, HttpContext paramHttpContext)
    throws IOException
  {
    paramSocket = (SSLSocket)this.socketfactory.createSocket(paramSocket, paramString, paramInt, true);
    if (this.supportedProtocols != null) {
      paramSocket.setEnabledProtocols(this.supportedProtocols);
    }
    for (;;)
    {
      if (this.supportedCipherSuites != null) {
        paramSocket.setEnabledCipherSuites(this.supportedCipherSuites);
      }
      if (Log.isLoggable("HttpClient", 3))
      {
        Log.d("HttpClient", "Enabled protocols: " + Arrays.asList(paramSocket.getEnabledProtocols()));
        Log.d("HttpClient", "Enabled cipher suites:" + Arrays.asList(paramSocket.getEnabledCipherSuites()));
      }
      prepareSocket(paramSocket);
      if (Build.VERSION.SDK_INT >= 17) {
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Enabling SNI for " + paramString);
        }
      }
      try
      {
        paramSocket.getClass().getMethod("setHostname", new Class[] { String.class }).invoke(paramSocket, new Object[] { paramString });
        if (Log.isLoggable("HttpClient", 3)) {
          Log.d("HttpClient", "Starting handshake");
        }
        paramSocket.startHandshake();
        verifyHostname(paramSocket, paramString);
        return paramSocket;
        paramHttpContext = paramSocket.getEnabledProtocols();
        ArrayList localArrayList = new ArrayList(paramHttpContext.length);
        int i = paramHttpContext.length;
        paramInt = 0;
        while (paramInt < i)
        {
          Object localObject = paramHttpContext[paramInt];
          if (!localObject.startsWith("SSL")) {
            localArrayList.add(localObject);
          }
          paramInt += 1;
        }
        if (localArrayList.isEmpty()) {
          continue;
        }
        paramSocket.setEnabledProtocols((String[])localArrayList.toArray(new String[localArrayList.size()]));
      }
      catch (Exception paramHttpContext)
      {
        for (;;)
        {
          if (Log.isLoggable("HttpClient", 3)) {
            Log.d("HttpClient", "SNI configuration failed", paramHttpContext);
          }
        }
      }
    }
  }
  
  public Socket createSocket(HttpContext paramHttpContext)
    throws IOException
  {
    return SocketFactory.getDefault().createSocket();
  }
  
  X509HostnameVerifier getHostnameVerifier()
  {
    return this.hostnameVerifier;
  }
  
  protected void prepareSocket(SSLSocket paramSSLSocket)
    throws IOException
  {}
}
