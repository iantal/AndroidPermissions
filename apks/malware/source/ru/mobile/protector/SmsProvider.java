package ru.mobile.protector;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import java.util.HashMap;

public class SmsProvider
  extends ContentProvider
{
  public static final Uri CONTENT_URI = Uri.parse("content://com.samples.servicelaunch.smsprovider/smsdb");
  public static String DATABASE_NAME = "smsdb";
  public static int DATABASE_VERSION = 2;
  public static final int URI_CODE = 1;
  public static final int URI_CODE_ID = 2;
  private static SQLiteDatabase db;
  private static HashMap<String, String> mContactMap;
  private static final UriMatcher mUriMatcher = new UriMatcher(-1);
  
  static
  {
    mUriMatcher.addURI(CONTENT_URI.toString(), "smsdb", 1);
    mUriMatcher.addURI(CONTENT_URI.toString(), "smsdb/#", 2);
    mContactMap = new HashMap();
    mContactMap.put("_ID", "_ID");
    mContactMap.put("smslist_id", "smslist_id");
    mContactMap.put("smstext", "smstext");
    mContactMap.put("smsdate", "smsdate");
    mContactMap.put("name", "name");
    mContactMap.put("number", "number");
    mContactMap.put("type", "type");
  }
  
  public SmsProvider() {}
  
  public static SQLiteDatabase getDb()
  {
    return db;
  }
  
  public int delete(Uri paramUri, String paramString, String[] paramArrayOfString)
  {
    int i = db.delete("smsdb", paramString, paramArrayOfString);
    getContext().getContentResolver().notifyChange(paramUri, null);
    return i;
  }
  
  public String getDbName()
  {
    return "smsdb";
  }
  
  public String getType(Uri paramUri)
  {
    return null;
  }
  
  public Uri insert(Uri paramUri, ContentValues paramContentValues)
  {
    paramContentValues = new ContentValues(paramContentValues);
    long l = db.insert("smsdb", "smslist_id", paramContentValues);
    if (l > 0L)
    {
      paramUri = ContentUris.withAppendedId(CONTENT_URI, l);
      getContext().getContentResolver().notifyChange(paramUri, null);
      return paramUri;
    }
    throw new SQLException("Failed to insert row into " + paramUri);
  }
  
  public boolean onCreate()
  {
    db = new SmsDBHelper(getContext()).getWritableDatabase();
    return db != null;
  }
  
  public Cursor query(Uri paramUri, String[] paramArrayOfString1, String paramString1, String[] paramArrayOfString2, String paramString2)
  {
    SQLiteQueryBuilder localSQLiteQueryBuilder = new SQLiteQueryBuilder();
    localSQLiteQueryBuilder.setTables("smsdb");
    localSQLiteQueryBuilder.setProjectionMap(mContactMap);
    paramArrayOfString1 = localSQLiteQueryBuilder.query(db, paramArrayOfString1, paramString1, paramArrayOfString2, null, null, paramString2);
    paramArrayOfString1.setNotificationUri(getContext().getContentResolver(), paramUri);
    return paramArrayOfString1;
  }
  
  public int update(Uri paramUri, ContentValues paramContentValues, String paramString, String[] paramArrayOfString)
  {
    int i = db.update("smsdb", paramContentValues, paramString, paramArrayOfString);
    getContext().getContentResolver().notifyChange(paramUri, null);
    return i;
  }
}
