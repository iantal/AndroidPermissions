package org.jsoup.select;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import org.jsoup.helper.StringUtil;
import org.jsoup.helper.Validate;
import org.jsoup.parser.TokenQueue;

class QueryParser
{
  private static final String[] combinators = { ",", ">", "+", "~", " " };
  private List<Evaluator> evals = new ArrayList();
  private String query;
  private TokenQueue tq;
  
  private QueryParser(String paramString)
  {
    this.query = paramString;
    this.tq = new TokenQueue(paramString);
  }
  
  private void allElements()
  {
    this.evals.add(new Evaluator.AllElements());
  }
  
  private void byAttribute()
  {
    TokenQueue localTokenQueue = new TokenQueue(this.tq.chompBalanced('[', ']'));
    String str = localTokenQueue.consumeToAny(new String[] { "=", "!=", "^=", "$=", "*=", "~=" });
    Validate.notEmpty(str);
    localTokenQueue.consumeWhitespace();
    if (localTokenQueue.isEmpty())
    {
      if (str.startsWith("^"))
      {
        this.evals.add(new Evaluator.AttributeStarting(str.substring(1)));
        return;
      }
      this.evals.add(new Evaluator.Attribute(str));
      return;
    }
    if (localTokenQueue.matchChomp("="))
    {
      this.evals.add(new Evaluator.AttributeWithValue(str, localTokenQueue.remainder()));
      return;
    }
    if (localTokenQueue.matchChomp("!="))
    {
      this.evals.add(new Evaluator.AttributeWithValueNot(str, localTokenQueue.remainder()));
      return;
    }
    if (localTokenQueue.matchChomp("^="))
    {
      this.evals.add(new Evaluator.AttributeWithValueStarting(str, localTokenQueue.remainder()));
      return;
    }
    if (localTokenQueue.matchChomp("$="))
    {
      this.evals.add(new Evaluator.AttributeWithValueEnding(str, localTokenQueue.remainder()));
      return;
    }
    if (localTokenQueue.matchChomp("*="))
    {
      this.evals.add(new Evaluator.AttributeWithValueContaining(str, localTokenQueue.remainder()));
      return;
    }
    if (localTokenQueue.matchChomp("~="))
    {
      this.evals.add(new Evaluator.AttributeWithValueMatching(str, Pattern.compile(localTokenQueue.remainder())));
      return;
    }
    throw new Selector.SelectorParseException("Could not parse attribute query '%s': unexpected token at '%s'", new Object[] { this.query, localTokenQueue.remainder() });
  }
  
  private void byClass()
  {
    String str = this.tq.consumeCssIdentifier();
    Validate.notEmpty(str);
    this.evals.add(new Evaluator.Class(str.trim().toLowerCase()));
  }
  
  private void byId()
  {
    String str = this.tq.consumeCssIdentifier();
    Validate.notEmpty(str);
    this.evals.add(new Evaluator.Id(str));
  }
  
  private void byTag()
  {
    String str2 = this.tq.consumeElementSelector();
    Validate.notEmpty(str2);
    String str1 = str2;
    if (str2.contains("|")) {
      str1 = str2.replace("|", ":");
    }
    this.evals.add(new Evaluator.Tag(str1.trim().toLowerCase()));
  }
  
  private void combinator(char paramChar)
  {
    this.tq.consumeWhitespace();
    Object localObject2 = consumeSubQuery();
    if (this.evals.size() == 1) {}
    for (Object localObject1 = (Evaluator)this.evals.get(0);; localObject1 = new CombiningEvaluator.And(this.evals))
    {
      this.evals.clear();
      localObject2 = parse((String)localObject2);
      if (paramChar != '>') {
        break;
      }
      this.evals.add(new CombiningEvaluator.And(new Evaluator[] { localObject2, new StructuralEvaluator.ImmediateParent((Evaluator)localObject1) }));
      return;
    }
    if (paramChar == ' ')
    {
      this.evals.add(new CombiningEvaluator.And(new Evaluator[] { localObject2, new StructuralEvaluator.Parent((Evaluator)localObject1) }));
      return;
    }
    if (paramChar == '+')
    {
      this.evals.add(new CombiningEvaluator.And(new Evaluator[] { localObject2, new StructuralEvaluator.ImmediatePreviousSibling((Evaluator)localObject1) }));
      return;
    }
    if (paramChar == '~')
    {
      this.evals.add(new CombiningEvaluator.And(new Evaluator[] { localObject2, new StructuralEvaluator.PreviousSibling((Evaluator)localObject1) }));
      return;
    }
    throw new Selector.SelectorParseException("Unknown combinator: " + paramChar, new Object[0]);
  }
  
  private int consumeIndex()
  {
    String str = this.tq.chompTo(")").trim();
    Validate.isTrue(StringUtil.isNumeric(str), "Index must be numeric");
    return Integer.parseInt(str);
  }
  
  private String consumeSubQuery()
  {
    StringBuilder localStringBuilder = new StringBuilder();
    for (;;)
    {
      if (!this.tq.isEmpty())
      {
        if (this.tq.matches("("))
        {
          localStringBuilder.append("(").append(this.tq.chompBalanced('(', ')')).append(")");
          continue;
        }
        if (this.tq.matches("["))
        {
          localStringBuilder.append("[").append(this.tq.chompBalanced('[', ']')).append("]");
          continue;
        }
        if (!this.tq.matchesAny(combinators)) {}
      }
      else
      {
        return localStringBuilder.toString();
      }
      localStringBuilder.append(this.tq.consume());
    }
  }
  
  private void contains(boolean paramBoolean)
  {
    TokenQueue localTokenQueue = this.tq;
    if (paramBoolean) {}
    for (String str = ":containsOwn";; str = ":contains")
    {
      localTokenQueue.consume(str);
      str = TokenQueue.unescape(this.tq.chompBalanced('(', ')'));
      Validate.notEmpty(str, ":contains(text) query must not be empty");
      if (!paramBoolean) {
        break;
      }
      this.evals.add(new Evaluator.ContainsOwnText(str));
      return;
    }
    this.evals.add(new Evaluator.ContainsText(str));
  }
  
  private void findElements()
  {
    if (this.tq.matchChomp("#"))
    {
      byId();
      return;
    }
    if (this.tq.matchChomp("."))
    {
      byClass();
      return;
    }
    if (this.tq.matchesWord())
    {
      byTag();
      return;
    }
    if (this.tq.matches("["))
    {
      byAttribute();
      return;
    }
    if (this.tq.matchChomp("*"))
    {
      allElements();
      return;
    }
    if (this.tq.matchChomp(":lt("))
    {
      indexLessThan();
      return;
    }
    if (this.tq.matchChomp(":gt("))
    {
      indexGreaterThan();
      return;
    }
    if (this.tq.matchChomp(":eq("))
    {
      indexEquals();
      return;
    }
    if (this.tq.matches(":has("))
    {
      has();
      return;
    }
    if (this.tq.matches(":contains("))
    {
      contains(false);
      return;
    }
    if (this.tq.matches(":containsOwn("))
    {
      contains(true);
      return;
    }
    if (this.tq.matches(":matches("))
    {
      matches(false);
      return;
    }
    if (this.tq.matches(":matchesOwn("))
    {
      matches(true);
      return;
    }
    if (this.tq.matches(":not("))
    {
      not();
      return;
    }
    throw new Selector.SelectorParseException("Could not parse query '%s': unexpected token at '%s'", new Object[] { this.query, this.tq.remainder() });
  }
  
  private void has()
  {
    this.tq.consume(":has");
    String str = this.tq.chompBalanced('(', ')');
    Validate.notEmpty(str, ":has(el) subselect must not be empty");
    this.evals.add(new StructuralEvaluator.Has(parse(str)));
  }
  
  private void indexEquals()
  {
    this.evals.add(new Evaluator.IndexEquals(consumeIndex()));
  }
  
  private void indexGreaterThan()
  {
    this.evals.add(new Evaluator.IndexGreaterThan(consumeIndex()));
  }
  
  private void indexLessThan()
  {
    this.evals.add(new Evaluator.IndexLessThan(consumeIndex()));
  }
  
  private void matches(boolean paramBoolean)
  {
    TokenQueue localTokenQueue = this.tq;
    if (paramBoolean) {}
    for (String str = ":matchesOwn";; str = ":matches")
    {
      localTokenQueue.consume(str);
      str = this.tq.chompBalanced('(', ')');
      Validate.notEmpty(str, ":matches(regex) query must not be empty");
      if (!paramBoolean) {
        break;
      }
      this.evals.add(new Evaluator.MatchesOwn(Pattern.compile(str)));
      return;
    }
    this.evals.add(new Evaluator.Matches(Pattern.compile(str)));
  }
  
  private void not()
  {
    this.tq.consume(":not");
    String str = this.tq.chompBalanced('(', ')');
    Validate.notEmpty(str, ":not(selector) subselect must not be empty");
    this.evals.add(new StructuralEvaluator.Not(parse(str)));
  }
  
  public static Evaluator parse(String paramString)
  {
    return new QueryParser(paramString).parse();
  }
  
  Evaluator parse()
  {
    this.tq.consumeWhitespace();
    if (this.tq.matchesAny(combinators))
    {
      this.evals.add(new StructuralEvaluator.Root());
      combinator(this.tq.consume());
    }
    while (!this.tq.isEmpty())
    {
      boolean bool = this.tq.consumeWhitespace();
      if (this.tq.matchChomp(","))
      {
        CombiningEvaluator.Or localOr = new CombiningEvaluator.Or(this.evals);
        this.evals.clear();
        this.evals.add(localOr);
        while (!this.tq.isEmpty()) {
          localOr.add(parse(this.tq.chompTo(",")));
        }
        continue;
        findElements();
      }
      else if (this.tq.matchesAny(combinators))
      {
        combinator(this.tq.consume());
      }
      else if (bool)
      {
        combinator(' ');
      }
      else
      {
        findElements();
      }
    }
    if (this.evals.size() == 1) {
      return (Evaluator)this.evals.get(0);
    }
    return new CombiningEvaluator.And(this.evals);
  }
}
