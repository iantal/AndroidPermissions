package org.jsoup.parser;

import java.util.ArrayList;
import java.util.List;
import org.jsoup.helper.Validate;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.Entities;

class Tokeniser
{
  static final char replacementChar = 'ï¿½';
  private StringBuilder charBuffer = new StringBuilder();
  Token.Comment commentPending;
  StringBuilder dataBuffer;
  Token.Doctype doctypePending;
  private Token emitPending;
  private List<ParseError> errors = new ArrayList();
  private boolean isEmitPending = false;
  private Token.StartTag lastStartTag;
  private CharacterReader reader;
  private boolean selfClosingFlagAcknowledged = true;
  private TokeniserState state = TokeniserState.Data;
  Token.Tag tagPending;
  private boolean trackErrors = true;
  
  Tokeniser(CharacterReader paramCharacterReader)
  {
    this.reader = paramCharacterReader;
  }
  
  private void characterReferenceError()
  {
    if (this.trackErrors) {
      this.errors.add(new ParseError("Invalid character reference", this.reader.pos()));
    }
  }
  
  private void error(String paramString)
  {
    if (this.trackErrors) {
      this.errors.add(new ParseError(paramString, this.reader.pos()));
    }
  }
  
  void acknowledgeSelfClosingFlag()
  {
    this.selfClosingFlagAcknowledged = true;
  }
  
  void advanceTransition(TokeniserState paramTokeniserState)
  {
    this.reader.advance();
    this.state = paramTokeniserState;
  }
  
  String appropriateEndTagName()
  {
    return this.lastStartTag.tagName;
  }
  
  Character consumeCharacterReference(Character paramCharacter, boolean paramBoolean)
  {
    if (this.reader.isEmpty()) {}
    do
    {
      do
      {
        return null;
      } while ((paramCharacter != null) && (paramCharacter.charValue() == this.reader.current()));
    } while (this.reader.matchesAny(new char[] { 9, 10, 12, 60, 38 }));
    this.reader.mark();
    int j;
    int i;
    if (this.reader.matchConsume("#"))
    {
      paramBoolean = this.reader.matchConsumeIgnoreCase("X");
      if (paramBoolean) {}
      for (paramCharacter = this.reader.consumeHexSequence(); paramCharacter.length() == 0; paramCharacter = this.reader.consumeDigitSequence())
      {
        characterReferenceError();
        this.reader.rewindToMark();
        return null;
      }
      if (!this.reader.matchConsume(";")) {
        characterReferenceError();
      }
      j = -1;
      if (paramBoolean) {
        i = 16;
      }
    }
    try
    {
      for (;;)
      {
        i = Integer.valueOf(paramCharacter, i).intValue();
        if ((i != -1) && ((i < 55296) || (i > 57343)) && (i <= 1114111)) {
          break;
        }
        characterReferenceError();
        return Character.valueOf(65533);
        i = 10;
      }
      return Character.valueOf((char)i);
      paramCharacter = this.reader.consumeLetterSequence();
      boolean bool = this.reader.matches(';');
      i = 0;
      while ((paramCharacter.length() > 0) && (i == 0)) {
        if (Entities.isNamedEntity(paramCharacter))
        {
          i = 1;
        }
        else
        {
          paramCharacter = paramCharacter.substring(0, paramCharacter.length() - 1);
          this.reader.unconsume();
        }
      }
      if (i == 0)
      {
        if (bool) {
          characterReferenceError();
        }
        this.reader.rewindToMark();
        return null;
      }
      if ((paramBoolean) && ((this.reader.matchesLetter()) || (this.reader.matchesDigit()) || (this.reader.matches('='))))
      {
        this.reader.rewindToMark();
        return null;
      }
      if (!this.reader.matchConsume(";")) {
        characterReferenceError();
      }
      return Entities.getCharacterByName(paramCharacter);
    }
    catch (NumberFormatException paramCharacter)
    {
      for (;;)
      {
        i = j;
      }
    }
  }
  
  void createCommentPending()
  {
    this.commentPending = new Token.Comment();
  }
  
  void createDoctypePending()
  {
    this.doctypePending = new Token.Doctype();
  }
  
  Token.Tag createTagPending(boolean paramBoolean)
  {
    if (paramBoolean) {}
    for (Object localObject = new Token.StartTag();; localObject = new Token.EndTag())
    {
      this.tagPending = ((Token.Tag)localObject);
      return this.tagPending;
    }
  }
  
  void createTempBuffer()
  {
    this.dataBuffer = new StringBuilder();
  }
  
  boolean currentNodeInHtmlNS()
  {
    return true;
  }
  
  void emit(char paramChar)
  {
    this.charBuffer.append(paramChar);
  }
  
  void emit(String paramString)
  {
    this.charBuffer.append(paramString);
  }
  
  void emit(Token paramToken)
  {
    Validate.isFalse(this.isEmitPending, "There is an unread token pending!");
    this.emitPending = paramToken;
    this.isEmitPending = true;
    if (paramToken.type == Token.TokenType.StartTag)
    {
      paramToken = (Token.StartTag)paramToken;
      this.lastStartTag = paramToken;
      if (paramToken.selfClosing) {
        this.selfClosingFlagAcknowledged = false;
      }
    }
    while ((paramToken.type != Token.TokenType.EndTag) || (((Token.EndTag)paramToken).attributes.size() <= 0)) {
      return;
    }
    error("Attributes incorrectly present on end tag");
  }
  
  void emitCommentPending()
  {
    emit(this.commentPending);
  }
  
  void emitDoctypePending()
  {
    emit(this.doctypePending);
  }
  
  void emitTagPending()
  {
    this.tagPending.finaliseTag();
    emit(this.tagPending);
  }
  
  void eofError(TokeniserState paramTokeniserState)
  {
    if (this.trackErrors) {
      this.errors.add(new ParseError("Unexpectedly reached end of file (EOF)", paramTokeniserState, this.reader.pos()));
    }
  }
  
  void error(TokeniserState paramTokeniserState)
  {
    if (this.trackErrors) {
      this.errors.add(new ParseError("Unexpected character in input", this.reader.current(), paramTokeniserState, this.reader.pos()));
    }
  }
  
  TokeniserState getState()
  {
    return this.state;
  }
  
  boolean isAppropriateEndTagToken()
  {
    return this.tagPending.tagName.equals(this.lastStartTag.tagName);
  }
  
  boolean isTrackErrors()
  {
    return this.trackErrors;
  }
  
  Token read()
  {
    if (!this.selfClosingFlagAcknowledged)
    {
      error("Self closing flag not acknowledged");
      this.selfClosingFlagAcknowledged = true;
    }
    while (!this.isEmitPending) {
      this.state.read(this, this.reader);
    }
    if (this.charBuffer.length() > 0)
    {
      String str = this.charBuffer.toString();
      this.charBuffer.delete(0, this.charBuffer.length());
      return new Token.Character(str);
    }
    this.isEmitPending = false;
    return this.emitPending;
  }
  
  void setTrackErrors(boolean paramBoolean)
  {
    this.trackErrors = paramBoolean;
  }
  
  void transition(TokeniserState paramTokeniserState)
  {
    this.state = paramTokeniserState;
  }
}
