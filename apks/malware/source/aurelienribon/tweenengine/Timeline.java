package aurelienribon.tweenengine;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class Timeline
  extends BaseTween
{
  static final Pool pool;
  private static final Pool.Callback poolCallback;
  private final List children = new ArrayList(10);
  private Timeline current;
  private boolean isBuilt;
  private Timeline.Modes mode;
  private Timeline parent;
  
  static
  {
    if (!Timeline.class.desiredAssertionStatus()) {}
    for (boolean bool = true;; bool = false)
    {
      $assertionsDisabled = bool;
      poolCallback = new Timeline.1();
      pool = new Timeline.2(10, poolCallback);
      return;
    }
  }
  
  private Timeline()
  {
    reset();
  }
  
  public static Timeline createParallel()
  {
    Timeline localTimeline = (Timeline)pool.get();
    localTimeline.setup(Timeline.Modes.PARALLEL);
    return localTimeline;
  }
  
  public static Timeline createSequence()
  {
    Timeline localTimeline = (Timeline)pool.get();
    localTimeline.setup(Timeline.Modes.SEQUENCE);
    return localTimeline;
  }
  
  public static void ensurePoolCapacity(int paramInt)
  {
    pool.ensureCapacity(paramInt);
  }
  
  public static int getPoolSize()
  {
    return pool.size();
  }
  
  private void setup(Timeline.Modes paramModes)
  {
    this.mode = paramModes;
    this.current = this;
  }
  
  public final Timeline beginParallel()
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    Timeline localTimeline = (Timeline)pool.get();
    localTimeline.parent = this.current;
    localTimeline.mode = Timeline.Modes.PARALLEL;
    this.current.children.add(localTimeline);
    this.current = localTimeline;
    return this;
  }
  
  public final Timeline beginSequence()
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    Timeline localTimeline = (Timeline)pool.get();
    localTimeline.parent = this.current;
    localTimeline.mode = Timeline.Modes.SEQUENCE;
    this.current.children.add(localTimeline);
    this.current = localTimeline;
    return this;
  }
  
  public final Timeline build()
  {
    if (this.isBuilt) {
      return this;
    }
    this.duration = 0.0F;
    int i = 0;
    if (i < this.children.size())
    {
      BaseTween localBaseTween = (BaseTween)this.children.get(i);
      if (localBaseTween.getRepeatCount() < 0) {
        throw new RuntimeException("You can't push an object with infinite repetitions in a timeline");
      }
      localBaseTween.build();
      switch (Timeline.3.$SwitchMap$aurelienribon$tweenengine$Timeline$Modes[this.mode.ordinal()])
      {
      }
      for (;;)
      {
        i += 1;
        break;
        float f = this.duration;
        this.duration += localBaseTween.getFullDuration();
        localBaseTween.delay = (f + localBaseTween.delay);
        continue;
        this.duration = Math.max(this.duration, localBaseTween.getFullDuration());
      }
    }
    this.isBuilt = true;
    return this;
  }
  
  protected final boolean containsTarget(Object paramObject)
  {
    int j = this.children.size();
    int i = 0;
    while (i < j)
    {
      if (((BaseTween)this.children.get(i)).containsTarget(paramObject)) {
        return true;
      }
      i += 1;
    }
    return false;
  }
  
  protected final boolean containsTarget(Object paramObject, int paramInt)
  {
    int j = this.children.size();
    int i = 0;
    while (i < j)
    {
      if (((BaseTween)this.children.get(i)).containsTarget(paramObject, paramInt)) {
        return true;
      }
      i += 1;
    }
    return false;
  }
  
  public final Timeline end()
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    if (this.current == this) {
      throw new RuntimeException("Nothing to end...");
    }
    this.current = this.current.parent;
    return this;
  }
  
  protected final void forceEndValues()
  {
    int j = this.children.size();
    int i = 0;
    while (i < j)
    {
      ((BaseTween)this.children.get(i)).forceToEnd(this.duration);
      i += 1;
    }
  }
  
  protected final void forceStartValues()
  {
    int i = this.children.size() - 1;
    while (i >= 0)
    {
      ((BaseTween)this.children.get(i)).forceToStart();
      i -= 1;
    }
  }
  
  public final void free()
  {
    int i = this.children.size() - 1;
    while (i >= 0)
    {
      ((BaseTween)this.children.remove(i)).free();
      i -= 1;
    }
    pool.free(this);
  }
  
  public final List getChildren()
  {
    if (this.isBuilt) {
      return Collections.unmodifiableList(this.current.children);
    }
    return this.current.children;
  }
  
  public final Timeline push(Timeline paramTimeline)
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    if (paramTimeline.current != paramTimeline) {
      throw new RuntimeException("You forgot to call a few 'end()' statements in your pushed timeline");
    }
    paramTimeline.parent = this.current;
    this.current.children.add(paramTimeline);
    return this;
  }
  
  public final Timeline push(Tween paramTween)
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    this.current.children.add(paramTween);
    return this;
  }
  
  public final Timeline pushPause(float paramFloat)
  {
    if (this.isBuilt) {
      throw new RuntimeException("You can't push anything to a timeline once it is started");
    }
    this.current.children.add(Tween.mark().delay(paramFloat));
    return this;
  }
  
  protected final void reset()
  {
    super.reset();
    this.children.clear();
    this.parent = null;
    this.current = null;
    this.isBuilt = false;
  }
  
  public final Timeline start()
  {
    super.start();
    int i = 0;
    while (i < this.children.size())
    {
      ((BaseTween)this.children.get(i)).start();
      i += 1;
    }
    return this;
  }
  
  protected final void updateOverride(int paramInt1, int paramInt2, boolean paramBoolean, float paramFloat)
  {
    if ((!paramBoolean) && (paramInt1 > paramInt2))
    {
      assert (paramFloat >= 0.0F);
      paramInt2 = this.children.size();
      paramInt1 = 0;
    }
    while (paramInt1 < paramInt2)
    {
      ((BaseTween)this.children.get(paramInt1)).update(paramFloat + 1.0F);
      paramInt1 += 1;
      continue;
      if ((!paramBoolean) && (paramInt1 < paramInt2))
      {
        assert (paramFloat <= 0.0F);
        paramInt1 = this.children.size() - 1;
      }
      while (paramInt1 >= 0)
      {
        ((BaseTween)this.children.get(paramInt1)).update(paramFloat - 1.0F);
        paramInt1 -= 1;
        continue;
        assert (paramBoolean);
        if (paramInt1 > paramInt2)
        {
          if (isReverse(paramInt1))
          {
            forceEndValues();
            paramInt2 = this.children.size();
            paramInt1 = 0;
            while (paramInt1 < paramInt2)
            {
              ((BaseTween)this.children.get(paramInt1)).update(paramFloat);
              paramInt1 += 1;
            }
          }
          forceStartValues();
          paramInt2 = this.children.size();
          paramInt1 = 0;
          while (paramInt1 < paramInt2)
          {
            ((BaseTween)this.children.get(paramInt1)).update(paramFloat);
            paramInt1 += 1;
          }
        }
        if (paramInt1 < paramInt2)
        {
          if (isReverse(paramInt1))
          {
            forceStartValues();
            paramInt1 = this.children.size() - 1;
            while (paramInt1 >= 0)
            {
              ((BaseTween)this.children.get(paramInt1)).update(paramFloat);
              paramInt1 -= 1;
            }
          }
          forceEndValues();
          paramInt1 = this.children.size() - 1;
          while (paramInt1 >= 0)
          {
            ((BaseTween)this.children.get(paramInt1)).update(paramFloat);
            paramInt1 -= 1;
          }
        }
        if (isReverse(paramInt1)) {}
        for (float f = -paramFloat; paramFloat >= 0.0F; f = paramFloat)
        {
          paramInt2 = this.children.size();
          paramInt1 = 0;
          while (paramInt1 < paramInt2)
          {
            ((BaseTween)this.children.get(paramInt1)).update(f);
            paramInt1 += 1;
          }
        }
        paramInt1 = this.children.size() - 1;
        while (paramInt1 >= 0)
        {
          ((BaseTween)this.children.get(paramInt1)).update(f);
          paramInt1 -= 1;
        }
      }
    }
  }
}
