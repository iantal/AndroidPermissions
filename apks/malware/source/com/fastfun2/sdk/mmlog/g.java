package com.fastfun2.sdk.mmlog;

import android.util.Base64;
import java.io.ByteArrayOutputStream;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;

public final class g
{
  private static RSAPrivateKey a;
  private static RSAPublicKey b;
  
  public g() {}
  
  private static void a()
  {
    if ((b == null) || (a == null)) {
      localObject = null;
    }
    try
    {
      KeyPairGenerator localKeyPairGenerator = KeyPairGenerator.getInstance("RSA");
      localObject = localKeyPairGenerator;
    }
    catch (NoSuchAlgorithmException localNoSuchAlgorithmException)
    {
      for (;;)
      {
        localNoSuchAlgorithmException.printStackTrace();
      }
    }
    ((KeyPairGenerator)localObject).initialize(1024, new SecureRandom());
    Object localObject = ((KeyPairGenerator)localObject).generateKeyPair();
    b = (RSAPublicKey)((KeyPair)localObject).getPublic();
    a = (RSAPrivateKey)((KeyPair)localObject).getPrivate();
  }
  
  public static byte[] a(byte[] paramArrayOfByte, String paramString)
  {
    if ((paramArrayOfByte != null) && (paramString != null))
    {
      paramString = new X509EncodedKeySpec(Base64.decode(paramString, 0));
      paramString = KeyFactory.getInstance("RSA").generatePublic(paramString);
      Cipher localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
      localCipher.init(1, paramString);
      int k = paramArrayOfByte.length;
      ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
      int j = 0;
      int i = 0;
      if (k - i <= 0)
      {
        paramArrayOfByte = localByteArrayOutputStream.toByteArray();
        localByteArrayOutputStream.close();
        return paramArrayOfByte;
      }
      if (k - i > 117) {}
      for (paramString = localCipher.doFinal(paramArrayOfByte, i, 117);; paramString = localCipher.doFinal(paramArrayOfByte, i, k - i))
      {
        localByteArrayOutputStream.write(paramString, 0, paramString.length);
        j += 1;
        i = j * 117;
        break;
      }
    }
    throw new IllegalArgumentException("encryptByPublicKey data||publicKey is null");
  }
  
  private static String b()
  {
    return Base64.encodeToString(a.getEncoded(), 2);
  }
  
  private static byte[] b(byte[] paramArrayOfByte, String paramString)
  {
    Object localObject = null;
    int i = 0;
    if (paramString == null) {
      return null;
    }
    try
    {
      paramString = new PKCS8EncodedKeySpec(Base64.decode(paramString, 0));
      paramString = KeyFactory.getInstance("RSA").generatePrivate(paramString);
      localCipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
      localCipher.init(2, paramString);
      k = paramArrayOfByte.length;
      localByteArrayOutputStream = new ByteArrayOutputStream();
      j = 0;
      if (k - j > 0) {
        break label96;
      }
      paramArrayOfByte = localByteArrayOutputStream.toByteArray();
      try
      {
        localByteArrayOutputStream.close();
        return paramArrayOfByte;
      }
      catch (Exception localException)
      {
        paramString = paramArrayOfByte;
        paramArrayOfByte = localException;
      }
    }
    catch (Exception paramArrayOfByte)
    {
      for (;;)
      {
        Cipher localCipher;
        int k;
        ByteArrayOutputStream localByteArrayOutputStream;
        int j;
        label96:
        paramString = localException;
      }
    }
    paramArrayOfByte.printStackTrace();
    return paramString;
    if (k - j > 128) {}
    for (paramString = localCipher.doFinal(paramArrayOfByte, j, 128);; paramString = localCipher.doFinal(paramArrayOfByte, j, k - j))
    {
      localByteArrayOutputStream.write(paramString, 0, paramString.length);
      i += 1;
      j = i * 128;
      break;
    }
  }
  
  private static String c()
  {
    return Base64.encodeToString(b.getEncoded(), 2);
  }
}
