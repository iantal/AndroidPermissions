package com.tencent.android.tpush.service.channel.c;

import java.io.IOException;
import java.io.InputStream;

public class b
  extends InputStream
{
  protected b(a paramA) {}
  
  public int available()
  {
    synchronized (this.a)
    {
      if (this.a.i) {
        throw new IOException("InputStream has been closed, it is not ready.");
      }
    }
    int i = a.a(this.a);
    return i;
  }
  
  public void close()
  {
    synchronized (this.a)
    {
      this.a.i = true;
      return;
    }
  }
  
  public void mark(int paramInt)
  {
    synchronized (this.a)
    {
      if (this.a.a.length - 1 > paramInt)
      {
        this.a.e = paramInt;
        this.a.d = this.a.b;
      }
      return;
    }
  }
  
  public boolean markSupported()
  {
    return true;
  }
  
  public int read()
  {
    for (;;)
    {
      synchronized (this.a)
      {
        if (this.a.i) {
          throw new IOException("InputStream has been closed; cannot read from a closed InputStream.");
        }
      }
      if (a.a(this.a) > 0)
      {
        int i = this.a.a[this.a.b];
        a localA2 = this.a;
        localA2.b += 1;
        if (this.a.b == this.a.a.length) {
          this.a.b = 0;
        }
        a.b(this.a);
        return i & 0xFF;
      }
      if (this.a.k) {
        return -1;
      }
      try
      {
        Thread.sleep(100L);
      }
      catch (Exception localException)
      {
        throw new IOException("Blocking read operation interrupted.");
      }
    }
  }
  
  public int read(byte[] paramArrayOfByte)
  {
    return read(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  public int read(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    for (;;)
    {
      synchronized (this.a)
      {
        if (this.a.i) {
          throw new IOException("InputStream has been closed; cannot read from a closed InputStream.");
        }
      }
      int i = a.a(this.a);
      if (i > 0)
      {
        paramInt2 = Math.min(paramInt2, i);
        i = Math.min(paramInt2, this.a.a.length - this.a.b);
        int j = paramInt2 - i;
        System.arraycopy(this.a.a, this.a.b, paramArrayOfByte, paramInt1, i);
        if (j > 0) {
          System.arraycopy(this.a.a, 0, paramArrayOfByte, i + paramInt1, j);
        }
        for (this.a.b = j;; paramArrayOfByte.b += paramInt2)
        {
          if (this.a.b == this.a.a.length) {
            this.a.b = 0;
          }
          a.b(this.a);
          return paramInt2;
          paramArrayOfByte = this.a;
        }
      }
      if (this.a.k) {
        return -1;
      }
      try
      {
        Thread.sleep(100L);
      }
      catch (Exception paramArrayOfByte)
      {
        throw new IOException("Blocking read operation interrupted.");
      }
    }
  }
  
  public void reset()
  {
    synchronized (this.a)
    {
      if (this.a.i) {
        throw new IOException("InputStream has been closed; cannot reset a closed InputStream.");
      }
    }
    this.a.b = this.a.d;
  }
  
  public long skip(long paramLong)
  {
    for (;;)
    {
      synchronized (this.a)
      {
        if (this.a.i) {
          throw new IOException("InputStream has been closed; cannot skip bytes on a closed InputStream.");
        }
      }
      int i = a.a(this.a);
      if (i > 0)
      {
        i = Math.min((int)paramLong, i);
        int j = i - Math.min(i, this.a.a.length - this.a.b);
        if (j > 0) {}
        a localA2;
        for (this.a.b = j;; localA2.b += i)
        {
          if (this.a.b == this.a.a.length) {
            this.a.b = 0;
          }
          a.b(this.a);
          paramLong = i;
          return paramLong;
          localA2 = this.a;
        }
      }
      if (this.a.k) {
        return 0L;
      }
      try
      {
        Thread.sleep(100L);
      }
      catch (Exception localException)
      {
        throw new IOException("Blocking read operation interrupted.");
      }
    }
  }
}
