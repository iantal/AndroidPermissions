package com.tencent.msdk.tea;

import com.tencent.msdk.tools.HexUtil;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Random;

public class TEACoding
{
  private static Random random = new Random();
  private int contextStart;
  private int crypt;
  private boolean header;
  private byte[] key;
  private byte[] out;
  private int padding;
  private byte[] plain;
  private int pos;
  private int preCrypt;
  private byte[] prePlain;
  
  public TEACoding(byte[] paramArrayOfByte)
  {
    if ((paramArrayOfByte == null) || (paramArrayOfByte.length != 16)) {
      throw new IllegalArgumentException("Key length must be 16!");
    }
    this.header = true;
    this.key = paramArrayOfByte;
  }
  
  private byte[] decipher(byte[] paramArrayOfByte)
  {
    return decipher(paramArrayOfByte, 0);
  }
  
  private byte[] decipher(byte[] paramArrayOfByte, int paramInt)
  {
    long l2;
    long l3;
    long l4;
    long l5;
    long l6;
    long l7;
    long l1;
    try
    {
      l2 = getUnsignedInt(paramArrayOfByte, paramInt, 4);
      l3 = getUnsignedInt(paramArrayOfByte, paramInt + 4, 4);
      l4 = getUnsignedInt(this.key, 0, 4);
      l5 = getUnsignedInt(this.key, 4, 4);
      l6 = getUnsignedInt(this.key, 8, 4);
      l7 = getUnsignedInt(this.key, 12, 4);
      l1 = 0xFFFFFFFFE3779B90 & 0xFFFFFFFF;
      paramInt = 16;
    }
    catch (IOException paramArrayOfByte)
    {
      DataOutputStream localDataOutputStream;
      return null;
    }
    paramArrayOfByte = new ByteArrayOutputStream(8);
    localDataOutputStream = new DataOutputStream(paramArrayOfByte);
    localDataOutputStream.writeInt((int)l2);
    localDataOutputStream.writeInt((int)l3);
    localDataOutputStream.close();
    paramArrayOfByte = paramArrayOfByte.toByteArray();
    return paramArrayOfByte;
    while (paramInt > 0)
    {
      l3 = l3 - ((l2 << 4) + l6 ^ l2 + l1 ^ (l2 >>> 5) + l7) & 0xFFFFFFFF;
      l2 = l2 - ((l3 << 4) + l4 ^ l3 + l1 ^ (l3 >>> 5) + l5) & 0xFFFFFFFF;
      l1 = l1 - (0xFFFFFFFF9E3779B9 & 0xFFFFFFFF) & 0xFFFFFFFF;
      paramInt -= 1;
    }
  }
  
  private byte[] decode(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    this.preCrypt = 0;
    this.crypt = 0;
    byte[] arrayOfByte = new byte[paramInt1 + 8];
    if ((paramInt2 % 8 != 0) || (paramInt2 < 16)) {}
    int k;
    do
    {
      do
      {
        return null;
        this.prePlain = decipher(paramArrayOfByte, paramInt1);
      } while (this.prePlain == null);
      this.pos = (this.prePlain[0] & 0x7);
      k = paramInt2 - this.pos - 10;
    } while (k < 0);
    int i = paramInt1;
    while (i < arrayOfByte.length)
    {
      arrayOfByte[i] = 0;
      i += 1;
    }
    this.out = new byte[k];
    this.preCrypt = 0;
    this.crypt = 8;
    this.contextStart = 8;
    this.pos += 1;
    this.padding = 1;
    while (this.padding <= 2)
    {
      if (this.pos < 8)
      {
        this.pos += 1;
        this.padding += 1;
      }
      if (this.pos == 8)
      {
        arrayOfByte = paramArrayOfByte;
        if (!decrypt8Bytes(paramArrayOfByte, paramInt1, paramInt2)) {
          return null;
        }
      }
    }
    int j = 0;
    i = k;
    while (i != 0)
    {
      int m = i;
      k = j;
      if (this.pos < 8)
      {
        this.out[j] = ((byte)(arrayOfByte[(this.preCrypt + paramInt1 + this.pos)] ^ this.prePlain[this.pos]));
        k = j + 1;
        m = i - 1;
        this.pos += 1;
      }
      i = m;
      j = k;
      if (this.pos == 8)
      {
        arrayOfByte = paramArrayOfByte;
        this.preCrypt = (this.crypt - 8);
        i = m;
        j = k;
        if (!decrypt8Bytes(paramArrayOfByte, paramInt1, paramInt2)) {
          return null;
        }
      }
    }
    for (this.padding = 1;; this.padding += 1)
    {
      if (this.padding >= 8) {
        break label443;
      }
      if (this.pos < 8)
      {
        if ((arrayOfByte[(this.preCrypt + paramInt1 + this.pos)] ^ this.prePlain[this.pos]) != 0) {
          break;
        }
        this.pos += 1;
      }
      if (this.pos == 8)
      {
        arrayOfByte = paramArrayOfByte;
        this.preCrypt = this.crypt;
        if (!decrypt8Bytes(paramArrayOfByte, paramInt1, paramInt2)) {
          break;
        }
      }
    }
    label443:
    return this.out;
  }
  
  private boolean decrypt8Bytes(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    for (this.pos = 0; this.pos < 8; this.pos += 1)
    {
      if (this.contextStart + this.pos >= paramInt2) {
        return true;
      }
      byte[] arrayOfByte = this.prePlain;
      int i = this.pos;
      arrayOfByte[i] = ((byte)(arrayOfByte[i] ^ paramArrayOfByte[(this.crypt + paramInt1 + this.pos)]));
    }
    this.prePlain = decipher(this.prePlain);
    if (this.prePlain == null) {
      return false;
    }
    this.contextStart += 8;
    this.crypt += 8;
    this.pos = 0;
    return true;
  }
  
  private byte[] encipher(byte[] paramArrayOfByte)
  {
    long l2;
    long l3;
    long l4;
    long l5;
    long l6;
    long l7;
    long l1;
    int i;
    try
    {
      l2 = getUnsignedInt(paramArrayOfByte, 0, 4);
      l3 = getUnsignedInt(paramArrayOfByte, 4, 4);
      l4 = getUnsignedInt(this.key, 0, 4);
      l5 = getUnsignedInt(this.key, 4, 4);
      l6 = getUnsignedInt(this.key, 8, 4);
      l7 = getUnsignedInt(this.key, 12, 4);
      l1 = 0L;
      i = 16;
    }
    catch (IOException paramArrayOfByte)
    {
      DataOutputStream localDataOutputStream;
      return null;
    }
    paramArrayOfByte = new ByteArrayOutputStream(8);
    localDataOutputStream = new DataOutputStream(paramArrayOfByte);
    localDataOutputStream.writeInt((int)l2);
    localDataOutputStream.writeInt((int)l3);
    localDataOutputStream.close();
    paramArrayOfByte = paramArrayOfByte.toByteArray();
    return paramArrayOfByte;
    while (i > 0)
    {
      l1 = l1 + (0xFFFFFFFF9E3779B9 & 0xFFFFFFFF) & 0xFFFFFFFF;
      l2 = l2 + ((l3 << 4) + l4 ^ l3 + l1 ^ (l3 >>> 5) + l5) & 0xFFFFFFFF;
      l3 = l3 + ((l2 << 4) + l6 ^ l2 + l1 ^ (l2 >>> 5) + l7) & 0xFFFFFFFF;
      i -= 1;
    }
  }
  
  private byte[] encode(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    this.plain = new byte[8];
    this.prePlain = new byte[8];
    this.pos = 1;
    this.padding = 0;
    this.preCrypt = 0;
    this.crypt = 0;
    this.header = true;
    this.pos = ((paramInt2 + 10) % 8);
    if (this.pos != 0) {
      this.pos = (8 - this.pos);
    }
    this.out = new byte[this.pos + paramInt2 + 10];
    this.plain[0] = ((byte)(rand() & 0xF8 | this.pos));
    int i = 1;
    while (i <= this.pos)
    {
      this.plain[i] = ((byte)(rand() & 0xFF));
      i += 1;
    }
    this.pos += 1;
    i = 0;
    while (i < 8)
    {
      this.prePlain[i] = 0;
      i += 1;
    }
    this.padding = 1;
    byte[] arrayOfByte;
    while (this.padding <= 2)
    {
      if (this.pos < 8)
      {
        arrayOfByte = this.plain;
        i = this.pos;
        this.pos = (i + 1);
        arrayOfByte[i] = ((byte)(rand() & 0xFF));
        this.padding += 1;
      }
      if (this.pos == 8) {
        encrypt8Bytes();
      }
    }
    if (paramInt2 > 0)
    {
      if (this.pos >= 8) {
        break label408;
      }
      arrayOfByte = this.plain;
      int j = this.pos;
      this.pos = (j + 1);
      i = paramInt1 + 1;
      arrayOfByte[j] = paramArrayOfByte[paramInt1];
      paramInt2 -= 1;
      paramInt1 = i;
    }
    label408:
    for (;;)
    {
      if (this.pos == 8)
      {
        encrypt8Bytes();
        break;
        this.padding = 1;
        while (this.padding <= 7)
        {
          if (this.pos < 8)
          {
            paramArrayOfByte = this.plain;
            paramInt1 = this.pos;
            this.pos = (paramInt1 + 1);
            paramArrayOfByte[paramInt1] = 0;
            this.padding += 1;
          }
          if (this.pos == 8) {
            encrypt8Bytes();
          }
        }
        return this.out;
      }
      break;
    }
  }
  
  private void encrypt8Bytes()
  {
    this.pos = 0;
    byte[] arrayOfByte;
    int i;
    if (this.pos < 8)
    {
      if (this.header)
      {
        arrayOfByte = this.plain;
        i = this.pos;
        arrayOfByte[i] = ((byte)(arrayOfByte[i] ^ this.prePlain[this.pos]));
      }
      for (;;)
      {
        this.pos += 1;
        break;
        arrayOfByte = this.plain;
        i = this.pos;
        arrayOfByte[i] = ((byte)(arrayOfByte[i] ^ this.out[(this.preCrypt + this.pos)]));
      }
    }
    System.arraycopy(encipher(this.plain), 0, this.out, this.crypt, 8);
    for (this.pos = 0; this.pos < 8; this.pos += 1)
    {
      arrayOfByte = this.out;
      i = this.crypt + this.pos;
      arrayOfByte[i] = ((byte)(arrayOfByte[i] ^ this.prePlain[this.pos]));
    }
    System.arraycopy(this.plain, 0, this.prePlain, 0, 8);
    this.preCrypt = this.crypt;
    this.crypt += 8;
    this.pos = 0;
    this.header = false;
  }
  
  public static long getUnsignedInt(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    long l = 0L;
    if (paramInt2 > 8) {
      paramInt2 = paramInt1 + 8;
    }
    while (paramInt1 < paramInt2)
    {
      l = l << 8 | paramArrayOfByte[paramInt1] & 0xFF;
      paramInt1 += 1;
      continue;
      paramInt2 = paramInt1 + paramInt2;
    }
    return 0xFFFFFFFF & l | l >>> 32;
  }
  
  private int rand()
  {
    return random.nextInt();
  }
  
  public byte[] decode(byte[] paramArrayOfByte)
  {
    return decode(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  public byte[] decodeFromBase64Str(String paramString)
  {
    return decode(Base64.decode(paramString, 0));
  }
  
  public byte[] decodeFromHexStr(String paramString)
  {
    return decode(HexUtil.hexStr2Bytes(paramString));
  }
  
  public byte[] encode(byte[] paramArrayOfByte)
  {
    return encode(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  public String encode2HexBase64(byte[] paramArrayOfByte)
  {
    return Base64.encodeToString(encode(paramArrayOfByte), 0);
  }
  
  public String encode2HexStr(byte[] paramArrayOfByte)
  {
    return HexUtil.bytes2HexStr(encode(paramArrayOfByte));
  }
}
