package com.google.android.vending.expansion.downloader.impl;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDoneException;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.database.sqlite.SQLiteStatement;
import android.provider.BaseColumns;
import android.util.Log;

public class DownloadsDB
{
  private static final int CONTROL_IDX = 7;
  private static final int CURRENTBYTES_IDX = 4;
  private static final String DATABASE_NAME = "DownloadsDB";
  private static final int DATABASE_VERSION = 7;
  private static final String[] DC_PROJECTION = { "FN", "URI", "ETAG", "TOTALBYTES", "CURRENTBYTES", "LASTMOD", "STATUS", "CONTROL", "FAILCOUNT", "RETRYAFTER", "REDIRECTCOUNT", "FILEIDX" };
  private static final int ETAG_IDX = 2;
  private static final int FILENAME_IDX = 0;
  private static final int INDEX_IDX = 11;
  private static final int LASTMOD_IDX = 5;
  public static final String LOG_TAG = DownloadsDB.class.getName();
  private static final int NUM_FAILED_IDX = 8;
  private static final int REDIRECT_COUNT_IDX = 10;
  private static final int RETRY_AFTER_IDX = 9;
  private static final int STATUS_IDX = 6;
  private static final int TOTALBYTES_IDX = 3;
  private static final int URI_IDX = 1;
  private static DownloadsDB mDownloadsDB;
  int mFlags;
  SQLiteStatement mGetDownloadByIndex;
  final SQLiteOpenHelper mHelper;
  long mMetadataRowID = -1L;
  int mStatus = -1;
  SQLiteStatement mUpdateCurrentBytes;
  int mVersionCode = -1;
  
  private DownloadsDB(Context paramContext)
  {
    this.mHelper = new DownloadsContentDBHelper(paramContext);
    paramContext = this.mHelper.getReadableDatabase().rawQuery("SELECT APKVERSION,_id,DOWNLOADSTATUS,DOWNLOADFLAGS FROM MetadataColumns LIMIT 1", null);
    if ((paramContext != null) && (paramContext.moveToFirst()))
    {
      this.mVersionCode = paramContext.getInt(0);
      this.mMetadataRowID = paramContext.getLong(1);
      this.mStatus = paramContext.getInt(2);
      this.mFlags = paramContext.getInt(3);
      paramContext.close();
    }
    mDownloadsDB = this;
  }
  
  /* Error */
  public static DownloadsDB getDB(Context paramContext)
  {
    // Byte code:
    //   0: ldc 2
    //   2: monitorenter
    //   3: getstatic 148	com/google/android/vending/expansion/downloader/impl/DownloadsDB:mDownloadsDB	Lcom/google/android/vending/expansion/downloader/impl/DownloadsDB;
    //   6: ifnonnull +17 -> 23
    //   9: new 2	com/google/android/vending/expansion/downloader/impl/DownloadsDB
    //   12: dup
    //   13: aload_0
    //   14: invokespecial 151	com/google/android/vending/expansion/downloader/impl/DownloadsDB:<init>	(Landroid/content/Context;)V
    //   17: astore_0
    //   18: ldc 2
    //   20: monitorexit
    //   21: aload_0
    //   22: areturn
    //   23: getstatic 148	com/google/android/vending/expansion/downloader/impl/DownloadsDB:mDownloadsDB	Lcom/google/android/vending/expansion/downloader/impl/DownloadsDB;
    //   26: astore_0
    //   27: goto -9 -> 18
    //   30: astore_0
    //   31: ldc 2
    //   33: monitorexit
    //   34: aload_0
    //   35: athrow
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	36	0	paramContext	Context
    // Exception table:
    //   from	to	target	type
    //   3	18	30	finally
    //   23	27	30	finally
  }
  
  private SQLiteStatement getDownloadByIndexStatement()
  {
    if (this.mGetDownloadByIndex == null) {
      this.mGetDownloadByIndex = this.mHelper.getReadableDatabase().compileStatement("SELECT _id FROM DownloadColumns WHERE FILEIDX = ?");
    }
    return this.mGetDownloadByIndex;
  }
  
  private SQLiteStatement getUpdateCurrentBytesStatement()
  {
    if (this.mUpdateCurrentBytes == null) {
      this.mUpdateCurrentBytes = this.mHelper.getReadableDatabase().compileStatement("UPDATE DownloadColumns SET CURRENTBYTES = ? WHERE FILEIDX = ?");
    }
    return this.mUpdateCurrentBytes;
  }
  
  public void close()
  {
    this.mHelper.close();
  }
  
  protected DownloadInfo getDownloadInfoByFileName(String paramString)
  {
    Object localObject = this.mHelper.getReadableDatabase();
    String str = null;
    try
    {
      paramString = ((SQLiteDatabase)localObject).query("DownloadColumns", DC_PROJECTION, "FN = ?", new String[] { paramString }, null, null, null);
      if (paramString != null)
      {
        str = paramString;
        if (paramString.moveToFirst())
        {
          str = paramString;
          localObject = getDownloadInfoFromCursor(paramString);
          return localObject;
        }
      }
      return null;
    }
    finally
    {
      if (str != null) {
        str.close();
      }
    }
  }
  
  public DownloadInfo getDownloadInfoFromCursor(Cursor paramCursor)
  {
    DownloadInfo localDownloadInfo = new DownloadInfo(paramCursor.getInt(11), paramCursor.getString(0), getClass().getPackage().getName());
    setDownloadInfoFromCursor(localDownloadInfo, paramCursor);
    return localDownloadInfo;
  }
  
  public DownloadInfo[] getDownloads()
  {
    DownloadInfo[] arrayOfDownloadInfo = null;
    Object localObject3 = this.mHelper.getReadableDatabase();
    Object localObject1 = null;
    for (;;)
    {
      int i;
      try
      {
        localObject3 = ((SQLiteDatabase)localObject3).query("DownloadColumns", DC_PROJECTION, null, null, null, null, null);
        if (localObject3 != null)
        {
          localObject1 = localObject3;
          if (((Cursor)localObject3).moveToFirst())
          {
            localObject1 = localObject3;
            arrayOfDownloadInfo = new DownloadInfo[((Cursor)localObject3).getCount()];
            i = 0;
            localObject1 = localObject3;
            arrayOfDownloadInfo[i] = getDownloadInfoFromCursor((Cursor)localObject3);
            localObject1 = localObject3;
            boolean bool = ((Cursor)localObject3).moveToNext();
            if (bool) {
              break label146;
            }
            localObject1 = arrayOfDownloadInfo;
            if (localObject3 != null)
            {
              ((Cursor)localObject3).close();
              localObject1 = arrayOfDownloadInfo;
            }
            return localObject1;
          }
        }
        localObject1 = arrayOfDownloadInfo;
        return null;
      }
      finally
      {
        if (localObject1 != null) {
          ((Cursor)localObject1).close();
        }
      }
      label146:
      i += 1;
    }
  }
  
  public int getFlags()
  {
    return this.mFlags;
  }
  
  public long getIDByIndex(int paramInt)
  {
    SQLiteStatement localSQLiteStatement = getDownloadByIndexStatement();
    localSQLiteStatement.clearBindings();
    localSQLiteStatement.bindLong(1, paramInt);
    try
    {
      long l = localSQLiteStatement.simpleQueryForLong();
      return l;
    }
    catch (SQLiteDoneException localSQLiteDoneException) {}
    return -1L;
  }
  
  public long getIDForDownloadInfo(DownloadInfo paramDownloadInfo)
  {
    return getIDByIndex(paramDownloadInfo.mIndex);
  }
  
  public int getLastCheckedVersionCode()
  {
    return this.mVersionCode;
  }
  
  public boolean isDownloadRequired()
  {
    boolean bool2 = true;
    boolean bool1 = true;
    Cursor localCursor = this.mHelper.getReadableDatabase().rawQuery("SELECT Count(*) FROM DownloadColumns WHERE STATUS <> 0", null);
    if (localCursor != null) {}
    try
    {
      if (localCursor.moveToFirst())
      {
        int i = localCursor.getInt(0);
        if (i == 0) {}
        for (;;)
        {
          bool2 = bool1;
          if (localCursor != null)
          {
            localCursor.close();
            bool2 = bool1;
          }
          return bool2;
          bool1 = false;
        }
      }
      return true;
    }
    finally
    {
      if (localCursor != null) {
        localCursor.close();
      }
    }
  }
  
  public void setDownloadInfoFromCursor(DownloadInfo paramDownloadInfo, Cursor paramCursor)
  {
    paramDownloadInfo.mUri = paramCursor.getString(1);
    paramDownloadInfo.mETag = paramCursor.getString(2);
    paramDownloadInfo.mTotalBytes = paramCursor.getLong(3);
    paramDownloadInfo.mCurrentBytes = paramCursor.getLong(4);
    paramDownloadInfo.mLastMod = paramCursor.getLong(5);
    paramDownloadInfo.mStatus = paramCursor.getInt(6);
    paramDownloadInfo.mControl = paramCursor.getInt(7);
    paramDownloadInfo.mNumFailed = paramCursor.getInt(8);
    paramDownloadInfo.mRetryAfter = paramCursor.getInt(9);
    paramDownloadInfo.mRedirectCount = paramCursor.getInt(10);
  }
  
  public boolean updateDownload(DownloadInfo paramDownloadInfo)
  {
    ContentValues localContentValues = new ContentValues();
    localContentValues.put("FILEIDX", Integer.valueOf(paramDownloadInfo.mIndex));
    localContentValues.put("FN", paramDownloadInfo.mFileName);
    localContentValues.put("URI", paramDownloadInfo.mUri);
    localContentValues.put("ETAG", paramDownloadInfo.mETag);
    localContentValues.put("TOTALBYTES", Long.valueOf(paramDownloadInfo.mTotalBytes));
    localContentValues.put("CURRENTBYTES", Long.valueOf(paramDownloadInfo.mCurrentBytes));
    localContentValues.put("LASTMOD", Long.valueOf(paramDownloadInfo.mLastMod));
    localContentValues.put("STATUS", Integer.valueOf(paramDownloadInfo.mStatus));
    localContentValues.put("CONTROL", Integer.valueOf(paramDownloadInfo.mControl));
    localContentValues.put("FAILCOUNT", Integer.valueOf(paramDownloadInfo.mNumFailed));
    localContentValues.put("RETRYAFTER", Integer.valueOf(paramDownloadInfo.mRetryAfter));
    localContentValues.put("REDIRECTCOUNT", Integer.valueOf(paramDownloadInfo.mRedirectCount));
    return updateDownload(paramDownloadInfo, localContentValues);
  }
  
  public boolean updateDownload(DownloadInfo paramDownloadInfo, ContentValues paramContentValues)
  {
    long l;
    if (paramDownloadInfo == null) {
      l = -1L;
    }
    try
    {
      for (;;)
      {
        paramDownloadInfo = this.mHelper.getWritableDatabase();
        if (l == -1L) {
          break;
        }
        int i = paramDownloadInfo.update("DownloadColumns", paramContentValues, "DownloadColumns._id = " + l, null);
        if (1 != i) {}
        return false;
        l = getIDForDownloadInfo(paramDownloadInfo);
      }
      l = paramDownloadInfo.insert("DownloadColumns", "URI", paramContentValues);
      if (-1L != l) {}
      for (boolean bool = true;; bool = false) {
        return bool;
      }
      return false;
    }
    catch (SQLiteException paramDownloadInfo)
    {
      paramDownloadInfo.printStackTrace();
    }
  }
  
  public void updateDownloadCurrentBytes(DownloadInfo paramDownloadInfo)
  {
    SQLiteStatement localSQLiteStatement = getUpdateCurrentBytesStatement();
    localSQLiteStatement.clearBindings();
    localSQLiteStatement.bindLong(1, paramDownloadInfo.mCurrentBytes);
    localSQLiteStatement.bindLong(2, paramDownloadInfo.mIndex);
    localSQLiteStatement.execute();
  }
  
  public boolean updateFlags(int paramInt)
  {
    if (this.mFlags != paramInt)
    {
      ContentValues localContentValues = new ContentValues();
      localContentValues.put("DOWNLOADFLAGS", Integer.valueOf(paramInt));
      if (updateMetadata(localContentValues)) {
        this.mFlags = paramInt;
      }
    }
    else
    {
      return true;
    }
    return false;
  }
  
  public boolean updateFromDb(DownloadInfo paramDownloadInfo)
  {
    Object localObject2 = this.mHelper.getReadableDatabase();
    Object localObject1 = null;
    try
    {
      localObject2 = ((SQLiteDatabase)localObject2).query("DownloadColumns", DC_PROJECTION, "FN= ?", new String[] { paramDownloadInfo.mFileName }, null, null, null);
      if (localObject2 != null)
      {
        localObject1 = localObject2;
        if (((Cursor)localObject2).moveToFirst())
        {
          localObject1 = localObject2;
          setDownloadInfoFromCursor(paramDownloadInfo, (Cursor)localObject2);
          if (localObject2 != null) {
            ((Cursor)localObject2).close();
          }
          return true;
        }
      }
      if (localObject2 != null) {
        ((Cursor)localObject2).close();
      }
      return false;
    }
    finally
    {
      if (localObject1 != null) {
        localObject1.close();
      }
    }
  }
  
  public boolean updateMetadata(int paramInt1, int paramInt2)
  {
    ContentValues localContentValues = new ContentValues();
    localContentValues.put("APKVERSION", Integer.valueOf(paramInt1));
    localContentValues.put("DOWNLOADSTATUS", Integer.valueOf(paramInt2));
    if (updateMetadata(localContentValues))
    {
      this.mVersionCode = paramInt1;
      this.mStatus = paramInt2;
      return true;
    }
    return false;
  }
  
  public boolean updateMetadata(ContentValues paramContentValues)
  {
    SQLiteDatabase localSQLiteDatabase = this.mHelper.getWritableDatabase();
    if (-1L == this.mMetadataRowID)
    {
      l = localSQLiteDatabase.insert("MetadataColumns", "APKVERSION", paramContentValues);
      if (-1L == l) {
        return false;
      }
      this.mMetadataRowID = l;
    }
    while (localSQLiteDatabase.update("MetadataColumns", paramContentValues, "_id = " + this.mMetadataRowID, null) != 0)
    {
      long l;
      return true;
    }
    return false;
  }
  
  public boolean updateStatus(int paramInt)
  {
    if (this.mStatus != paramInt)
    {
      ContentValues localContentValues = new ContentValues();
      localContentValues.put("DOWNLOADSTATUS", Integer.valueOf(paramInt));
      if (updateMetadata(localContentValues)) {
        this.mStatus = paramInt;
      }
    }
    else
    {
      return true;
    }
    return false;
  }
  
  public static class DownloadColumns
    implements BaseColumns
  {
    public static final String CONTROL = "CONTROL";
    public static final String CURRENTBYTES = "CURRENTBYTES";
    public static final String ETAG = "ETAG";
    public static final String FILENAME = "FN";
    public static final String INDEX = "FILEIDX";
    public static final String LASTMOD = "LASTMOD";
    public static final String NUM_FAILED = "FAILCOUNT";
    public static final String REDIRECT_COUNT = "REDIRECTCOUNT";
    public static final String RETRY_AFTER = "RETRYAFTER";
    public static final String[][] SCHEMA;
    public static final String STATUS = "STATUS";
    public static final String TABLE_NAME = "DownloadColumns";
    public static final String TOTALBYTES = "TOTALBYTES";
    public static final String URI = "URI";
    public static final String _ID = "DownloadColumns._id";
    
    static
    {
      String[] arrayOfString1 = { "_id", "INTEGER PRIMARY KEY" };
      String[] arrayOfString2 = { "FILEIDX", "INTEGER UNIQUE" };
      String[] arrayOfString3 = { "FN", "TEXT UNIQUE" };
      String[] arrayOfString4 = { "ETAG", "TEXT" };
      String[] arrayOfString5 = { "CURRENTBYTES", "INTEGER" };
      String[] arrayOfString6 = { "LASTMOD", "INTEGER" };
      String[] arrayOfString7 = { "FAILCOUNT", "INTEGER" };
      SCHEMA = new String[][] { arrayOfString1, arrayOfString2, { "URI", "TEXT" }, arrayOfString3, arrayOfString4, { "TOTALBYTES", "INTEGER" }, arrayOfString5, arrayOfString6, { "STATUS", "INTEGER" }, { "CONTROL", "INTEGER" }, arrayOfString7, { "RETRYAFTER", "INTEGER" }, { "REDIRECTCOUNT", "INTEGER" } };
    }
    
    public DownloadColumns() {}
  }
  
  protected static class DownloadsContentDBHelper
    extends SQLiteOpenHelper
  {
    private static final String[][][] sSchemas = { DownloadsDB.DownloadColumns.SCHEMA, DownloadsDB.MetadataColumns.SCHEMA };
    private static final String[] sTables = { "DownloadColumns", "MetadataColumns" };
    
    DownloadsContentDBHelper(Context paramContext)
    {
      super("DownloadsDB", null, 7);
    }
    
    private String createTableQueryFromArray(String paramString, String[][] paramArrayOfString)
    {
      StringBuilder localStringBuilder = new StringBuilder();
      localStringBuilder.append("CREATE TABLE ");
      localStringBuilder.append(paramString);
      localStringBuilder.append(" (");
      int j = paramArrayOfString.length;
      int i = 0;
      for (;;)
      {
        if (i >= j)
        {
          localStringBuilder.setLength(localStringBuilder.length() - 1);
          localStringBuilder.append(");");
          return localStringBuilder.toString();
        }
        paramString = paramArrayOfString[i];
        localStringBuilder.append(' ');
        localStringBuilder.append(paramString[0]);
        localStringBuilder.append(' ');
        localStringBuilder.append(paramString[1]);
        localStringBuilder.append(',');
        i += 1;
      }
    }
    
    private void dropTables(SQLiteDatabase paramSQLiteDatabase)
    {
      String[] arrayOfString = sTables;
      int j = arrayOfString.length;
      int i = 0;
      for (;;)
      {
        if (i < j)
        {
          String str = arrayOfString[i];
          try
          {
            paramSQLiteDatabase.execSQL("DROP TABLE IF EXISTS " + str);
            i += 1;
          }
          catch (Exception localException)
          {
            for (;;)
            {
              localException.printStackTrace();
            }
          }
        }
      }
    }
    
    public void onCreate(SQLiteDatabase paramSQLiteDatabase)
    {
      int j = sSchemas.length;
      int i = 0;
      for (;;)
      {
        if (i < j) {
          try
          {
            String[][] arrayOfString = (String[][])sSchemas[i];
            paramSQLiteDatabase.execSQL(createTableQueryFromArray(sTables[i], arrayOfString));
            i += 1;
          }
          catch (Exception paramSQLiteDatabase)
          {
            for (;;)
            {
              paramSQLiteDatabase.printStackTrace();
            }
          }
        }
      }
    }
    
    public void onUpgrade(SQLiteDatabase paramSQLiteDatabase, int paramInt1, int paramInt2)
    {
      Log.w(DownloadsContentDBHelper.class.getName(), "Upgrading database from version " + paramInt1 + " to " + paramInt2 + ", which will destroy all old data");
      dropTables(paramSQLiteDatabase);
      onCreate(paramSQLiteDatabase);
    }
  }
  
  public static class MetadataColumns
    implements BaseColumns
  {
    public static final String APKVERSION = "APKVERSION";
    public static final String DOWNLOAD_STATUS = "DOWNLOADSTATUS";
    public static final String FLAGS = "DOWNLOADFLAGS";
    public static final String[][] SCHEMA = { { "_id", "INTEGER PRIMARY KEY" }, { "APKVERSION", "INTEGER" }, { "DOWNLOADSTATUS", "INTEGER" }, { "DOWNLOADFLAGS", "INTEGER" } };
    public static final String TABLE_NAME = "MetadataColumns";
    public static final String _ID = "MetadataColumns._id";
    
    public MetadataColumns() {}
  }
}
