package com.hdc.ultilities;

public class Base64
{
  private static final char[] S_BASE64CHAR = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 };
  private static final char S_BASE64PAD = '=';
  private static final byte[] S_DECODETABLE = new byte['Â€'];
  
  static
  {
    int j = S_DECODETABLE.length;
    int i = 0;
    if (i >= j)
    {
      j = S_BASE64CHAR.length;
      i = 0;
    }
    for (;;)
    {
      if (i >= j)
      {
        return;
        S_DECODETABLE[i] = Byte.MAX_VALUE;
        i += 1;
        break;
      }
      S_DECODETABLE[S_BASE64CHAR[i]] = ((byte)i);
      i += 1;
    }
  }
  
  public Base64() {}
  
  public static byte[] decode(String paramString)
    throws Exception
  {
    char[] arrayOfChar = new char[4];
    byte[] arrayOfByte = new byte[paramString.length() / 4 * 3 + 3];
    int m = 0;
    int i2 = paramString.length();
    int k = 0;
    int j = 0;
    if (k >= i2)
    {
      if (m == arrayOfByte.length) {
        return arrayOfByte;
      }
    }
    else
    {
      int i = paramString.charAt(k);
      if ((i != 61) && ((i >= S_DECODETABLE.length) || (S_DECODETABLE[i] == Byte.MAX_VALUE))) {
        break label148;
      }
      int i1 = j + 1;
      arrayOfChar[j] = i;
      j = i1;
      n = m;
      if (i1 == arrayOfChar.length) {
        j = 0;
      }
    }
    label148:
    for (int n = m + decode0(arrayOfChar, arrayOfByte, m);; n = m)
    {
      k += 1;
      m = n;
      break;
      paramString = new byte[m];
      System.arraycopy(arrayOfByte, 0, paramString, 0, m);
      return paramString;
    }
  }
  
  public static byte[] decode(char[] paramArrayOfChar, int paramInt1, int paramInt2)
    throws Exception
  {
    char[] arrayOfChar = new char[4];
    byte[] arrayOfByte = new byte[paramInt2 / 4 * 3 + 3];
    int m = 0;
    int k = paramInt1;
    int j = 0;
    if (k >= paramInt1 + paramInt2)
    {
      if (m == arrayOfByte.length) {
        return arrayOfByte;
      }
    }
    else
    {
      int i = paramArrayOfChar[k];
      if ((i != 61) && ((i >= S_DECODETABLE.length) || (S_DECODETABLE[i] == Byte.MAX_VALUE))) {
        break label148;
      }
      int i1 = j + 1;
      arrayOfChar[j] = i;
      j = i1;
      n = m;
      if (i1 == arrayOfChar.length) {
        j = 0;
      }
    }
    label148:
    for (int n = m + decode0(arrayOfChar, arrayOfByte, m);; n = m)
    {
      k += 1;
      m = n;
      break;
      paramArrayOfChar = new byte[m];
      System.arraycopy(arrayOfByte, 0, paramArrayOfChar, 0, m);
      return paramArrayOfChar;
    }
  }
  
  private static int decode0(char[] paramArrayOfChar, byte[] paramArrayOfByte, int paramInt)
    throws Exception
  {
    int i = 3;
    if (paramArrayOfChar[3] == '=') {
      i = 2;
    }
    if (paramArrayOfChar[2] == '=') {
      i = 1;
    }
    int j = S_DECODETABLE[paramArrayOfChar[0]];
    int k = S_DECODETABLE[paramArrayOfChar[1]];
    int m = S_DECODETABLE[paramArrayOfChar[2]];
    int n = S_DECODETABLE[paramArrayOfChar[3]];
    switch (i)
    {
    default: 
      throw new Exception("internalError00");
    case 1: 
      paramArrayOfByte[paramInt] = ((byte)(j << 2 & 0xFC | k >> 4 & 0x3));
      return 1;
    case 2: 
      paramArrayOfByte[paramInt] = ((byte)(j << 2 & 0xFC | k >> 4 & 0x3));
      paramArrayOfByte[(paramInt + 1)] = ((byte)(k << 4 & 0xF0 | m >> 2 & 0xF));
      return 2;
    }
    i = paramInt + 1;
    paramArrayOfByte[paramInt] = ((byte)(j << 2 & 0xFC | k >> 4 & 0x3));
    paramArrayOfByte[i] = ((byte)(k << 4 & 0xF0 | m >> 2 & 0xF));
    paramArrayOfByte[(i + 1)] = ((byte)(m << 6 & 0xC0 | n & 0x3F));
    return 3;
  }
  
  public static String encode(byte[] paramArrayOfByte)
  {
    return encode(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  public static String encode(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    if (paramInt2 <= 0) {
      return "";
    }
    char[] arrayOfChar = new char[paramInt2 / 3 * 4 + 4];
    int j = paramInt1;
    int i = paramInt2 - paramInt1;
    paramInt1 = 0;
    if (i < 3)
    {
      if (i != 1) {
        break label237;
      }
      paramInt2 = paramArrayOfByte[j] & 0xFF;
      i = paramInt1 + 1;
      arrayOfChar[paramInt1] = S_BASE64CHAR[(paramInt2 >> 2)];
      paramInt1 = i + 1;
      arrayOfChar[i] = S_BASE64CHAR[(paramInt2 << 4 & 0x3F)];
      paramInt2 = paramInt1 + 1;
      arrayOfChar[paramInt1] = '=';
      arrayOfChar[paramInt2] = '=';
    }
    for (paramInt1 = paramInt2 + 1;; paramInt1 = paramInt2)
    {
      return new String(arrayOfChar, 0, paramInt1);
      paramInt2 = ((paramArrayOfByte[j] & 0xFF) << 16) + ((paramArrayOfByte[(j + 1)] & 0xFF) << 8) + (paramArrayOfByte[(j + 2)] & 0xFF);
      int k = paramInt1 + 1;
      arrayOfChar[paramInt1] = S_BASE64CHAR[(paramInt2 >> 18)];
      paramInt1 = k + 1;
      arrayOfChar[k] = S_BASE64CHAR[(paramInt2 >> 12 & 0x3F)];
      k = paramInt1 + 1;
      arrayOfChar[paramInt1] = S_BASE64CHAR[(paramInt2 >> 6 & 0x3F)];
      paramInt1 = k + 1;
      arrayOfChar[k] = S_BASE64CHAR[(paramInt2 & 0x3F)];
      j += 3;
      i -= 3;
      break;
      label237:
      paramInt2 = paramInt1;
      if (i == 2)
      {
        paramInt2 = ((paramArrayOfByte[j] & 0xFF) << 8) + (paramArrayOfByte[(j + 1)] & 0xFF);
        i = paramInt1 + 1;
        arrayOfChar[paramInt1] = S_BASE64CHAR[(paramInt2 >> 10)];
        paramInt1 = i + 1;
        arrayOfChar[i] = S_BASE64CHAR[(paramInt2 >> 4 & 0x3F)];
        i = paramInt1 + 1;
        arrayOfChar[paramInt1] = S_BASE64CHAR[(paramInt2 << 2 & 0x3F)];
        paramInt2 = i + 1;
        arrayOfChar[i] = '=';
      }
    }
  }
}
