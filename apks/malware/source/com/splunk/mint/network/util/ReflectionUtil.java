package com.splunk.mint.network.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public final class ReflectionUtil
{
  public static final boolean includeObject = false;
  
  public ReflectionUtil() {}
  
  public static boolean callingClassAnyOf(String[] paramArrayOfString)
  {
    StackTraceElement[] arrayOfStackTraceElement = new Throwable().getStackTrace();
    int j = arrayOfStackTraceElement.length;
    int i = 0;
    while (i < j)
    {
      if (contains(arrayOfStackTraceElement[i].getClassName(), paramArrayOfString)) {
        return true;
      }
      i += 1;
    }
    return false;
  }
  
  public static final boolean contains(String paramString, String[] paramArrayOfString)
  {
    int j = paramArrayOfString.length;
    int i = 0;
    while (i < j)
    {
      if (paramString.contains(paramArrayOfString[i])) {
        return true;
      }
      i += 1;
    }
    return false;
  }
  
  public static String extractCallingMethod(String[] paramArrayOfString)
  {
    StackTraceElement[] arrayOfStackTraceElement = new Throwable().getStackTrace();
    int j = arrayOfStackTraceElement.length;
    int i = 0;
    while (i < j)
    {
      StackTraceElement localStackTraceElement = arrayOfStackTraceElement[i];
      if (!inExcluded(localStackTraceElement.getClassName(), paramArrayOfString)) {
        return localStackTraceElement.getClassName() + "." + localStackTraceElement.getMethodName() + ":" + localStackTraceElement.getLineNumber();
      }
      i += 1;
    }
    return null;
  }
  
  public static Constructor<?> findConstructor(String paramString, Class<?>[] paramArrayOfClass)
    throws ClassNotFoundException
  {
    paramString = Class.forName(paramString).getDeclaredConstructors();
    int m = paramString.length;
    int i = 0;
    while (i < m)
    {
      Constructor<?> localConstructor = paramString[i];
      Class[] arrayOfClass = localConstructor.getParameterTypes();
      if (arrayOfClass.length == paramArrayOfClass.length)
      {
        int k = 1;
        int j = 0;
        while (j < arrayOfClass.length)
        {
          if (!arrayOfClass[j].equals(paramArrayOfClass[j])) {
            k = 0;
          }
          j += 1;
        }
        if (k != 0) {
          return localConstructor;
        }
      }
      i += 1;
    }
    return null;
  }
  
  public static Set<Method> getAllMethods(Class<?> paramClass)
  {
    HashSet localHashSet = new HashSet();
    paramClass = getAllSuperTypes(paramClass).iterator();
    while (paramClass.hasNext())
    {
      Method[] arrayOfMethod = ((Class)paramClass.next()).getDeclaredMethods();
      int j = arrayOfMethod.length;
      int i = 0;
      while (i < j)
      {
        localHashSet.add(arrayOfMethod[i]);
        i += 1;
      }
    }
    return localHashSet;
  }
  
  public static Set<Class<?>> getAllSuperTypes(Class<?> paramClass)
  {
    HashSet localHashSet = new HashSet();
    if ((paramClass != null) && (!paramClass.equals(Object.class)))
    {
      localHashSet.add(paramClass);
      localHashSet.addAll(getAllSuperTypes(paramClass.getSuperclass()));
      paramClass = paramClass.getInterfaces();
      int j = paramClass.length;
      int i = 0;
      while (i < j)
      {
        localHashSet.addAll(getAllSuperTypes(paramClass[i]));
        i += 1;
      }
    }
    return localHashSet;
  }
  
  private static final boolean inExcluded(String paramString, String[] paramArrayOfString)
  {
    int j = paramArrayOfString.length;
    int i = 0;
    while (i < j)
    {
      if (paramString.startsWith(paramArrayOfString[i])) {
        return true;
      }
      i += 1;
    }
    return false;
  }
}
