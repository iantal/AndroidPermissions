package com.splunk.mint.network.io;

import com.splunk.mint.network.Counter;
import com.splunk.mint.network.MonitorRegistry;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public final class OutputStreamMonitor
  extends OutputStream
{
  private static final int MAX_POSSIBLE_HEADER_LENGTH = 50;
  public static final String OUT_POSTFIX = "-bytes-out";
  private StringBuffer body;
  private List<Byte> chars;
  private final Counter counter;
  private final OutputStream original;
  
  public OutputStreamMonitor(String paramString, MonitorRegistry paramMonitorRegistry, OutputStream paramOutputStream)
  {
    this.original = paramOutputStream;
    this.counter = new Counter(paramString + "-bytes-out");
    paramMonitorRegistry.add(this.counter);
    this.chars = new ArrayList();
    this.body = new StringBuffer();
  }
  
  private void updateBody()
  {
    byte[] arrayOfByte = new byte[this.chars.size()];
    int i = 0;
    while (i < arrayOfByte.length)
    {
      arrayOfByte[i] = ((Byte)this.chars.get(i)).byteValue();
      i += 1;
    }
    this.chars.clear();
    this.body.append(new String(arrayOfByte));
  }
  
  public void close()
    throws IOException
  {
    this.original.close();
  }
  
  public HashMap<String, List<String>> getHeaders()
  {
    HashMap localHashMap = new HashMap(1);
    if ((this.body != null) && (this.body.toString() != null) && (this.body.toString().length() > 50)) {}
    try
    {
      BufferedReader localBufferedReader = new BufferedReader(new StringReader(this.body.toString()));
      int k = 0;
      int i = 0;
      int m;
      do
      {
        int j;
        do
        {
          String str1 = localBufferedReader.readLine();
          if (str1 == null) {
            break;
          }
          j = k;
          if (k == 0)
          {
            j = k;
            if (str1.contains(":"))
            {
              j = k;
              if (str1.length() < 50)
              {
                m = str1.indexOf(":");
                j = k;
                if (m > -1)
                {
                  String str2 = str1.substring(0, m).trim();
                  j = k;
                  if (str2.equals("Host"))
                  {
                    localHashMap.put(str2, Arrays.asList(new String[] { str1.substring(m + 1, str1.length()).trim() }));
                    j = 1;
                  }
                }
              }
            }
          }
          m = i;
          if (i == 0) {
            if (!str1.contains("POST"))
            {
              m = i;
              if (!str1.contains("GET")) {}
            }
            else
            {
              localHashMap.put("splk-host2", Arrays.asList(new String[] { str1.split(" ")[1].trim() }));
              m = 1;
            }
          }
          k = j;
          i = m;
        } while (j == 0);
        k = j;
        i = m;
      } while (m == 0);
      return localHashMap;
    }
    catch (IOException localIOException)
    {
      localIOException.printStackTrace();
    }
    return localHashMap;
  }
  
  public void write(int paramInt)
    throws IOException
  {
    this.counter.inc();
    this.original.write(paramInt);
    this.chars.add(Byte.valueOf((byte)paramInt));
    updateBody();
  }
  
  public void write(byte[] paramArrayOfByte)
    throws IOException
  {
    this.counter.inc(paramArrayOfByte.length);
    this.original.write(paramArrayOfByte);
    int i = 0;
    while (i < paramArrayOfByte.length)
    {
      this.chars.add(Byte.valueOf(paramArrayOfByte[i]));
      i += 1;
    }
    updateBody();
  }
  
  public void write(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
    throws IOException
  {
    this.counter.inc(paramInt2);
    this.original.write(paramArrayOfByte, paramInt1, paramInt2);
    while (paramInt1 < paramInt2)
    {
      this.chars.add(Byte.valueOf(paramArrayOfByte[paramInt1]));
      paramInt1 += 1;
    }
    updateBody();
  }
}
