package com.litesuits.http.concurrent;

import android.util.Log;
import com.litesuits.http.log.HttpLog;
import com.litesuits.http.utils.HttpUtil;
import java.util.LinkedList;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.DiscardPolicy;
import java.util.concurrent.TimeUnit;

public class SmartExecutor
  implements Executor
{
  private static final String TAG = SmartExecutor.class.getSimpleName();
  private static ThreadPoolExecutor threadPool;
  private int coreSize = HttpUtil.getCoresNumbers();
  private final Object lock = new Object();
  private OverloadPolicy overloadPolicy = OverloadPolicy.DiscardOldTaskInQueue;
  private int queueSize = this.coreSize * 32;
  private LinkedList<SmartExecutor.WrappedRunnable> runningList = new LinkedList();
  private SchedulePolicy schedulePolicy = SchedulePolicy.FirstInFistRun;
  private LinkedList<SmartExecutor.WrappedRunnable> waitingList = new LinkedList();
  
  public SmartExecutor()
  {
    initThreadPool();
  }
  
  public SmartExecutor(int paramInt1, int paramInt2)
  {
    this.coreSize = paramInt1;
    this.queueSize = paramInt2;
    initThreadPool();
  }
  
  public static ThreadPoolExecutor createDefaultThreadPool()
  {
    return new ThreadPoolExecutor(1, Integer.MAX_VALUE, 3L, TimeUnit.SECONDS, new SynchronousQueue(), new SmartExecutor.1(), new ThreadPoolExecutor.DiscardPolicy());
  }
  
  public static ThreadPoolExecutor getThreadPool()
  {
    return threadPool;
  }
  
  private void scheduleNext(SmartExecutor.WrappedRunnable paramWrappedRunnable)
  {
    for (;;)
    {
      synchronized (this.lock)
      {
        if (!this.runningList.remove(paramWrappedRunnable))
        {
          this.runningList.clear();
          HttpLog.e(TAG, "SmartExecutor scheduler remove failed, so clear all(running list) to avoid unpreditable error : " + paramWrappedRunnable);
        }
        if (this.waitingList.size() > 0) {}
        switch (SmartExecutor.3.$SwitchMap$com$litesuits$http$concurrent$SchedulePolicy[this.schedulePolicy.ordinal()])
        {
        case 1: 
          paramWrappedRunnable = (SmartExecutor.WrappedRunnable)this.waitingList.pollLast();
          if (paramWrappedRunnable != null)
          {
            this.runningList.add(paramWrappedRunnable);
            threadPool.execute(paramWrappedRunnable);
            return;
            paramWrappedRunnable = (SmartExecutor.WrappedRunnable)this.waitingList.pollLast();
          }
          break;
        case 2: 
          paramWrappedRunnable = (SmartExecutor.WrappedRunnable)this.waitingList.pollFirst();
          continue;
          HttpLog.e(TAG, "SmartExecutor get a NULL task from waiting queue: " + Thread.currentThread().getName());
        }
      }
    }
  }
  
  public static void setThreadPool(ThreadPoolExecutor paramThreadPoolExecutor)
  {
    threadPool = paramThreadPoolExecutor;
  }
  
  public boolean cancelWaitingTask(Runnable paramRunnable)
  {
    boolean bool2 = false;
    boolean bool1 = false;
    for (;;)
    {
      int i;
      synchronized (this.lock)
      {
        i = this.waitingList.size();
        if (i > 0)
        {
          i -= 1;
          bool2 = bool1;
          if (i >= 0)
          {
            if (((SmartExecutor.WrappedRunnable)this.waitingList.get(i)).getRealRunnable() != paramRunnable) {
              break label83;
            }
            this.waitingList.remove(i);
            bool1 = true;
            break label83;
          }
        }
        return bool2;
      }
      label83:
      i -= 1;
    }
  }
  
  public void execute(Runnable paramRunnable)
  {
    if (paramRunnable == null) {
      return;
    }
    SmartExecutor.2 local2 = new SmartExecutor.2(this, paramRunnable);
    int j = 0;
    for (;;)
    {
      synchronized (this.lock)
      {
        if (this.runningList.size() < this.coreSize)
        {
          this.runningList.add(local2);
          threadPool.execute(local2);
          i = j;
          if (i == 0) {
            break;
          }
          if (HttpLog.isPrint) {
            HttpLog.w(TAG, "SmartExecutor task running in caller thread");
          }
          paramRunnable.run();
          return;
        }
        if (this.waitingList.size() < this.queueSize)
        {
          this.waitingList.addLast(local2);
          i = j;
        }
      }
      if (HttpLog.isPrint) {
        HttpLog.w(TAG, "SmartExecutor overload , policy is: " + this.overloadPolicy);
      }
      int i = j;
      switch (SmartExecutor.3.$SwitchMap$com$litesuits$http$concurrent$OverloadPolicy[this.overloadPolicy.ordinal()])
      {
      case 4: 
      case 1: 
        this.waitingList.pollLast();
        this.waitingList.addLast(local2);
        i = j;
        break;
      case 2: 
        this.waitingList.pollFirst();
        this.waitingList.addLast(local2);
        i = j;
        break;
      case 5: 
        throw new RuntimeException("Task rejected from lite smart executor. " + paramRunnable.toString());
      default: 
        i = j;
        break;
      case 3: 
        i = 1;
      }
    }
  }
  
  public int getCoreSize()
  {
    return this.coreSize;
  }
  
  public OverloadPolicy getOverloadPolicy()
  {
    return this.overloadPolicy;
  }
  
  public int getQueueSize()
  {
    return this.queueSize;
  }
  
  public int getRunningSize()
  {
    return this.runningList.size();
  }
  
  public SchedulePolicy getSchedulePolicy()
  {
    return this.schedulePolicy;
  }
  
  public int getWaitingSize()
  {
    return this.waitingList.size();
  }
  
  protected void initThreadPool()
  {
    try
    {
      if (HttpLog.isPrint) {
        HttpLog.v(TAG, "SmartExecutor core-queue size: " + this.coreSize + " - " + this.queueSize + "  running-wait task: " + this.runningList.size() + " - " + this.waitingList.size());
      }
      if (threadPool == null) {
        threadPool = createDefaultThreadPool();
      }
      return;
    }
    finally {}
  }
  
  public void printThreadPoolInfo()
  {
    if (HttpLog.isPrint)
    {
      Log.i(TAG, "______________________________________");
      Log.i(TAG, "state (shutdown - terminating - terminated): " + threadPool.isShutdown() + " - " + threadPool.isTerminating() + " - " + threadPool.isTerminated());
      Log.i(TAG, "pool size (core - max): " + threadPool.getCorePoolSize() + " - " + threadPool.getMaximumPoolSize());
      Log.i(TAG, "task (actice - complete - total): " + threadPool.getActiveCount() + " - " + threadPool.getCompletedTaskCount() + " - " + threadPool.getTaskCount());
      Log.i(TAG, "waitingList size : " + threadPool.getQueue().size() + " , " + threadPool.getQueue());
    }
  }
  
  public SmartExecutor setCoreSize(int paramInt)
  {
    if (paramInt <= 0) {
      throw new NullPointerException("coreSize can not <= 0 !");
    }
    this.coreSize = paramInt;
    if (HttpLog.isPrint) {
      HttpLog.v(TAG, "SmartExecutor core-queue size: " + paramInt + " - " + this.queueSize + "  running-wait task: " + this.runningList.size() + " - " + this.waitingList.size());
    }
    return this;
  }
  
  public void setOverloadPolicy(OverloadPolicy paramOverloadPolicy)
  {
    if (paramOverloadPolicy == null) {
      throw new NullPointerException("OverloadPolicy can not be null !");
    }
    this.overloadPolicy = paramOverloadPolicy;
  }
  
  public SmartExecutor setQueueSize(int paramInt)
  {
    if (paramInt < 0) {
      throw new NullPointerException("queueSize can not < 0 !");
    }
    this.queueSize = paramInt;
    if (HttpLog.isPrint) {
      HttpLog.v(TAG, "SmartExecutor core-queue size: " + this.coreSize + " - " + paramInt + "  running-wait task: " + this.runningList.size() + " - " + this.waitingList.size());
    }
    return this;
  }
  
  public void setSchedulePolicy(SchedulePolicy paramSchedulePolicy)
  {
    if (paramSchedulePolicy == null) {
      throw new NullPointerException("SchedulePolicy can not be null !");
    }
    this.schedulePolicy = paramSchedulePolicy;
  }
}
