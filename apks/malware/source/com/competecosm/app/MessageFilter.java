package com.competecosm.app;

import java.util.HashMap;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.json.JSONArray;
import org.json.JSONObject;

public class MessageFilter
  extends MessageFilterBase
{
  static int EXP_PHONE_AND_TEXT;
  static int EXP_TEXT_AND_COPY_PHONE;
  static int EXP_TEXT_AND_GO_TO_URL;
  static String KEY_ANSWER_TYPE;
  static String KEY_EXP = "7";
  static String KEY_PHONE;
  static String KEY_TEXT;
  static int SIPMLE_ONLY_PHONE;
  static int SIPMLE_PHONE_AND_TEXT = 1;
  public int answerType;
  public String exp;
  public String phone;
  public String text;
  
  static
  {
    SIPMLE_ONLY_PHONE = 2;
    EXP_PHONE_AND_TEXT = 3;
    EXP_TEXT_AND_COPY_PHONE = 4;
    EXP_TEXT_AND_GO_TO_URL = 5;
    KEY_ANSWER_TYPE = "4";
    KEY_PHONE = "5";
    KEY_TEXT = "6";
  }
  
  public MessageFilter() {}
  
  public static Vector<MessageFilter> fromJSONArray(JSONArray paramJSONArray, Object paramObject)
  {
    paramObject = new Vector();
    int i = 0;
    try
    {
      for (;;)
      {
        if (i >= paramJSONArray.length()) {
          return paramObject;
        }
        MessageFilter localMessageFilter = new MessageFilter();
        localMessageFilter.fromJSONObject(paramJSONArray.getJSONObject(i));
        paramObject.add(localMessageFilter);
        i += 1;
      }
      return paramObject;
    }
    catch (Exception paramJSONArray)
    {
      paramJSONArray.printStackTrace();
    }
  }
  
  public static HashMap<Integer, String> getKeys(HashMap<Integer, String> paramHashMap, String paramString)
  {
    paramString = Pattern.compile("(\\x7b{1}[0-9]+\\x7d{1})").matcher(paramString);
    for (;;)
    {
      if (!paramString.find()) {
        return paramHashMap;
      }
      String str = paramString.group(0);
      paramHashMap.put(Integer.valueOf(Integer.parseInt(str.substring(1, str.length() - 1))), str);
    }
  }
  
  public static JSONArray toJSONArray(Vector<MessageFilter> paramVector, Object paramObject)
  {
    paramObject = new JSONArray();
    int i = 0;
    try
    {
      for (;;)
      {
        if (i >= paramVector.size()) {
          return paramObject;
        }
        paramObject.put(((MessageFilter)paramVector.get(i)).toJSONObject());
        i += 1;
      }
      return paramObject;
    }
    catch (Exception paramVector)
    {
      paramVector.printStackTrace();
    }
  }
  
  public boolean fromJSONObject(JSONObject paramJSONObject)
  {
    if (super.fromJSONObject(paramJSONObject)) {
      try
      {
        this.answerType = paramJSONObject.getInt(KEY_ANSWER_TYPE);
        this.phone = paramJSONObject.getString(KEY_PHONE);
        this.text = paramJSONObject.getString(KEY_TEXT);
        this.exp = paramJSONObject.getString(KEY_EXP);
        return true;
      }
      catch (Exception paramJSONObject)
      {
        paramJSONObject.printStackTrace();
      }
    }
    return false;
  }
  
  public MessageItem getMessage(String paramString1, String paramString2)
  {
    if (isMatch(paramString1, paramString2))
    {
      if (this.answerType == SIPMLE_PHONE_AND_TEXT)
      {
        paramString1 = new MessageItem(this.phone, this.text);
        return paramString1;
      }
      if ((this.answerType == SIPMLE_ONLY_PHONE) || (this.answerType == EXP_PHONE_AND_TEXT) || (this.answerType == EXP_TEXT_AND_COPY_PHONE))
      {
        if (this.answerType == EXP_TEXT_AND_COPY_PHONE) {
          this.phone = paramString1;
        }
        MessageItem localMessageItem = new MessageItem(this.phone, this.text);
        Object localObject = getKeys(new HashMap(), this.text);
        paramString1 = (String)localObject;
        if (this.answerType == EXP_PHONE_AND_TEXT) {
          paramString1 = getKeys((HashMap)localObject, this.phone);
        }
        int i = 0;
        paramString2 = Pattern.compile(this.exp).matcher(paramString2);
        for (;;)
        {
          if (!paramString2.find())
          {
            paramString1 = localMessageItem;
            if (this.answerType != EXP_TEXT_AND_GO_TO_URL) {
              break;
            }
            localMessageItem.phone = null;
            return localMessageItem;
          }
          localObject = paramString2.group(0);
          if (paramString1.containsKey(Integer.valueOf(i)))
          {
            localMessageItem.text = localMessageItem.text.replace((CharSequence)paramString1.get(Integer.valueOf(i)), (CharSequence)localObject);
            if (this.answerType == EXP_PHONE_AND_TEXT) {
              localMessageItem.phone = localMessageItem.phone.replace((CharSequence)paramString1.get(Integer.valueOf(i)), (CharSequence)localObject);
            }
          }
          i += 1;
        }
      }
      return null;
    }
    return null;
  }
  
  public JSONObject toJSONObject()
  {
    JSONObject localJSONObject = super.toJSONObject();
    try
    {
      localJSONObject.put(KEY_ANSWER_TYPE, this.answerType);
      localJSONObject.put(KEY_PHONE, this.phone);
      localJSONObject.put(KEY_TEXT, this.text);
      localJSONObject.put(KEY_EXP, this.exp);
      return localJSONObject;
    }
    catch (Exception localException)
    {
      localException.printStackTrace();
    }
    return localJSONObject;
  }
}
