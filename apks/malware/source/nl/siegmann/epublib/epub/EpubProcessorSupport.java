package nl.siegmann.epublib.epub;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URL;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xmlpull.v1.XmlPullParserFactory;
import org.xmlpull.v1.XmlSerializer;

public class EpubProcessorSupport
{
  protected static DocumentBuilderFactory documentBuilderFactory;
  public static EntityResolver entityResolver = new EntityResolver()
  {
    private String previousLocation;
    
    public InputSource resolveEntity(String paramAnonymousString1, String paramAnonymousString2)
      throws SAXException, IOException
    {
      if (paramAnonymousString2.startsWith("http:"))
      {
        paramAnonymousString1 = new URL(paramAnonymousString2);
        paramAnonymousString1 = "dtd/" + paramAnonymousString1.getHost() + paramAnonymousString1.getPath();
        this.previousLocation = paramAnonymousString1.substring(0, paramAnonymousString1.lastIndexOf('/'));
      }
      while (getClass().getClassLoader().getResource(paramAnonymousString1) == null)
      {
        throw new RuntimeException("remote resource is not cached : [" + paramAnonymousString2 + "] cannot continue");
        paramAnonymousString1 = this.previousLocation + paramAnonymousString2.substring(paramAnonymousString2.lastIndexOf('/'));
      }
      return new InputSource(EpubProcessorSupport.class.getClassLoader().getResourceAsStream(paramAnonymousString1));
    }
  };
  private static final Logger log = LoggerFactory.getLogger(EpubProcessorSupport.class);
  
  static
  {
    init();
  }
  
  public EpubProcessorSupport() {}
  
  public static DocumentBuilder createDocumentBuilder()
  {
    Object localObject = null;
    try
    {
      DocumentBuilder localDocumentBuilder = documentBuilderFactory.newDocumentBuilder();
      localObject = localDocumentBuilder;
      localDocumentBuilder.setEntityResolver(entityResolver);
      return localDocumentBuilder;
    }
    catch (ParserConfigurationException localParserConfigurationException)
    {
      log.error(localParserConfigurationException.getMessage());
    }
    return localObject;
  }
  
  public static XmlSerializer createXmlSerializer(OutputStream paramOutputStream)
    throws UnsupportedEncodingException
  {
    return createXmlSerializer(new OutputStreamWriter(paramOutputStream, "UTF-8"));
  }
  
  public static XmlSerializer createXmlSerializer(Writer paramWriter)
  {
    XmlSerializer localXmlSerializer2 = null;
    XmlSerializer localXmlSerializer1 = localXmlSerializer2;
    try
    {
      XmlPullParserFactory localXmlPullParserFactory = XmlPullParserFactory.newInstance();
      localXmlSerializer1 = localXmlSerializer2;
      localXmlPullParserFactory.setValidating(true);
      localXmlSerializer1 = localXmlSerializer2;
      localXmlSerializer2 = localXmlPullParserFactory.newSerializer();
      localXmlSerializer1 = localXmlSerializer2;
      localXmlSerializer2.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
      localXmlSerializer1 = localXmlSerializer2;
      localXmlSerializer2.setOutput(paramWriter);
      return localXmlSerializer2;
    }
    catch (Exception paramWriter)
    {
      log.error("When creating XmlSerializer: " + paramWriter.getClass().getName() + ": " + paramWriter.getMessage());
    }
    return localXmlSerializer1;
  }
  
  private static void init()
  {
    documentBuilderFactory = DocumentBuilderFactory.newInstance();
    documentBuilderFactory.setNamespaceAware(true);
    documentBuilderFactory.setValidating(false);
  }
  
  public DocumentBuilderFactory getDocumentBuilderFactory()
  {
    return documentBuilderFactory;
  }
}
