package fi.harism.curl;

import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.PointF;
import android.graphics.RectF;
import android.opengl.GLUtils;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import javax.microedition.khronos.opengles.GL10;

public class CurlMesh
{
  private static final boolean DRAW_CURL_POSITION = false;
  private static final boolean DRAW_POLYGON_OUTLINES = false;
  private static final boolean DRAW_SHADOW = true;
  private static final boolean DRAW_TEXTURE = true;
  private static final float[] SHADOW_INNER_COLOR = { 0.0F, 0.0F, 0.0F, 0.5F };
  private static final float[] SHADOW_OUTER_COLOR = { 0.0F, 0.0F, 0.0F, 0.0F };
  private Array<ShadowVertex> mArrDropShadowVertices;
  private Array<Vertex> mArrIntersections;
  private Array<Vertex> mArrOutputVertices;
  private Array<Vertex> mArrRotatedVertices;
  private Array<Double> mArrScanLines;
  private Array<ShadowVertex> mArrSelfShadowVertices;
  private Array<ShadowVertex> mArrTempShadowVertices;
  private Array<Vertex> mArrTempVertices;
  private FloatBuffer mBufColors;
  private FloatBuffer mBufCurlPositionLines;
  private FloatBuffer mBufShadowColors;
  private FloatBuffer mBufShadowVertices;
  private FloatBuffer mBufTexCoords;
  private FloatBuffer mBufVertices;
  private int mCurlPositionLinesCount;
  private int mDropShadowCount;
  private boolean mFlipTexture = false;
  private int mMaxCurlSplits;
  private final Vertex[] mRectangle = new Vertex[4];
  private int mSelfShadowCount;
  private boolean mTextureBack = false;
  private int[] mTextureIds = null;
  private final CurlPage mTexturePage = new CurlPage();
  private final RectF mTextureRectBack = new RectF();
  private final RectF mTextureRectFront = new RectF();
  private int mVerticesCountBack;
  private int mVerticesCountFront;
  
  public CurlMesh(int paramInt)
  {
    if (paramInt < 1) {}
    for (int i = 1;; i = paramInt)
    {
      this.mMaxCurlSplits = i;
      this.mArrScanLines = new Array(paramInt + 2);
      this.mArrOutputVertices = new Array(7);
      this.mArrRotatedVertices = new Array(4);
      this.mArrIntersections = new Array(2);
      this.mArrTempVertices = new Array(11);
      paramInt = 0;
      while (paramInt < 11)
      {
        this.mArrTempVertices.add(new Vertex());
        paramInt += 1;
      }
    }
    this.mArrSelfShadowVertices = new Array((this.mMaxCurlSplits + 2) * 2);
    this.mArrDropShadowVertices = new Array((this.mMaxCurlSplits + 2) * 2);
    this.mArrTempShadowVertices = new Array((this.mMaxCurlSplits + 2) * 2);
    paramInt = 0;
    while (paramInt < (this.mMaxCurlSplits + 2) * 2)
    {
      this.mArrTempShadowVertices.add(new ShadowVertex(null));
      paramInt += 1;
    }
    paramInt = 0;
    while (paramInt < 4)
    {
      this.mRectangle[paramInt] = new Vertex();
      paramInt += 1;
    }
    Object localObject = this.mRectangle[0];
    Vertex localVertex1 = this.mRectangle[1];
    Vertex localVertex2 = this.mRectangle[1];
    this.mRectangle[3].mPenumbraY = -1.0D;
    localVertex2.mPenumbraY = -1.0D;
    localVertex1.mPenumbraX = -1.0D;
    ((Vertex)localObject).mPenumbraX = -1.0D;
    localObject = this.mRectangle[0];
    localVertex1 = this.mRectangle[2];
    localVertex2 = this.mRectangle[2];
    this.mRectangle[3].mPenumbraX = 1.0D;
    localVertex2.mPenumbraY = 1.0D;
    localVertex1.mPenumbraX = 1.0D;
    ((Vertex)localObject).mPenumbraY = 1.0D;
    paramInt = this.mMaxCurlSplits * 2 + 6;
    localObject = ByteBuffer.allocateDirect(paramInt * 3 * 4);
    ((ByteBuffer)localObject).order(ByteOrder.nativeOrder());
    this.mBufVertices = ((ByteBuffer)localObject).asFloatBuffer();
    this.mBufVertices.position(0);
    localObject = ByteBuffer.allocateDirect(paramInt * 2 * 4);
    ((ByteBuffer)localObject).order(ByteOrder.nativeOrder());
    this.mBufTexCoords = ((ByteBuffer)localObject).asFloatBuffer();
    this.mBufTexCoords.position(0);
    localObject = ByteBuffer.allocateDirect(paramInt * 4 * 4);
    ((ByteBuffer)localObject).order(ByteOrder.nativeOrder());
    this.mBufColors = ((ByteBuffer)localObject).asFloatBuffer();
    this.mBufColors.position(0);
    paramInt = (this.mMaxCurlSplits + 2) * 2 * 2;
    localObject = ByteBuffer.allocateDirect(paramInt * 4 * 4);
    ((ByteBuffer)localObject).order(ByteOrder.nativeOrder());
    this.mBufShadowColors = ((ByteBuffer)localObject).asFloatBuffer();
    this.mBufShadowColors.position(0);
    localObject = ByteBuffer.allocateDirect(paramInt * 3 * 4);
    ((ByteBuffer)localObject).order(ByteOrder.nativeOrder());
    this.mBufShadowVertices = ((ByteBuffer)localObject).asFloatBuffer();
    this.mBufShadowVertices.position(0);
    this.mSelfShadowCount = 0;
    this.mDropShadowCount = 0;
  }
  
  private void addVertex(Vertex paramVertex)
  {
    this.mBufVertices.put((float)paramVertex.mPosX);
    this.mBufVertices.put((float)paramVertex.mPosY);
    this.mBufVertices.put((float)paramVertex.mPosZ);
    this.mBufColors.put(paramVertex.mColorFactor * Color.red(paramVertex.mColor) / 255.0F);
    this.mBufColors.put(paramVertex.mColorFactor * Color.green(paramVertex.mColor) / 255.0F);
    this.mBufColors.put(paramVertex.mColorFactor * Color.blue(paramVertex.mColor) / 255.0F);
    this.mBufColors.put(Color.alpha(paramVertex.mColor) / 255.0F);
    this.mBufTexCoords.put((float)paramVertex.mTexX);
    this.mBufTexCoords.put((float)paramVertex.mTexY);
  }
  
  private Array<Vertex> getIntersections(Array<Vertex> paramArray, int[][] paramArrayOfInt, double paramDouble)
  {
    this.mArrIntersections.clear();
    int i = 0;
    while (i < paramArrayOfInt.length)
    {
      Vertex localVertex1 = (Vertex)paramArray.get(paramArrayOfInt[i][0]);
      Vertex localVertex2 = (Vertex)paramArray.get(paramArrayOfInt[i][1]);
      if ((localVertex1.mPosX > paramDouble) && (localVertex2.mPosX < paramDouble))
      {
        double d = (paramDouble - localVertex2.mPosX) / (localVertex1.mPosX - localVertex2.mPosX);
        Vertex localVertex3 = (Vertex)this.mArrTempVertices.remove(0);
        localVertex3.set(localVertex2);
        localVertex3.mPosX = paramDouble;
        localVertex3.mPosY += (localVertex1.mPosY - localVertex2.mPosY) * d;
        localVertex3.mTexX += (localVertex1.mTexX - localVertex2.mTexX) * d;
        localVertex3.mTexY += (localVertex1.mTexY - localVertex2.mTexY) * d;
        localVertex3.mPenumbraX += (localVertex1.mPenumbraX - localVertex2.mPenumbraX) * d;
        localVertex3.mPenumbraY += (localVertex1.mPenumbraY - localVertex2.mPenumbraY) * d;
        this.mArrIntersections.add(localVertex3);
      }
      i += 1;
    }
    return this.mArrIntersections;
  }
  
  private void setTexCoords(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    try
    {
      this.mRectangle[0].mTexX = paramFloat1;
      this.mRectangle[0].mTexY = paramFloat2;
      this.mRectangle[1].mTexX = paramFloat1;
      this.mRectangle[1].mTexY = paramFloat4;
      this.mRectangle[2].mTexX = paramFloat3;
      this.mRectangle[2].mTexY = paramFloat2;
      this.mRectangle[3].mTexX = paramFloat3;
      this.mRectangle[3].mTexY = paramFloat4;
      return;
    }
    finally
    {
      localObject = finally;
      throw localObject;
    }
  }
  
  public void curl(PointF paramPointF1, PointF paramPointF2, double paramDouble)
  {
    double d1;
    Object localObject1;
    int j;
    Object localObject2;
    Object localObject3;
    Object localObject4;
    double d4;
    for (;;)
    {
      label532:
      try
      {
        this.mBufVertices.position(0);
        this.mBufColors.position(0);
        this.mBufTexCoords.position(0);
        d2 = Math.acos(paramPointF2.x);
        d1 = d2;
        if (paramPointF2.y > 0.0F) {
          d1 = -d2;
        }
        this.mArrTempVertices.addAll(this.mArrRotatedVertices);
        this.mArrRotatedVertices.clear();
        i = 0;
        if (i < 4)
        {
          localObject1 = (Vertex)this.mArrTempVertices.remove(0);
          ((Vertex)localObject1).set(this.mRectangle[i]);
          ((Vertex)localObject1).translate(-paramPointF1.x, -paramPointF1.y);
          ((Vertex)localObject1).rotateZ(-d1);
          j = 0;
          if (j < this.mArrRotatedVertices.size())
          {
            localObject2 = (Vertex)this.mArrRotatedVertices.get(j);
            if (((Vertex)localObject1).mPosX <= ((Vertex)localObject2).mPosX) {}
          }
          else
          {
            this.mArrRotatedVertices.add(j, localObject1);
            i += 1;
            continue;
          }
          if (((Vertex)localObject1).mPosX != ((Vertex)localObject2).mPosX) {
            break label2120;
          }
          if (((Vertex)localObject1).mPosY > ((Vertex)localObject2).mPosY) {
            continue;
          }
          break label2120;
        }
        localObject1 = new int[4][];
        localObject1[0] = { 0, 1 };
        localObject1[1] = { 0, 2 };
        localObject1[2] = { 1, 3 };
        localObject1[3] = { 2, 3 };
        localObject2 = (Vertex)this.mArrRotatedVertices.get(0);
        localObject3 = (Vertex)this.mArrRotatedVertices.get(2);
        localObject4 = (Vertex)this.mArrRotatedVertices.get(3);
        if (Math.sqrt((((Vertex)localObject2).mPosX - ((Vertex)localObject3).mPosX) * (((Vertex)localObject2).mPosX - ((Vertex)localObject3).mPosX) + (((Vertex)localObject2).mPosY - ((Vertex)localObject3).mPosY) * (((Vertex)localObject2).mPosY - ((Vertex)localObject3).mPosY)) > Math.sqrt((((Vertex)localObject2).mPosX - ((Vertex)localObject4).mPosX) * (((Vertex)localObject2).mPosX - ((Vertex)localObject4).mPosX) + (((Vertex)localObject2).mPosY - ((Vertex)localObject4).mPosY) * (((Vertex)localObject2).mPosY - ((Vertex)localObject4).mPosY)))
        {
          localObject1[1][1] = 3;
          localObject1[2][1] = 2;
        }
        this.mVerticesCountBack = 0;
        this.mVerticesCountFront = 0;
        this.mArrTempShadowVertices.addAll(this.mArrDropShadowVertices);
        this.mArrTempShadowVertices.addAll(this.mArrSelfShadowVertices);
        this.mArrDropShadowVertices.clear();
        this.mArrSelfShadowVertices.clear();
        d4 = 3.141592653589793D * paramDouble;
        this.mArrScanLines.clear();
        if (this.mMaxCurlSplits <= 0) {
          break label2129;
        }
        this.mArrScanLines.add(Double.valueOf(0.0D));
      }
      finally {}
      if (i >= this.mMaxCurlSplits) {
        continue;
      }
      this.mArrScanLines.add(Double.valueOf(-d4 * i / (this.mMaxCurlSplits - 1)));
      i += 1;
    }
    this.mArrScanLines.add(Double.valueOf(((Vertex)this.mArrRotatedVertices.get(3)).mPosX - 1.0D));
    double d2 = ((Vertex)this.mArrRotatedVertices.get(0)).mPosX + 1.0D;
    int i = 0;
    for (;;)
    {
      double d3;
      if (i < this.mArrScanLines.size())
      {
        d3 = ((Double)this.mArrScanLines.get(i)).doubleValue();
        j = 0;
      }
      for (;;)
      {
        if (j < this.mArrRotatedVertices.size())
        {
          localObject2 = (Vertex)this.mArrRotatedVertices.get(j);
          if ((((Vertex)localObject2).mPosX >= d3) && (((Vertex)localObject2).mPosX <= d2))
          {
            localObject3 = (Vertex)this.mArrTempVertices.remove(0);
            ((Vertex)localObject3).set((Vertex)localObject2);
            localObject4 = getIntersections(this.mArrRotatedVertices, (int[][])localObject1, ((Vertex)localObject3).mPosX);
            if ((((Array)localObject4).size() == 1) && (((Vertex)((Array)localObject4).get(0)).mPosY > ((Vertex)localObject2).mPosY))
            {
              this.mArrOutputVertices.addAll((Array)localObject4);
              this.mArrOutputVertices.add(localObject3);
            }
            else if (((Array)localObject4).size() <= 1)
            {
              this.mArrOutputVertices.add(localObject3);
              this.mArrOutputVertices.addAll((Array)localObject4);
            }
            else
            {
              this.mArrTempVertices.add(localObject3);
              this.mArrTempVertices.addAll((Array)localObject4);
            }
          }
        }
        else
        {
          localObject2 = getIntersections(this.mArrRotatedVertices, (int[][])localObject1, d3);
          int k;
          if (((Array)localObject2).size() == 2)
          {
            localObject3 = (Vertex)((Array)localObject2).get(0);
            localObject4 = (Vertex)((Array)localObject2).get(1);
            if (((Vertex)localObject3).mPosY < ((Vertex)localObject4).mPosY)
            {
              this.mArrOutputVertices.add(localObject4);
              this.mArrOutputVertices.add(localObject3);
              if (this.mArrOutputVertices.size() <= 0) {
                break label2144;
              }
              localObject2 = (Vertex)this.mArrOutputVertices.remove(0);
              this.mArrTempVertices.add(localObject2);
              if (i != 0) {
                break label1376;
              }
              k = 1;
              this.mVerticesCountFront += 1;
              label973:
              if (k == this.mFlipTexture) {
                break label1570;
              }
              ((Vertex)localObject2).mTexX *= this.mTextureRectFront.right;
              ((Vertex)localObject2).mTexY *= this.mTextureRectFront.bottom;
            }
          }
          for (((Vertex)localObject2).mColor = this.mTexturePage.getColor(1);; ((Vertex)localObject2).mColor = this.mTexturePage.getColor(2))
          {
            ((Vertex)localObject2).rotateZ(d1);
            ((Vertex)localObject2).translate(paramPointF1.x, paramPointF1.y);
            addVertex((Vertex)localObject2);
            if ((((Vertex)localObject2).mPosZ > 0.0D) && (((Vertex)localObject2).mPosZ <= paramDouble))
            {
              localObject3 = (ShadowVertex)this.mArrTempShadowVertices.remove(0);
              ((ShadowVertex)localObject3).mPosX = ((Vertex)localObject2).mPosX;
              ((ShadowVertex)localObject3).mPosY = ((Vertex)localObject2).mPosY;
              ((ShadowVertex)localObject3).mPosZ = ((Vertex)localObject2).mPosZ;
              ((ShadowVertex)localObject3).mPenumbraX = (((Vertex)localObject2).mPosZ / 2.0D * -paramPointF2.x);
              ((ShadowVertex)localObject3).mPenumbraY = (((Vertex)localObject2).mPosZ / 2.0D * -paramPointF2.y);
              ((ShadowVertex)localObject3).mPenumbraColor = (((Vertex)localObject2).mPosZ / paramDouble);
              j = (this.mArrDropShadowVertices.size() + 1) / 2;
              this.mArrDropShadowVertices.add(j, localObject3);
            }
            if (((Vertex)localObject2).mPosZ <= paramDouble) {
              break;
            }
            localObject3 = (ShadowVertex)this.mArrTempShadowVertices.remove(0);
            ((ShadowVertex)localObject3).mPosX = ((Vertex)localObject2).mPosX;
            ((ShadowVertex)localObject3).mPosY = ((Vertex)localObject2).mPosY;
            ((ShadowVertex)localObject3).mPosZ = ((Vertex)localObject2).mPosZ;
            ((ShadowVertex)localObject3).mPenumbraX = ((((Vertex)localObject2).mPosZ - paramDouble) / 3.0D * ((Vertex)localObject2).mPenumbraX);
            ((ShadowVertex)localObject3).mPenumbraY = ((((Vertex)localObject2).mPosZ - paramDouble) / 3.0D * ((Vertex)localObject2).mPenumbraY);
            ((ShadowVertex)localObject3).mPenumbraColor = ((((Vertex)localObject2).mPosZ - paramDouble) / (2.0D * paramDouble));
            j = (this.mArrSelfShadowVertices.size() + 1) / 2;
            this.mArrSelfShadowVertices.add(j, localObject3);
            break;
            this.mArrOutputVertices.addAll((Array)localObject2);
            break;
            if (((Array)localObject2).size() == 0) {
              break;
            }
            this.mArrTempVertices.addAll((Array)localObject2);
            break;
            label1376:
            if ((i == this.mArrScanLines.size() - 1) || (d4 == 0.0D))
            {
              ((Vertex)localObject2).mPosX = (-(((Vertex)localObject2).mPosX + d4));
              ((Vertex)localObject2).mPosZ = (2.0D * paramDouble);
              ((Vertex)localObject2).mPenumbraX = (-((Vertex)localObject2).mPenumbraX);
              k = 0;
              this.mVerticesCountBack += 1;
              break label973;
            }
            d2 = 3.141592653589793D * (((Vertex)localObject2).mPosX / d4);
            ((Vertex)localObject2).mPosX = (Math.sin(d2) * paramDouble);
            ((Vertex)localObject2).mPosZ = (paramDouble - Math.cos(d2) * paramDouble);
            ((Vertex)localObject2).mPenumbraX *= Math.cos(d2);
            ((Vertex)localObject2).mColorFactor = ((float)(0.10000000149011612D + 0.8999999761581421D * Math.sqrt(Math.sin(d2) + 1.0D)));
            if (((Vertex)localObject2).mPosZ >= paramDouble)
            {
              k = 0;
              this.mVerticesCountBack += 1;
              break label973;
            }
            k = 1;
            this.mVerticesCountFront += 1;
            break label973;
            label1570:
            ((Vertex)localObject2).mTexX *= this.mTextureRectBack.right;
            ((Vertex)localObject2).mTexY *= this.mTextureRectBack.bottom;
          }
          this.mBufVertices.position(0);
          this.mBufColors.position(0);
          this.mBufTexCoords.position(0);
          this.mBufShadowColors.position(0);
          this.mBufShadowVertices.position(0);
          this.mDropShadowCount = 0;
          i = 0;
          while (i < this.mArrDropShadowVertices.size())
          {
            paramPointF1 = (ShadowVertex)this.mArrDropShadowVertices.get(i);
            this.mBufShadowVertices.put((float)paramPointF1.mPosX);
            this.mBufShadowVertices.put((float)paramPointF1.mPosY);
            this.mBufShadowVertices.put((float)paramPointF1.mPosZ);
            this.mBufShadowVertices.put((float)(paramPointF1.mPosX + paramPointF1.mPenumbraX));
            this.mBufShadowVertices.put((float)(paramPointF1.mPosY + paramPointF1.mPenumbraY));
            this.mBufShadowVertices.put((float)paramPointF1.mPosZ);
            j = 0;
            while (j < 4)
            {
              paramDouble = SHADOW_OUTER_COLOR[j];
              d1 = SHADOW_INNER_COLOR[j] - SHADOW_OUTER_COLOR[j];
              d2 = paramPointF1.mPenumbraColor;
              this.mBufShadowColors.put((float)(paramDouble + d1 * d2));
              j += 1;
            }
            this.mBufShadowColors.put(SHADOW_OUTER_COLOR);
            this.mDropShadowCount += 2;
            i += 1;
          }
          this.mSelfShadowCount = 0;
          i = 0;
          while (i < this.mArrSelfShadowVertices.size())
          {
            paramPointF1 = (ShadowVertex)this.mArrSelfShadowVertices.get(i);
            this.mBufShadowVertices.put((float)paramPointF1.mPosX);
            this.mBufShadowVertices.put((float)paramPointF1.mPosY);
            this.mBufShadowVertices.put((float)paramPointF1.mPosZ);
            this.mBufShadowVertices.put((float)(paramPointF1.mPosX + paramPointF1.mPenumbraX));
            this.mBufShadowVertices.put((float)(paramPointF1.mPosY + paramPointF1.mPenumbraY));
            this.mBufShadowVertices.put((float)paramPointF1.mPosZ);
            j = 0;
            while (j < 4)
            {
              paramDouble = SHADOW_OUTER_COLOR[j];
              d1 = SHADOW_INNER_COLOR[j] - SHADOW_OUTER_COLOR[j];
              d2 = paramPointF1.mPenumbraColor;
              this.mBufShadowColors.put((float)(paramDouble + d1 * d2));
              j += 1;
            }
            this.mBufShadowColors.put(SHADOW_OUTER_COLOR);
            this.mSelfShadowCount += 2;
            i += 1;
          }
          this.mBufShadowColors.position(0);
          this.mBufShadowVertices.position(0);
          return;
          label2120:
          j += 1;
          break;
          label2129:
          i = 1;
          break label532;
        }
        j += 1;
      }
      label2144:
      d2 = d3;
      i += 1;
    }
  }
  
  public CurlPage getTexturePage()
  {
    try
    {
      CurlPage localCurlPage = this.mTexturePage;
      return localCurlPage;
    }
    finally
    {
      localObject = finally;
      throw localObject;
    }
  }
  
  public void onDrawFrame(GL10 paramGL10)
  {
    for (;;)
    {
      try
      {
        Object localObject;
        int j;
        int i;
        if (this.mTextureIds == null)
        {
          this.mTextureIds = new int[2];
          paramGL10.glGenTextures(2, this.mTextureIds, 0);
          localObject = this.mTextureIds;
          j = localObject.length;
          i = 0;
          if (i < j)
          {
            paramGL10.glBindTexture(3553, localObject[i]);
            paramGL10.glTexParameterf(3553, 10241, 9728.0F);
            paramGL10.glTexParameterf(3553, 10240, 9728.0F);
            paramGL10.glTexParameterf(3553, 10242, 33071.0F);
            paramGL10.glTexParameterf(3553, 10243, 33071.0F);
            i += 1;
            continue;
          }
        }
        if (this.mTexturePage.getTexturesChanged())
        {
          paramGL10.glBindTexture(3553, this.mTextureIds[0]);
          localObject = this.mTexturePage.getTexture(this.mTextureRectFront, 1);
          GLUtils.texImage2D(3553, 0, (Bitmap)localObject, 0);
          ((Bitmap)localObject).recycle();
          this.mTextureBack = this.mTexturePage.hasBackTexture();
          if (this.mTextureBack)
          {
            paramGL10.glBindTexture(3553, this.mTextureIds[1]);
            localObject = this.mTexturePage.getTexture(this.mTextureRectBack, 2);
            GLUtils.texImage2D(3553, 0, (Bitmap)localObject, 0);
            ((Bitmap)localObject).recycle();
            this.mTexturePage.recycle();
            reset();
          }
        }
        else
        {
          paramGL10.glEnableClientState(32884);
          paramGL10.glDisable(3553);
          paramGL10.glEnable(3042);
          paramGL10.glBlendFunc(770, 771);
          paramGL10.glEnableClientState(32886);
          paramGL10.glColorPointer(4, 5126, 0, this.mBufShadowColors);
          paramGL10.glVertexPointer(3, 5126, 0, this.mBufShadowVertices);
          paramGL10.glDrawArrays(5, 0, this.mDropShadowCount);
          paramGL10.glDisableClientState(32886);
          paramGL10.glDisable(3042);
          paramGL10.glEnableClientState(32888);
          paramGL10.glTexCoordPointer(2, 5126, 0, this.mBufTexCoords);
          paramGL10.glVertexPointer(3, 5126, 0, this.mBufVertices);
          paramGL10.glEnableClientState(32886);
          paramGL10.glColorPointer(4, 5126, 0, this.mBufColors);
          paramGL10.glDisable(3553);
          paramGL10.glDrawArrays(5, 0, this.mVerticesCountFront);
          paramGL10.glEnable(3042);
          paramGL10.glEnable(3553);
          if ((this.mFlipTexture) && (this.mTextureBack)) {
            break label793;
          }
          paramGL10.glBindTexture(3553, this.mTextureIds[0]);
          paramGL10.glBlendFunc(770, 771);
          paramGL10.glDrawArrays(5, 0, this.mVerticesCountFront);
          paramGL10.glDisable(3042);
          paramGL10.glDisable(3553);
          i = Math.max(0, this.mVerticesCountFront - 2);
          j = this.mVerticesCountFront + this.mVerticesCountBack - i;
          paramGL10.glDrawArrays(5, i, j);
          paramGL10.glEnable(3042);
          paramGL10.glEnable(3553);
          if ((!this.mFlipTexture) && (this.mTextureBack)) {
            break label811;
          }
          paramGL10.glBindTexture(3553, this.mTextureIds[0]);
          paramGL10.glBlendFunc(770, 771);
          paramGL10.glDrawArrays(5, i, j);
          paramGL10.glDisable(3042);
          paramGL10.glDisable(3553);
          paramGL10.glDisableClientState(32888);
          paramGL10.glDisableClientState(32886);
          paramGL10.glEnable(3042);
          paramGL10.glBlendFunc(770, 771);
          paramGL10.glEnableClientState(32886);
          paramGL10.glColorPointer(4, 5126, 0, this.mBufShadowColors);
          paramGL10.glVertexPointer(3, 5126, 0, this.mBufShadowVertices);
          paramGL10.glDrawArrays(5, this.mDropShadowCount, this.mSelfShadowCount);
          paramGL10.glDisableClientState(32886);
          paramGL10.glDisable(3042);
          paramGL10.glDisableClientState(32884);
          return;
        }
        this.mTextureRectBack.set(this.mTextureRectFront);
        continue;
        paramGL10.glBindTexture(3553, this.mTextureIds[1]);
      }
      finally {}
      label793:
      continue;
      label811:
      paramGL10.glBindTexture(3553, this.mTextureIds[1]);
    }
  }
  
  public void reset()
  {
    try
    {
      this.mBufVertices.position(0);
      this.mBufColors.position(0);
      this.mBufTexCoords.position(0);
      int i = 0;
      if (i < 4)
      {
        Vertex localVertex = (Vertex)this.mArrTempVertices.get(0);
        localVertex.set(this.mRectangle[i]);
        if (this.mFlipTexture)
        {
          localVertex.mTexX *= this.mTextureRectBack.right;
          localVertex.mTexY *= this.mTextureRectBack.bottom;
        }
        for (localVertex.mColor = this.mTexturePage.getColor(2);; localVertex.mColor = this.mTexturePage.getColor(1))
        {
          addVertex(localVertex);
          i += 1;
          break;
          localVertex.mTexX *= this.mTextureRectFront.right;
          localVertex.mTexY *= this.mTextureRectFront.bottom;
        }
      }
      this.mVerticesCountFront = 4;
    }
    finally {}
    this.mVerticesCountBack = 0;
    this.mBufVertices.position(0);
    this.mBufColors.position(0);
    this.mBufTexCoords.position(0);
    this.mSelfShadowCount = 0;
    this.mDropShadowCount = 0;
  }
  
  public void resetTexture()
  {
    try
    {
      this.mTextureIds = null;
      return;
    }
    finally
    {
      localObject = finally;
      throw localObject;
    }
  }
  
  /* Error */
  public void setFlipTexture(boolean paramBoolean)
  {
    // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: iload_1
    //   4: putfield 76	fi/harism/curl/CurlMesh:mFlipTexture	Z
    //   7: iload_1
    //   8: ifeq +14 -> 22
    //   11: aload_0
    //   12: fconst_1
    //   13: fconst_0
    //   14: fconst_0
    //   15: fconst_1
    //   16: invokespecial 420	fi/harism/curl/CurlMesh:setTexCoords	(FFFF)V
    //   19: aload_0
    //   20: monitorexit
    //   21: return
    //   22: aload_0
    //   23: fconst_0
    //   24: fconst_0
    //   25: fconst_1
    //   26: fconst_1
    //   27: invokespecial 420	fi/harism/curl/CurlMesh:setTexCoords	(FFFF)V
    //   30: goto -11 -> 19
    //   33: astore_2
    //   34: aload_0
    //   35: monitorexit
    //   36: aload_2
    //   37: athrow
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	38	0	this	CurlMesh
    //   0	38	1	paramBoolean	boolean
    //   33	4	2	localObject	Object
    // Exception table:
    //   from	to	target	type
    //   2	7	33	finally
    //   11	19	33	finally
    //   22	30	33	finally
  }
  
  public void setRect(RectF paramRectF)
  {
    this.mRectangle[0].mPosX = paramRectF.left;
    this.mRectangle[0].mPosY = paramRectF.top;
    this.mRectangle[1].mPosX = paramRectF.left;
    this.mRectangle[1].mPosY = paramRectF.bottom;
    this.mRectangle[2].mPosX = paramRectF.right;
    this.mRectangle[2].mPosY = paramRectF.top;
    this.mRectangle[3].mPosX = paramRectF.right;
    this.mRectangle[3].mPosY = paramRectF.bottom;
  }
  
  private class Array<T>
  {
    private Object[] mArray;
    private int mCapacity;
    private int mSize;
    
    public Array(int paramInt)
    {
      this.mCapacity = paramInt;
      this.mArray = new Object[paramInt];
    }
    
    public void add(int paramInt, T paramT)
    {
      if ((paramInt < 0) || (paramInt > this.mSize) || (this.mSize >= this.mCapacity)) {
        throw new IndexOutOfBoundsException();
      }
      int i = this.mSize;
      while (i > paramInt)
      {
        this.mArray[i] = this.mArray[(i - 1)];
        i -= 1;
      }
      this.mArray[paramInt] = paramT;
      this.mSize += 1;
    }
    
    public void add(T paramT)
    {
      if (this.mSize >= this.mCapacity) {
        throw new IndexOutOfBoundsException();
      }
      Object[] arrayOfObject = this.mArray;
      int i = this.mSize;
      this.mSize = (i + 1);
      arrayOfObject[i] = paramT;
    }
    
    public void addAll(Array<T> paramArray)
    {
      if (this.mSize + paramArray.size() > this.mCapacity) {
        throw new IndexOutOfBoundsException();
      }
      int i = 0;
      while (i < paramArray.size())
      {
        Object[] arrayOfObject = this.mArray;
        int j = this.mSize;
        this.mSize = (j + 1);
        arrayOfObject[j] = paramArray.get(i);
        i += 1;
      }
    }
    
    public void clear()
    {
      this.mSize = 0;
    }
    
    public T get(int paramInt)
    {
      if ((paramInt < 0) || (paramInt >= this.mSize)) {
        throw new IndexOutOfBoundsException();
      }
      return this.mArray[paramInt];
    }
    
    public T remove(int paramInt)
    {
      if ((paramInt < 0) || (paramInt >= this.mSize)) {
        throw new IndexOutOfBoundsException();
      }
      Object localObject = this.mArray[paramInt];
      while (paramInt < this.mSize - 1)
      {
        this.mArray[paramInt] = this.mArray[(paramInt + 1)];
        paramInt += 1;
      }
      this.mSize -= 1;
      return localObject;
    }
    
    public int size()
    {
      return this.mSize;
    }
  }
  
  private class ShadowVertex
  {
    public double mPenumbraColor;
    public double mPenumbraX;
    public double mPenumbraY;
    public double mPosX;
    public double mPosY;
    public double mPosZ;
    
    private ShadowVertex() {}
  }
  
  private class Vertex
  {
    public int mColor;
    public float mColorFactor = 1.0F;
    public double mPenumbraX;
    public double mPenumbraY;
    public double mPosX = 0.0D;
    public double mPosY = 0.0D;
    public double mPosZ = 0.0D;
    public double mTexX = 0.0D;
    public double mTexY = 0.0D;
    
    public Vertex() {}
    
    public void rotateZ(double paramDouble)
    {
      double d1 = Math.cos(paramDouble);
      paramDouble = Math.sin(paramDouble);
      double d2 = this.mPosX;
      double d3 = this.mPosY;
      double d4 = this.mPosX;
      double d5 = -paramDouble;
      double d6 = this.mPosY;
      this.mPosX = (d2 * d1 + d3 * paramDouble);
      this.mPosY = (d4 * d5 + d6 * d1);
      d2 = this.mPenumbraX;
      d3 = this.mPenumbraY;
      d4 = this.mPenumbraX;
      d5 = -paramDouble;
      d6 = this.mPenumbraY;
      this.mPenumbraX = (d2 * d1 + d3 * paramDouble);
      this.mPenumbraY = (d4 * d5 + d6 * d1);
    }
    
    public void set(Vertex paramVertex)
    {
      this.mPosX = paramVertex.mPosX;
      this.mPosY = paramVertex.mPosY;
      this.mPosZ = paramVertex.mPosZ;
      this.mTexX = paramVertex.mTexX;
      this.mTexY = paramVertex.mTexY;
      this.mPenumbraX = paramVertex.mPenumbraX;
      this.mPenumbraY = paramVertex.mPenumbraY;
      this.mColor = paramVertex.mColor;
      this.mColorFactor = paramVertex.mColorFactor;
    }
    
    public void translate(double paramDouble1, double paramDouble2)
    {
      this.mPosX += paramDouble1;
      this.mPosY += paramDouble2;
    }
  }
}
