package fi.harism.curl;

import android.content.Context;
import android.graphics.PointF;
import android.graphics.RectF;
import android.opengl.GLSurfaceView;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;

public class CurlView
  extends GLSurfaceView
  implements View.OnTouchListener, CurlRenderer.Observer
{
  public static final int CURL_LEFT = 1;
  public static final int CURL_NONE = 0;
  public static final int CURL_RIGHT = 2;
  private static final int SET_CURL_TO_LEFT = 1;
  private static final int SET_CURL_TO_RIGHT = 2;
  public static final int SHOW_ONE_PAGE = 1;
  public static final int SHOW_TWO_PAGES = 2;
  private ActionObserver mActionObserver;
  private boolean mAllowLastPageCurl = true;
  private boolean mAnimate = false;
  private long mAnimationDurationTime = 300L;
  private PointF mAnimationSource = new PointF();
  private long mAnimationStartTime;
  private PointF mAnimationTarget = new PointF();
  private int mAnimationTargetEvent;
  private PointF mCurlDir = new PointF();
  private PointF mCurlPos = new PointF();
  private int mCurlState = 0;
  private int mCurrentIndex = 0;
  private PointF mDragStartPos = new PointF();
  private boolean mEnableTouchPressure = false;
  private int mPageBitmapHeight = -1;
  private int mPageBitmapWidth = -1;
  private CurlMesh mPageCurl;
  private CurlMesh mPageLeft;
  private PageProvider mPageProvider;
  private CurlMesh mPageRight;
  private PointerPosition mPointerPos = new PointerPosition(null);
  private boolean mRenderLeftPage = true;
  private CurlRenderer mRenderer;
  private SizeChangedObserver mSizeChangedObserver;
  private int mViewMode = 1;
  
  public CurlView(Context paramContext)
  {
    super(paramContext);
    init(paramContext);
  }
  
  public CurlView(Context paramContext, AttributeSet paramAttributeSet)
  {
    super(paramContext, paramAttributeSet);
    init(paramContext);
  }
  
  public CurlView(Context paramContext, AttributeSet paramAttributeSet, int paramInt)
  {
    this(paramContext, paramAttributeSet);
  }
  
  private void init(Context paramContext)
  {
    this.mRenderer = new CurlRenderer(this);
    setRenderer(this.mRenderer);
    setRenderMode(0);
    setOnTouchListener(this);
    this.mPageLeft = new CurlMesh(10);
    this.mPageRight = new CurlMesh(10);
    this.mPageCurl = new CurlMesh(10);
    this.mPageLeft.setFlipTexture(true);
    this.mPageRight.setFlipTexture(false);
  }
  
  private void setCurlPos(PointF paramPointF1, PointF paramPointF2, double paramDouble)
  {
    RectF localRectF;
    float f1;
    float f2;
    if ((this.mCurlState == 2) || ((this.mCurlState == 1) && (this.mViewMode == 1)))
    {
      localRectF = this.mRenderer.getPageRect(2);
      if (paramPointF1.x >= localRectF.right)
      {
        this.mPageCurl.reset();
        requestRender();
        return;
      }
      if (paramPointF1.x < localRectF.left) {
        paramPointF1.x = localRectF.left;
      }
      if (paramPointF2.y != 0.0F)
      {
        f1 = paramPointF1.x;
        f2 = localRectF.left;
        f1 = paramPointF1.y + paramPointF2.x * (f1 - f2) / paramPointF2.y;
        if ((paramPointF2.y < 0.0F) && (f1 < localRectF.top))
        {
          paramPointF2.x = (paramPointF1.y - localRectF.top);
          paramPointF2.y = (localRectF.left - paramPointF1.x);
        }
      }
      else
      {
        double d = Math.sqrt(paramPointF2.x * paramPointF2.x + paramPointF2.y * paramPointF2.y);
        if (d == 0.0D) {
          break label508;
        }
        paramPointF2.x = ((float)(paramPointF2.x / d));
        paramPointF2.y = ((float)(paramPointF2.y / d));
        this.mPageCurl.curl(paramPointF1, paramPointF2, paramDouble);
      }
    }
    for (;;)
    {
      requestRender();
      return;
      if ((paramPointF2.y <= 0.0F) || (f1 <= localRectF.bottom)) {
        break;
      }
      paramPointF2.x = (localRectF.bottom - paramPointF1.y);
      paramPointF2.y = (paramPointF1.x - localRectF.left);
      break;
      if (this.mCurlState != 1) {
        break;
      }
      localRectF = this.mRenderer.getPageRect(1);
      if (paramPointF1.x <= localRectF.left)
      {
        this.mPageCurl.reset();
        requestRender();
        return;
      }
      if (paramPointF1.x > localRectF.right) {
        paramPointF1.x = localRectF.right;
      }
      if (paramPointF2.y == 0.0F) {
        break;
      }
      f1 = paramPointF1.x;
      f2 = localRectF.right;
      f1 = paramPointF1.y + paramPointF2.x * (f1 - f2) / paramPointF2.y;
      if ((paramPointF2.y < 0.0F) && (f1 < localRectF.top))
      {
        paramPointF2.x = (localRectF.top - paramPointF1.y);
        paramPointF2.y = (paramPointF1.x - localRectF.right);
        break;
      }
      if ((paramPointF2.y <= 0.0F) || (f1 <= localRectF.bottom)) {
        break;
      }
      paramPointF2.x = (paramPointF1.y - localRectF.bottom);
      paramPointF2.y = (localRectF.right - paramPointF1.x);
      break;
      label508:
      this.mPageCurl.reset();
    }
  }
  
  private void startCurl(int paramInt)
  {
    switch (paramInt)
    {
    default: 
    case 2: 
      do
      {
        return;
        this.mRenderer.removeCurlMesh(this.mPageLeft);
        this.mRenderer.removeCurlMesh(this.mPageRight);
        this.mRenderer.removeCurlMesh(this.mPageCurl);
        localCurlMesh = this.mPageRight;
        this.mPageRight = this.mPageCurl;
        this.mPageCurl = localCurlMesh;
        if (this.mCurrentIndex > 0)
        {
          this.mPageLeft.setFlipTexture(true);
          this.mPageLeft.setRect(this.mRenderer.getPageRect(1));
          this.mPageLeft.reset();
          if (this.mRenderLeftPage) {
            this.mRenderer.addCurlMesh(this.mPageLeft);
          }
        }
        if (this.mCurrentIndex < this.mPageProvider.getPageCount() - 1)
        {
          updatePage(this.mPageRight.getTexturePage(), this.mCurrentIndex + 1);
          this.mPageRight.setRect(this.mRenderer.getPageRect(2));
          this.mPageRight.setFlipTexture(false);
          this.mPageRight.reset();
          this.mRenderer.addCurlMesh(this.mPageRight);
        }
        this.mPageCurl.setRect(this.mRenderer.getPageRect(2));
        this.mPageCurl.setFlipTexture(false);
        this.mPageCurl.reset();
        this.mRenderer.addCurlMesh(this.mPageCurl);
        this.mCurlState = 2;
      } while (this.mActionObserver == null);
      this.mActionObserver.didStartDragging(this.mCurlState);
      return;
    }
    this.mRenderer.removeCurlMesh(this.mPageLeft);
    this.mRenderer.removeCurlMesh(this.mPageRight);
    this.mRenderer.removeCurlMesh(this.mPageCurl);
    CurlMesh localCurlMesh = this.mPageLeft;
    this.mPageLeft = this.mPageCurl;
    this.mPageCurl = localCurlMesh;
    if (this.mCurrentIndex > 1)
    {
      updatePage(this.mPageLeft.getTexturePage(), this.mCurrentIndex - 2);
      this.mPageLeft.setFlipTexture(true);
      this.mPageLeft.setRect(this.mRenderer.getPageRect(1));
      this.mPageLeft.reset();
      if (this.mRenderLeftPage) {
        this.mRenderer.addCurlMesh(this.mPageLeft);
      }
    }
    if (this.mCurrentIndex < this.mPageProvider.getPageCount())
    {
      this.mPageRight.setFlipTexture(false);
      this.mPageRight.setRect(this.mRenderer.getPageRect(2));
      this.mPageRight.reset();
      this.mRenderer.addCurlMesh(this.mPageRight);
    }
    if ((this.mViewMode == 1) || ((this.mCurlState == 1) && (this.mViewMode == 2)))
    {
      this.mPageCurl.setRect(this.mRenderer.getPageRect(2));
      this.mPageCurl.setFlipTexture(false);
    }
    for (;;)
    {
      this.mPageCurl.reset();
      this.mRenderer.addCurlMesh(this.mPageCurl);
      this.mCurlState = 1;
      if (this.mActionObserver == null) {
        break;
      }
      this.mActionObserver.didStartDragging(this.mCurlState);
      return;
      this.mPageCurl.setRect(this.mRenderer.getPageRect(1));
      this.mPageCurl.setFlipTexture(true);
    }
  }
  
  private void updateCurlPos(PointerPosition paramPointerPosition)
  {
    double d2 = this.mRenderer.getPageRect(2).width() / 3.0F * Math.max(1.0F - paramPointerPosition.mPressure, 0.0F);
    this.mCurlPos.set(paramPointerPosition.mPos);
    float f1;
    float f2;
    double d3;
    double d1;
    if ((this.mCurlState == 2) || ((this.mCurlState == 1) && (this.mViewMode == 2)))
    {
      this.mCurlDir.x = (this.mCurlPos.x - this.mDragStartPos.x);
      this.mCurlDir.y = (this.mCurlPos.y - this.mDragStartPos.y);
      f1 = (float)Math.sqrt(this.mCurlDir.x * this.mCurlDir.x + this.mCurlDir.y * this.mCurlDir.y);
      f2 = this.mRenderer.getPageRect(2).width();
      double d4 = d2 * 3.141592653589793D;
      d3 = d4;
      d1 = d2;
      if (f1 > 2.0F * f2 - d4)
      {
        d3 = Math.max(2.0F * f2 - f1, 0.0F);
        d1 = d3 / 3.141592653589793D;
      }
      if (f1 >= d3)
      {
        d2 = (f1 - d3) / 2.0D;
        if (this.mViewMode == 2)
        {
          paramPointerPosition = this.mCurlPos;
          paramPointerPosition.x = ((float)(paramPointerPosition.x - this.mCurlDir.x * d2 / f1));
          paramPointerPosition = this.mCurlPos;
          paramPointerPosition.y = ((float)(paramPointerPosition.y - this.mCurlDir.y * d2 / f1));
        }
      }
    }
    for (;;)
    {
      setCurlPos(this.mCurlPos, this.mCurlDir, d1);
      return;
      f2 = this.mRenderer.getPageRect(2).left;
      d1 = Math.max(Math.min(this.mCurlPos.x - f2, d1), 0.0D);
      break;
      d2 = d1 * Math.sin(3.141592653589793D * Math.sqrt(f1 / d3));
      paramPointerPosition = this.mCurlPos;
      paramPointerPosition.x = ((float)(paramPointerPosition.x + this.mCurlDir.x * d2 / f1));
      paramPointerPosition = this.mCurlPos;
      paramPointerPosition.y = ((float)(paramPointerPosition.y + this.mCurlDir.y * d2 / f1));
      continue;
      d1 = d2;
      if (this.mCurlState == 1)
      {
        f1 = this.mRenderer.getPageRect(2).left;
        d1 = Math.max(Math.min(this.mCurlPos.x - f1, d2), 0.0D);
        f1 = this.mRenderer.getPageRect(2).right;
        paramPointerPosition = this.mCurlPos;
        paramPointerPosition.x = ((float)(paramPointerPosition.x - Math.min(f1 - this.mCurlPos.x, d1)));
        this.mCurlDir.x = (this.mCurlPos.x + this.mDragStartPos.x);
        this.mCurlDir.y = (this.mCurlPos.y - this.mDragStartPos.y);
      }
    }
  }
  
  private void updatePage(CurlPage paramCurlPage, int paramInt)
  {
    paramCurlPage.reset();
    this.mPageProvider.updatePage(paramCurlPage, this.mPageBitmapWidth, this.mPageBitmapHeight, paramInt);
  }
  
  private void updatePages()
  {
    if ((this.mPageProvider == null) || (this.mPageBitmapWidth <= 0) || (this.mPageBitmapHeight <= 0)) {}
    int j;
    int k;
    int i;
    int m;
    int n;
    do
    {
      return;
      this.mRenderer.removeCurlMesh(this.mPageLeft);
      this.mRenderer.removeCurlMesh(this.mPageRight);
      this.mRenderer.removeCurlMesh(this.mPageCurl);
      j = this.mCurrentIndex - 1;
      k = this.mCurrentIndex;
      i = -1;
      if (this.mCurlState != 1) {
        break;
      }
      i = j;
      m = j - 1;
      n = k;
      if ((n >= 0) && (n < this.mPageProvider.getPageCount()))
      {
        updatePage(this.mPageRight.getTexturePage(), n);
        this.mPageRight.setFlipTexture(false);
        this.mPageRight.setRect(this.mRenderer.getPageRect(2));
        this.mPageRight.reset();
        this.mRenderer.addCurlMesh(this.mPageRight);
      }
      if ((m >= 0) && (m < this.mPageProvider.getPageCount()))
      {
        updatePage(this.mPageLeft.getTexturePage(), m);
        this.mPageLeft.setFlipTexture(true);
        this.mPageLeft.setRect(this.mRenderer.getPageRect(1));
        this.mPageLeft.reset();
        if (this.mRenderLeftPage) {
          this.mRenderer.addCurlMesh(this.mPageLeft);
        }
      }
    } while ((i < 0) || (i >= this.mPageProvider.getPageCount()));
    updatePage(this.mPageCurl.getTexturePage(), i);
    if (this.mCurlState == 2)
    {
      this.mPageCurl.setFlipTexture(true);
      this.mPageCurl.setRect(this.mRenderer.getPageRect(2));
    }
    for (;;)
    {
      this.mPageCurl.reset();
      this.mRenderer.addCurlMesh(this.mPageCurl);
      return;
      m = j;
      n = k;
      if (this.mCurlState != 2) {
        break;
      }
      i = k;
      n = k + 1;
      m = j;
      break;
      this.mPageCurl.setFlipTexture(false);
      this.mPageCurl.setRect(this.mRenderer.getPageRect(1));
    }
  }
  
  public ActionObserver getActionObserver()
  {
    return this.mActionObserver;
  }
  
  public int getCurrentIndex()
  {
    return this.mCurrentIndex;
  }
  
  public int getViewMode()
  {
    return this.mViewMode;
  }
  
  public void onDrawFrame()
  {
    if (!this.mAnimate) {
      return;
    }
    long l = System.currentTimeMillis();
    if (l >= this.mAnimationStartTime + this.mAnimationDurationTime)
    {
      CurlMesh localCurlMesh;
      if (this.mAnimationTargetEvent == 2)
      {
        localObject = this.mPageCurl;
        localCurlMesh = this.mPageRight;
        ((CurlMesh)localObject).setRect(this.mRenderer.getPageRect(2));
        ((CurlMesh)localObject).setFlipTexture(false);
        ((CurlMesh)localObject).reset();
        this.mRenderer.removeCurlMesh(localCurlMesh);
        this.mPageCurl = localCurlMesh;
        this.mPageRight = ((CurlMesh)localObject);
        if (this.mCurlState == 1)
        {
          this.mCurrentIndex -= 1;
          if (this.mActionObserver != null) {
            this.mActionObserver.didCurl(this.mCurrentIndex, this.mCurlState);
          }
        }
      }
      for (;;)
      {
        this.mCurlState = 0;
        this.mAnimate = false;
        requestRender();
        return;
        if (this.mActionObserver != null)
        {
          this.mActionObserver.didCurl(this.mCurrentIndex, 0);
          continue;
          if (this.mAnimationTargetEvent == 1)
          {
            localObject = this.mPageCurl;
            localCurlMesh = this.mPageLeft;
            ((CurlMesh)localObject).setRect(this.mRenderer.getPageRect(1));
            ((CurlMesh)localObject).setFlipTexture(true);
            ((CurlMesh)localObject).reset();
            this.mRenderer.removeCurlMesh(localCurlMesh);
            if (!this.mRenderLeftPage) {
              this.mRenderer.removeCurlMesh((CurlMesh)localObject);
            }
            this.mPageCurl = localCurlMesh;
            this.mPageLeft = ((CurlMesh)localObject);
            if (this.mCurlState == 2)
            {
              this.mCurrentIndex += 1;
              if (this.mActionObserver != null) {
                this.mActionObserver.didCurl(this.mCurrentIndex, this.mCurlState);
              }
            }
            else if (this.mActionObserver != null)
            {
              this.mActionObserver.didCurl(this.mCurrentIndex, 0);
            }
          }
          else if (this.mActionObserver != null)
          {
            this.mActionObserver.didCurl(this.mCurrentIndex, this.mCurlState);
          }
        }
      }
    }
    this.mPointerPos.mPos.set(this.mAnimationSource);
    float f = 1.0F - (float)(l - this.mAnimationStartTime) / (float)this.mAnimationDurationTime;
    f = 1.0F - f * f * f * (3.0F - 2.0F * f);
    Object localObject = this.mPointerPos.mPos;
    ((PointF)localObject).x += (this.mAnimationTarget.x - this.mAnimationSource.x) * f;
    localObject = this.mPointerPos.mPos;
    ((PointF)localObject).y += (this.mAnimationTarget.y - this.mAnimationSource.y) * f;
    updateCurlPos(this.mPointerPos);
  }
  
  public void onPageSizeChanged(int paramInt1, int paramInt2)
  {
    this.mPageBitmapWidth = paramInt1;
    this.mPageBitmapHeight = paramInt2;
    updatePages();
    requestRender();
  }
  
  public void onSizeChanged(int paramInt1, int paramInt2, int paramInt3, int paramInt4)
  {
    super.onSizeChanged(paramInt1, paramInt2, paramInt3, paramInt4);
    requestRender();
    if (this.mSizeChangedObserver != null) {
      this.mSizeChangedObserver.onSizeChanged(paramInt1, paramInt2);
    }
  }
  
  public void onSurfaceCreated()
  {
    this.mPageLeft.resetTexture();
    this.mPageRight.resetTexture();
    this.mPageCurl.resetTexture();
  }
  
  public boolean onTouch(View paramView, MotionEvent paramMotionEvent)
  {
    if ((this.mAnimate) || (this.mPageProvider == null)) {
      return false;
    }
    paramView = this.mRenderer.getPageRect(2);
    RectF localRectF = this.mRenderer.getPageRect(1);
    this.mPointerPos.mPos.set(paramMotionEvent.getX(), paramMotionEvent.getY());
    this.mRenderer.translate(this.mPointerPos.mPos);
    if (this.mEnableTouchPressure)
    {
      this.mPointerPos.mPressure = paramMotionEvent.getPressure();
      label85:
      switch (paramMotionEvent.getAction())
      {
      }
    }
    for (;;)
    {
      label120:
      return true;
      this.mPointerPos.mPressure = 0.8F;
      break label85;
      this.mDragStartPos.set(this.mPointerPos.mPos);
      if (this.mDragStartPos.y > paramView.top)
      {
        this.mDragStartPos.y = paramView.top;
        label175:
        if (this.mViewMode != 2) {
          break label344;
        }
        if ((this.mDragStartPos.x >= paramView.left) || (this.mCurrentIndex <= 0)) {
          break label269;
        }
        this.mDragStartPos.x = localRectF.left;
        startCurl(1);
      }
      while (this.mCurlState != 0)
      {
        updateCurlPos(this.mPointerPos);
        break label120;
        if (this.mDragStartPos.y >= paramView.bottom) {
          break label175;
        }
        this.mDragStartPos.y = paramView.bottom;
        break label175;
        label269:
        if ((this.mDragStartPos.x >= paramView.left) && (this.mCurrentIndex < this.mPageProvider.getPageCount()))
        {
          this.mDragStartPos.x = paramView.right;
          if ((!this.mAllowLastPageCurl) && (this.mCurrentIndex >= this.mPageProvider.getPageCount() - 1)) {
            break;
          }
          startCurl(2);
          continue;
          label344:
          if (this.mViewMode == 1)
          {
            float f = (paramView.right + paramView.left) / 2.0F;
            if ((this.mDragStartPos.x < f) && (this.mCurrentIndex > 0))
            {
              this.mDragStartPos.x = paramView.left;
              startCurl(1);
            }
            else if ((this.mDragStartPos.x >= f) && (this.mCurrentIndex < this.mPageProvider.getPageCount()))
            {
              this.mDragStartPos.x = paramView.right;
              if ((!this.mAllowLastPageCurl) && (this.mCurrentIndex >= this.mPageProvider.getPageCount() - 1)) {
                break;
              }
              startCurl(2);
            }
          }
        }
      }
      if ((this.mCurlState == 1) || (this.mCurlState == 2))
      {
        this.mAnimationSource.set(this.mPointerPos.mPos);
        this.mAnimationStartTime = System.currentTimeMillis();
        if (((this.mViewMode == 1) && (this.mPointerPos.mPos.x > (paramView.left + paramView.right) / 2.0F)) || ((this.mViewMode == 2) && (this.mPointerPos.mPos.x > paramView.left)))
        {
          this.mAnimationTarget.set(this.mDragStartPos);
          this.mAnimationTarget.x = this.mRenderer.getPageRect(2).right;
          this.mAnimationTargetEvent = 2;
          this.mAnimate = true;
          requestRender();
          if (this.mActionObserver != null) {
            this.mActionObserver.didStopDragging(false);
          }
        }
        else
        {
          this.mAnimationTarget.set(this.mDragStartPos);
          if ((this.mCurlState == 2) || (this.mViewMode == 2)) {}
          for (this.mAnimationTarget.x = localRectF.left;; this.mAnimationTarget.x = paramView.left)
          {
            this.mAnimationTargetEvent = 1;
            break;
          }
        }
      }
      else if (this.mActionObserver != null)
      {
        this.mActionObserver.didStopDragging(false);
      }
    }
  }
  
  public void setActionObserver(ActionObserver paramActionObserver)
  {
    this.mActionObserver = paramActionObserver;
  }
  
  public void setAllowLastPageCurl(boolean paramBoolean)
  {
    this.mAllowLastPageCurl = paramBoolean;
  }
  
  public void setBackgroundColor(int paramInt)
  {
    this.mRenderer.setBackgroundColor(paramInt);
    requestRender();
  }
  
  public void setCurrentIndex(int paramInt)
  {
    int i;
    if (this.mCurrentIndex > paramInt)
    {
      i = 2;
      if ((this.mPageProvider != null) && (paramInt >= 0)) {
        break label58;
      }
      this.mCurrentIndex = 0;
    }
    for (;;)
    {
      if (this.mActionObserver != null) {
        this.mActionObserver.didCurl(paramInt, i);
      }
      updatePages();
      requestRender();
      return;
      i = 1;
      break;
      label58:
      if (this.mAllowLastPageCurl) {
        this.mCurrentIndex = Math.min(paramInt, this.mPageProvider.getPageCount());
      } else {
        this.mCurrentIndex = Math.min(paramInt, this.mPageProvider.getPageCount() - 1);
      }
    }
  }
  
  public void setEnableTouchPressure(boolean paramBoolean)
  {
    this.mEnableTouchPressure = paramBoolean;
  }
  
  public void setMargins(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    this.mRenderer.setMargins(paramFloat1, paramFloat2, paramFloat3, paramFloat4);
  }
  
  public void setPageProvider(PageProvider paramPageProvider)
  {
    this.mPageProvider = paramPageProvider;
    this.mCurrentIndex = 0;
    updatePages();
    requestRender();
  }
  
  public void setRenderLeftPage(boolean paramBoolean)
  {
    this.mRenderLeftPage = paramBoolean;
  }
  
  public void setSizeChangedObserver(SizeChangedObserver paramSizeChangedObserver)
  {
    this.mSizeChangedObserver = paramSizeChangedObserver;
  }
  
  public void setViewMode(int paramInt)
  {
    int i = this.mViewMode;
    switch (paramInt)
    {
    }
    for (;;)
    {
      if ((i != this.mViewMode) && (this.mSizeChangedObserver != null)) {
        this.mSizeChangedObserver.onViewModeChanged(i, this.mViewMode);
      }
      return;
      this.mViewMode = paramInt;
      this.mPageLeft.setFlipTexture(true);
      this.mRenderer.setViewMode(1);
      continue;
      this.mViewMode = paramInt;
      this.mPageLeft.setFlipTexture(false);
      this.mRenderer.setViewMode(2);
    }
  }
  
  public static abstract interface ActionObserver
  {
    public abstract void didCurl(int paramInt1, int paramInt2);
    
    public abstract void didStartDragging(int paramInt);
    
    public abstract void didStopDragging(boolean paramBoolean);
  }
  
  public static abstract interface PageProvider
  {
    public abstract int getPageCount();
    
    public abstract void updatePage(CurlPage paramCurlPage, int paramInt1, int paramInt2, int paramInt3);
  }
  
  private class PointerPosition
  {
    PointF mPos = new PointF();
    float mPressure;
    
    private PointerPosition() {}
  }
  
  public static abstract interface SizeChangedObserver
  {
    public abstract void onSizeChanged(int paramInt1, int paramInt2);
    
    public abstract void onViewModeChanged(int paramInt1, int paramInt2);
  }
}
