package com.urbanairship.iap;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.os.Environment;
import com.urbanairship.Logger;
import com.urbanairship.UAirship;
import com.urbanairship.restclient.AppAuthenticatedRequest;
import com.urbanairship.restclient.AsyncHandler;
import com.urbanairship.restclient.Request;
import com.urbanairship.restclient.RequestQueue;
import com.urbanairship.restclient.Response;
import com.urbanairship.util.UnzipperTask;
import com.urbanairship.util.UnzipperTask.Delegate;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Observable;
import java.util.Observer;
import java.util.Set;
import org.apache.http.HttpEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.message.BasicHeader;
import org.json.JSONObject;
import org.json.JSONTokener;

public class DownloadManager
{
  static final int MAX_TRIES = 3;
  static final String PENDING_PRODUCTS_FILE = "com.urbanairship.iap.pending_products";
  private InventoryObserver inventoryObserver = new InventoryObserver(null);
  private NotificationController notificationController = new NotificationController();
  private RequestQueue queue = new RequestQueue();
  private HashMap<String, Integer> tries = new HashMap();
  
  DownloadManager()
  {
    IAPManager.shared().getInventory().addObserver(this.inventoryObserver);
  }
  
  private void addPendingProduct(String paramString)
  {
    SharedPreferences.Editor localEditor = getPendingProducts().edit();
    localEditor.putBoolean(paramString, true);
    localEditor.commit();
  }
  
  private void download(final Product paramProduct, final String paramString)
  {
    final String str2 = paramProduct.getIdentifier();
    String str1 = paramProduct.getTitle();
    String str3 = sanitize(str2);
    Request localRequest = new Request("GET", paramString);
    paramProduct.setStatus(Product.Status.DOWNLOADING);
    paramString = this.notificationController.get(str2);
    paramString.setNotificationType(PurchaseNotificationInfo.NotificationType.DOWNLOADING);
    this.notificationController.sendNotification(paramString);
    try
    {
      if (Environment.getExternalStorageState().equals("mounted"))
      {
        paramString = Environment.getExternalStorageDirectory();
        Logger.debug("Writing to SD card");
      }
      for (;;)
      {
        final File localFile = new File(paramString, IAPManager.shared().getTempPath() + str3 + ".zip").getCanonicalFile();
        paramString = new File(paramString, IAPManager.shared().getDownloadPath() + str3).getCanonicalFile();
        localRequest.setDestination(localFile);
        this.queue.addRequest(localRequest, new AsyncHandler()
        {
          public void onComplete(Response paramAnonymousResponse)
          {
            Logger.info("Downloaded product to " + localFile + ", extracting...");
            paramAnonymousResponse = DownloadManager.this.notificationController.get(str2);
            paramAnonymousResponse.setProgress(100);
            IAPEventListener localIAPEventListener = IAPManager.shared().getEventListener();
            if (localIAPEventListener != null) {
              localIAPEventListener.downloadProgress(paramProduct, 100);
            }
            paramAnonymousResponse.setNotificationType(PurchaseNotificationInfo.NotificationType.DECOMPRESSING);
            DownloadManager.this.notificationController.sendNotification(paramAnonymousResponse);
            paramAnonymousResponse = new UnzipperTask();
            paramAnonymousResponse.setDelegate(new DownloadManager.UnzipDelegate(DownloadManager.this, paramProduct, paramString));
            paramAnonymousResponse.execute(new File[] { localFile, paramString });
          }
          
          public void onError(Exception paramAnonymousException)
          {
            Logger.error("Download " + paramProduct + " failed", paramAnonymousException);
            DownloadManager.this.retry(paramProduct);
          }
          
          public void onProgress(int paramAnonymousInt)
          {
            Logger.verbose("Download " + paramProduct + " progress " + paramAnonymousInt);
            Object localObject = DownloadManager.this.notificationController.get(str2);
            ((PurchaseNotificationInfo)localObject).setProgress(paramAnonymousInt);
            DownloadManager.this.notificationController.sendNotification((PurchaseNotificationInfo)localObject);
            localObject = IAPManager.shared().getEventListener();
            if (localObject != null) {
              ((IAPEventListener)localObject).downloadProgress(paramProduct, paramAnonymousInt);
            }
          }
        });
        return;
        paramString = UAirship.shared().getApplicationContext().getFilesDir();
        Logger.info("SD card not available, writing to internal storage");
      }
      return;
    }
    catch (Exception paramString)
    {
      Logger.error("Error downloading product " + str1, paramString);
      retry(paramProduct);
    }
  }
  
  private void removePendingProduct(String paramString)
  {
    SharedPreferences.Editor localEditor = getPendingProducts().edit();
    localEditor.remove(paramString);
    localEditor.commit();
  }
  
  private void resumePendingProducts()
  {
    Logger.verbose("resumePendingProducts");
    Iterator localIterator = getPendingProducts().getAll().entrySet().iterator();
    while (localIterator.hasNext())
    {
      Object localObject = (String)((Map.Entry)localIterator.next()).getKey();
      localObject = IAPManager.shared().getInventory().getProduct((String)localObject);
      String str = ((Product)localObject).getTitle();
      Product.Status localStatus = ((Product)localObject).getStatus();
      if ((localStatus != Product.Status.DOWNLOADING) && (localStatus != Product.Status.WAITING))
      {
        Logger.info("resuming download of " + str);
        verify((Product)localObject);
      }
      else
      {
        Logger.info(str + " is already downloading");
      }
    }
  }
  
  private void retry(Product paramProduct)
  {
    Object localObject = paramProduct.getIdentifier();
    String str = paramProduct.getTitle();
    int i = ((Integer)this.tries.get(localObject)).intValue();
    paramProduct.setStatus(Product.Status.PURCHASED);
    if (((Integer)this.tries.get(localObject)).intValue() < 3)
    {
      this.tries.put(localObject, Integer.valueOf(i + 1));
      Logger.info("Retrying download of " + str);
      verify(paramProduct);
    }
    do
    {
      return;
      Logger.info(String.format("Already tried downloading %s %d times, giving up for now", new Object[] { str, Integer.valueOf(3) }));
      this.notificationController.get((String)localObject).setNotificationType(PurchaseNotificationInfo.NotificationType.DOWNLOAD_FAILED);
      this.notificationController.removePurchaseNotification((String)localObject);
      this.tries.remove(localObject);
      localObject = IAPManager.shared().getEventListener();
    } while (localObject == null);
    ((IAPEventListener)localObject).downloadFailed(paramProduct);
  }
  
  private String sanitize(String paramString)
  {
    for (paramString = paramString.trim(); !paramString.substring(paramString.length() - 1).matches("[a-zA-Z0-9]"); paramString = paramString.substring(0, paramString.length() - 1)) {}
    return paramString;
  }
  
  private void verify(final Product paramProduct)
  {
    String str = paramProduct.getIdentifier();
    Object localObject1 = paramProduct.getTitle();
    paramProduct.setStatus(Product.Status.WAITING);
    if (!this.notificationController.contains(str)) {
      this.notificationController.registerPurchaseNotification(str, (String)localObject1, PurchaseNotificationInfo.NotificationType.VERIFYING_RECEIPT);
    }
    if (!this.tries.containsKey(str)) {
      this.tries.put(str, Integer.valueOf(1));
    }
    AppAuthenticatedRequest localAppAuthenticatedRequest = new AppAuthenticatedRequest("POST", paramProduct.getDownloadURLString() + "?platform=android");
    Object localObject2 = Receipt.fetch(str);
    Object localObject3 = ((Receipt)localObject2).getSignedData();
    localObject2 = ((Receipt)localObject2).getSignature();
    if ((localObject3 != null) && (localObject2 != null))
    {
      Logger.debug("paid product, verifying receipt");
      Logger.debug("receipt: " + (String)localObject3 + " signature: " + (String)localObject2);
    }
    for (;;)
    {
      try
      {
        localObject3 = new StringEntity((String)localObject3);
        ((StringEntity)localObject3).setContentType("application/json");
        localAppAuthenticatedRequest.setEntity((HttpEntity)localObject3);
        localAppAuthenticatedRequest.addHeader(new BasicHeader("x-google-iap-signature", (String)localObject2));
        this.queue.addRequest(localAppAuthenticatedRequest, new AsyncHandler()
        {
          public void onComplete(Response paramAnonymousResponse)
          {
            String str = paramAnonymousResponse.body();
            Logger.verbose("verifyRequest result " + str);
            if (paramAnonymousResponse.status() == 200) {
              try
              {
                paramAnonymousResponse = ((JSONObject)new JSONTokener(str).nextValue()).getString("content_url");
                DownloadManager.this.download(paramProduct, paramAnonymousResponse);
                return;
              }
              catch (Exception paramAnonymousResponse)
              {
                Logger.error("Error parsing verification response from server, for product " + this.val$title);
                DownloadManager.this.retry(paramProduct);
                return;
              }
            }
            Logger.debug("verifyRequest response status: " + paramAnonymousResponse.status());
            DownloadManager.this.retry(paramProduct);
          }
          
          public void onError(Exception paramAnonymousException)
          {
            Logger.error("Error fetching content url from server, for product: " + paramProduct);
            DownloadManager.this.retry(paramProduct);
          }
        });
        localObject1 = this.notificationController.get(str);
        this.notificationController.sendNotification((PurchaseNotificationInfo)localObject1);
        localObject1 = IAPManager.shared().getEventListener();
        if (localObject1 != null) {
          ((IAPEventListener)localObject1).downloadStarted(paramProduct, ((Integer)this.tries.get(str)).intValue());
        }
        return;
      }
      catch (UnsupportedEncodingException localUnsupportedEncodingException)
      {
        Logger.error("Error setting verifyRequest entity");
        continue;
      }
      Logger.debug("free product, sending bare request");
    }
  }
  
  public void downloadIfValid(Product paramProduct)
  {
    String str = paramProduct.getIdentifier();
    if (!hasPendingProduct(str)) {
      addPendingProduct(str);
    }
    verify(paramProduct);
  }
  
  SharedPreferences getPendingProducts()
  {
    return UAirship.shared().getApplicationContext().getSharedPreferences("com.urbanairship.iap.pending_products", 0);
  }
  
  public boolean hasPendingProduct(String paramString)
  {
    return getPendingProducts().contains(paramString);
  }
  
  private class InventoryObserver
    implements Observer
  {
    private InventoryObserver() {}
    
    public void update(Observable paramObservable, Object paramObject)
    {
      if (((Inventory)paramObject).getStatus() == Inventory.Status.LOADED)
      {
        if ((IAPManager.isFirstRun()) && (IAPManager.isBillingSupported())) {
          IAPManager.shared().restoreTransactions();
        }
      }
      else {
        return;
      }
      DownloadManager.this.resumePendingProducts();
    }
  }
  
  private class UnzipDelegate
    extends UnzipperTask.Delegate
  {
    File downloadPath;
    Product product;
    
    public UnzipDelegate(Product paramProduct, File paramFile)
    {
      this.product = paramProduct;
      this.downloadPath = paramFile;
    }
    
    public void onFail(Exception paramException)
    {
      String str = this.product.getIdentifier();
      Logger.error(String.format("Extraction of %s failed", new Object[] { this.product.getTitle() }), paramException);
      paramException = DownloadManager.this.notificationController.get(str);
      paramException.setNotificationType(PurchaseNotificationInfo.NotificationType.DECOMPRESS_FAILED);
      DownloadManager.this.notificationController.sendNotification(paramException);
      DownloadManager.this.retry(this.product);
    }
    
    public void onProgressUpdate(int paramInt) {}
    
    public void onSuccess()
    {
      Object localObject1 = this.product.getIdentifier();
      Object localObject2 = DownloadManager.this.notificationController.get((String)localObject1);
      ((PurchaseNotificationInfo)localObject2).setNotificationType(PurchaseNotificationInfo.NotificationType.INSTALL_SUCCESSFUL);
      this.product.setStatus(Product.Status.INSTALLED);
      this.product.setDownloadPath(this.downloadPath);
      Logger.verbose("Setting download path for " + ((PurchaseNotificationInfo)localObject2).getProductName() + ": " + this.downloadPath);
      localObject2 = Receipt.fetch(this.product.getIdentifier());
      ((Receipt)localObject2).setDownloadPathString(this.downloadPath.toString());
      ((Receipt)localObject2).serialize();
      DownloadManager.this.notificationController.removePurchaseNotification((String)localObject1);
      DownloadManager.this.removePendingProduct((String)localObject1);
      DownloadManager.this.tries.remove(localObject1);
      localObject1 = IAPManager.shared().getEventListener();
      if (localObject1 != null) {
        ((IAPEventListener)localObject1).downloadSuccessful(this.product);
      }
    }
  }
}
