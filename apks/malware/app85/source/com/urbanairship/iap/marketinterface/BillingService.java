package com.urbanairship.iap.marketinterface;

import android.app.Activity;
import android.app.PendingIntent;
import android.app.Service;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.BadParcelableException;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import com.android.vending.billing.IMarketBillingService;
import com.android.vending.billing.IMarketBillingService.Stub;
import com.urbanairship.Logger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class BillingService
  extends Service
  implements ServiceConnection
{
  private static LinkedList<BillingRequest> mPendingRequests = new LinkedList();
  private static HashMap<Long, BillingRequest> mSentRequests = new HashMap();
  private static IMarketBillingService mService;
  
  public BillingService() {}
  
  private boolean bindToMarketBillingService()
  {
    try
    {
      if (bindService(new Intent("com.android.vending.billing.MarketBillingService.BIND"), this, 1)) {
        return true;
      }
      Logger.error("Could not bind to service.");
    }
    catch (SecurityException localSecurityException)
    {
      for (;;)
      {
        Logger.error("Security exception: " + localSecurityException);
      }
    }
    return false;
  }
  
  private void checkResponseCode(long paramLong, Consts.ResponseCode paramResponseCode)
  {
    BillingRequest localBillingRequest = (BillingRequest)mSentRequests.get(Long.valueOf(paramLong));
    if (localBillingRequest != null) {
      localBillingRequest.responseCodeReceived(paramResponseCode);
    }
    mSentRequests.remove(Long.valueOf(paramLong));
  }
  
  private boolean confirmNotifications(int paramInt, String[] paramArrayOfString)
  {
    return new ConfirmNotifications(paramInt, paramArrayOfString).runRequest();
  }
  
  private boolean getPurchaseInformation(int paramInt, String[] paramArrayOfString)
  {
    return new GetPurchaseInformation(paramInt, paramArrayOfString).runRequest();
  }
  
  private ArrayList<Purchase> getPurchases(String paramString1, String paramString2)
  {
    paramString2 = new ArrayList();
    for (;;)
    {
      try
      {
        localJSONArray = new JSONObject(paramString1).optJSONArray("orders");
        if (localJSONArray == null) {
          break label166;
        }
        i = localJSONArray.length();
        j = 0;
      }
      catch (JSONException paramString1)
      {
        try
        {
          JSONArray localJSONArray;
          int j;
          JSONObject localJSONObject = localJSONArray.getJSONObject(j);
          Consts.PurchaseState localPurchaseState = Consts.PurchaseState.valueOf(localJSONObject.getInt("purchaseState"));
          String str1 = localJSONObject.getString("productId");
          long l = localJSONObject.getLong("purchaseTime");
          String str2 = localJSONObject.optString("orderId", "");
          paramString1 = null;
          if (localJSONObject.has("notificationId")) {
            paramString1 = localJSONObject.getString("notificationId");
          }
          paramString2.add(new Purchase(localPurchaseState, paramString1, str1, str2, l, localJSONObject.optString("developerPayload", null)));
          j += 1;
        }
        catch (JSONException paramString1)
        {
          Logger.error("JSON exception: ", paramString1);
          return null;
        }
        paramString1 = paramString1;
        return null;
      }
      if (j < i) {}
      return paramString2;
      label166:
      int i = 0;
    }
  }
  
  private void purchaseStateChanged(int paramInt, String paramString1, String paramString2)
  {
    Object localObject = getPurchases(paramString1, paramString2);
    if (localObject == null) {}
    ArrayList localArrayList;
    do
    {
      return;
      localArrayList = new ArrayList();
      localObject = ((ArrayList)localObject).iterator();
      while (((Iterator)localObject).hasNext())
      {
        Purchase localPurchase = (Purchase)((Iterator)localObject).next();
        if (localPurchase.notificationId != null) {
          localArrayList.add(localPurchase.notificationId);
        }
        ResponseHandler.purchaseResponse(localPurchase.purchaseState, localPurchase.productId, localPurchase.orderId, localPurchase.purchaseTime, paramString1, paramString2);
      }
    } while (localArrayList.isEmpty());
    confirmNotifications(paramInt, (String[])localArrayList.toArray(new String[localArrayList.size()]));
  }
  
  private void runPendingRequests()
  {
    int i = -1;
    for (;;)
    {
      BillingRequest localBillingRequest = (BillingRequest)mPendingRequests.peek();
      if (localBillingRequest == null) {
        break label110;
      }
      Logger.verbose("Billing Service - running request: " + localBillingRequest.getStartId());
      if (!localBillingRequest.runIfConnected()) {
        break;
      }
      Logger.verbose("Billing Service - request ran: " + localBillingRequest.getStartId());
      mPendingRequests.remove();
      if (i < localBillingRequest.getStartId()) {
        i = localBillingRequest.getStartId();
      }
    }
    Logger.debug("Billing Service - bind to market service");
    bindToMarketBillingService();
    label110:
    while (i < 0) {
      return;
    }
    stopSelf(i);
  }
  
  public boolean checkBillingSupported()
  {
    return new CheckBillingSupported().runRequest();
  }
  
  public void handleCommand(Intent paramIntent, int paramInt)
  {
    String str = paramIntent.getAction();
    if ("com.example.dungeons.CONFIRM_NOTIFICATION".equals(str)) {
      confirmNotifications(paramInt, paramIntent.getStringArrayExtra("notification_id"));
    }
    do
    {
      return;
      if ("com.example.dungeons.GET_PURCHASE_INFORMATION".equals(str))
      {
        getPurchaseInformation(paramInt, new String[] { paramIntent.getStringExtra("notification_id") });
        return;
      }
      if ("com.android.vending.billing.PURCHASE_STATE_CHANGED".equals(str))
      {
        str = paramIntent.getStringExtra("inapp_signed_data");
        paramIntent = paramIntent.getStringExtra("inapp_signature");
        if ((str != null) && (paramIntent != null))
        {
          purchaseStateChanged(paramInt, str, paramIntent);
          return;
        }
        Logger.warn("Received purchaseStateChanged intent with null signature/data!");
        Logger.warn("Purchase not verified!");
        return;
      }
    } while (!"com.android.vending.billing.RESPONSE_CODE".equals(str));
    checkResponseCode(paramIntent.getLongExtra("request_id", -1L), Consts.ResponseCode.valueOf(paramIntent.getIntExtra("response_code", Consts.ResponseCode.RESULT_ERROR.ordinal())));
  }
  
  public IBinder onBind(Intent paramIntent)
  {
    return null;
  }
  
  public void onServiceConnected(ComponentName paramComponentName, IBinder paramIBinder)
  {
    mService = IMarketBillingService.Stub.asInterface(paramIBinder);
    runPendingRequests();
  }
  
  public void onServiceDisconnected(ComponentName paramComponentName)
  {
    Logger.warn("Billing service disconnected");
    mService = null;
  }
  
  public void onStart(Intent paramIntent, int paramInt)
  {
    if (paramIntent != null) {
      handleCommand(paramIntent, paramInt);
    }
  }
  
  public boolean requestPurchase(Activity paramActivity, String paramString)
  {
    return new RequestPurchase(paramActivity, paramString).runRequest();
  }
  
  public boolean requestPurchase(Activity paramActivity, String paramString1, String paramString2)
  {
    return new RequestPurchase(paramActivity, paramString1, paramString2).runRequest();
  }
  
  public boolean restoreTransactions()
  {
    return new RestoreTransactions().runRequest();
  }
  
  public void setContext(Context paramContext)
  {
    attachBaseContext(paramContext);
  }
  
  public void unbind()
  {
    try
    {
      unbindService(this);
      return;
    }
    catch (IllegalArgumentException localIllegalArgumentException) {}
  }
  
  abstract class BillingRequest
  {
    protected long mRequestId;
    private final int mStartId;
    
    public BillingRequest(int paramInt)
    {
      this.mStartId = paramInt;
    }
    
    public int getStartId()
    {
      return this.mStartId;
    }
    
    protected void logResponseCode(String paramString, Bundle paramBundle)
    {
      Consts.ResponseCode.valueOf(paramBundle.getInt("RESPONSE_CODE"));
    }
    
    protected Bundle makeRequestBundle(String paramString)
    {
      Bundle localBundle = new Bundle();
      localBundle.putString("BILLING_REQUEST", paramString);
      localBundle.putInt("API_VERSION", 1);
      localBundle.putString("PACKAGE_NAME", BillingService.this.getPackageName());
      return localBundle;
    }
    
    protected void onRemoteException(RemoteException paramRemoteException)
    {
      Logger.warn("remote billing service crashed");
      BillingService.access$202(null);
    }
    
    protected void responseCodeReceived(Consts.ResponseCode paramResponseCode) {}
    
    protected abstract long run()
      throws RemoteException;
    
    public boolean runIfConnected()
    {
      if (BillingService.mService != null) {
        try
        {
          this.mRequestId = run();
          if (this.mRequestId >= 0L) {
            BillingService.mSentRequests.put(Long.valueOf(this.mRequestId), this);
          }
          return true;
        }
        catch (RemoteException localRemoteException)
        {
          onRemoteException(localRemoteException);
        }
      }
      return false;
    }
    
    public boolean runRequest()
    {
      if (runIfConnected()) {
        return true;
      }
      if (BillingService.this.bindToMarketBillingService())
      {
        BillingService.mPendingRequests.add(this);
        return true;
      }
      return false;
    }
    
    public Bundle send(Bundle paramBundle)
      throws BillingService.MarketFailException, RemoteException
    {
      try
      {
        paramBundle = BillingService.mService.sendBillingRequest(paramBundle);
        return paramBundle;
      }
      catch (SecurityException paramBundle)
      {
        Logger.error("SecurityException sending billing request: " + paramBundle.getMessage());
        throw new BillingService.MarketFailException(BillingService.this, "Failure sending billing request");
      }
      catch (BadParcelableException paramBundle)
      {
        for (;;)
        {
          Logger.error("BadParcelableException sending billing request: " + paramBundle.getMessage());
        }
      }
      catch (IllegalArgumentException paramBundle)
      {
        for (;;)
        {
          Logger.error("IllegalArgumentException sending billing request: " + paramBundle.getMessage());
        }
      }
      catch (NullPointerException paramBundle)
      {
        for (;;)
        {
          Logger.error("NullPointerException sending billing request: " + paramBundle.getMessage());
        }
      }
      catch (IllegalStateException paramBundle)
      {
        for (;;)
        {
          Logger.error("IllegalStateException sending billing request: " + paramBundle.getMessage());
        }
      }
      catch (RuntimeException paramBundle)
      {
        for (;;)
        {
          Logger.error("RuntimeException sending billing request: " + paramBundle.getMessage());
        }
      }
      catch (Exception paramBundle)
      {
        for (;;)
        {
          Logger.error("Unknown exception sending billing request: " + paramBundle.getMessage());
        }
      }
    }
  }
  
  class CheckBillingSupported
    extends BillingService.BillingRequest
  {
    public CheckBillingSupported()
    {
      super(-1);
    }
    
    protected long run()
      throws RemoteException
    {
      try
      {
        Bundle localBundle = send(makeRequestBundle("CHECK_BILLING_SUPPORTED"));
        if (localBundle.getInt("RESPONSE_CODE") == Consts.ResponseCode.RESULT_OK.ordinal()) {}
        for (boolean bool = true;; bool = false)
        {
          ResponseHandler.checkBillingSupportedResponse(bool);
          long l = localBundle.getLong("REQUEST_ID", Consts.BILLING_RESPONSE_INVALID_REQUEST_ID);
          return l;
        }
        return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
      }
      catch (BillingService.MarketFailException localMarketFailException)
      {
        Logger.warn("checkBillingSupported failed");
        ResponseHandler.checkBillingSupportedResponse(false);
      }
    }
  }
  
  class ConfirmNotifications
    extends BillingService.BillingRequest
  {
    final String[] mNotifyIds;
    
    public ConfirmNotifications(int paramInt, String[] paramArrayOfString)
    {
      super(paramInt);
      this.mNotifyIds = paramArrayOfString;
    }
    
    protected long run()
      throws RemoteException
    {
      Bundle localBundle = makeRequestBundle("CONFIRM_NOTIFICATIONS");
      localBundle.putStringArray("NOTIFY_IDS", this.mNotifyIds);
      try
      {
        localBundle = send(localBundle);
        logResponseCode("confirmNotifications", localBundle);
        long l = localBundle.getLong("REQUEST_ID", Consts.BILLING_RESPONSE_INVALID_REQUEST_ID);
        return l;
      }
      catch (BillingService.MarketFailException localMarketFailException)
      {
        Logger.warn("confirmNotifications failed");
      }
      return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
    }
  }
  
  class GetPurchaseInformation
    extends BillingService.BillingRequest
  {
    long mNonce;
    final String[] mNotifyIds;
    
    public GetPurchaseInformation(int paramInt, String[] paramArrayOfString)
    {
      super(paramInt);
      this.mNotifyIds = paramArrayOfString;
    }
    
    protected void onRemoteException(RemoteException paramRemoteException)
    {
      super.onRemoteException(paramRemoteException);
      Security.removeNonce(this.mNonce);
    }
    
    protected long run()
      throws RemoteException
    {
      this.mNonce = Security.generateNonce();
      Bundle localBundle = makeRequestBundle("GET_PURCHASE_INFORMATION");
      localBundle.putLong("NONCE", this.mNonce);
      localBundle.putStringArray("NOTIFY_IDS", this.mNotifyIds);
      try
      {
        localBundle = send(localBundle);
        logResponseCode("getPurchaseInformation", localBundle);
        long l = localBundle.getLong("REQUEST_ID", Consts.BILLING_RESPONSE_INVALID_REQUEST_ID);
        return l;
      }
      catch (BillingService.MarketFailException localMarketFailException)
      {
        Logger.warn("getPurchaseInformation failed");
      }
      return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
    }
  }
  
  private class MarketFailException
    extends Exception
  {
    private static final long serialVersionUID = 1L;
    
    public MarketFailException(String paramString)
    {
      super();
    }
  }
  
  public class Purchase
  {
    public String developerPayload;
    public String notificationId;
    public String orderId;
    public String productId;
    public Consts.PurchaseState purchaseState;
    public long purchaseTime;
    
    public Purchase(Consts.PurchaseState paramPurchaseState, String paramString1, String paramString2, String paramString3, long paramLong, String paramString4)
    {
      this.purchaseState = paramPurchaseState;
      this.notificationId = paramString1;
      this.productId = paramString2;
      this.orderId = paramString3;
      this.purchaseTime = paramLong;
      this.developerPayload = paramString4;
    }
  }
  
  public class RequestPurchase
    extends BillingService.BillingRequest
  {
    public final Activity activity;
    public final String mDeveloperPayload;
    public final String mProductId;
    
    public RequestPurchase(Activity paramActivity, String paramString)
    {
      this(paramActivity, paramString, null);
    }
    
    public RequestPurchase(Activity paramActivity, String paramString1, String paramString2)
    {
      super(-1);
      this.mProductId = paramString1;
      this.mDeveloperPayload = paramString2;
      this.activity = paramActivity;
      Logger.debug("Request Purchase for: " + paramString1);
    }
    
    protected void responseCodeReceived(Consts.ResponseCode paramResponseCode)
    {
      ResponseHandler.responseCodeReceived(BillingService.this, this, paramResponseCode);
    }
    
    protected long run()
      throws RemoteException
    {
      Bundle localBundle = makeRequestBundle("REQUEST_PURCHASE");
      localBundle.putString("ITEM_ID", this.mProductId);
      if (this.mDeveloperPayload != null) {
        localBundle.putString("DEVELOPER_PAYLOAD", this.mDeveloperPayload);
      }
      try
      {
        localBundle = send(localBundle);
        PendingIntent localPendingIntent = (PendingIntent)localBundle.getParcelable("PURCHASE_INTENT");
        if (localPendingIntent == null)
        {
          Logger.error("Error with requestPurchase");
          return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
        }
        Intent localIntent = new Intent();
        ResponseHandler.buyPageIntentResponse(this.activity, localPendingIntent, localIntent);
        long l = localBundle.getLong("REQUEST_ID", Consts.BILLING_RESPONSE_INVALID_REQUEST_ID);
        return l;
      }
      catch (BillingService.MarketFailException localMarketFailException)
      {
        Logger.warn("requestPurchase failed");
      }
      return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
    }
  }
  
  public class RestoreTransactions
    extends BillingService.BillingRequest
  {
    long mNonce;
    
    public RestoreTransactions()
    {
      super(-1);
    }
    
    protected void onRemoteException(RemoteException paramRemoteException)
    {
      super.onRemoteException(paramRemoteException);
      Security.removeNonce(this.mNonce);
    }
    
    protected void responseCodeReceived(Consts.ResponseCode paramResponseCode)
    {
      ResponseHandler.responseCodeReceived(BillingService.this, this, paramResponseCode);
    }
    
    protected long run()
      throws RemoteException
    {
      this.mNonce = Security.generateNonce();
      Bundle localBundle = makeRequestBundle("RESTORE_TRANSACTIONS");
      localBundle.putLong("NONCE", this.mNonce);
      try
      {
        localBundle = send(localBundle);
        logResponseCode("restoreTransactions", localBundle);
        long l = localBundle.getLong("REQUEST_ID", Consts.BILLING_RESPONSE_INVALID_REQUEST_ID);
        return l;
      }
      catch (BillingService.MarketFailException localMarketFailException)
      {
        Logger.warn("resoreTransactions failed");
      }
      return Consts.BILLING_RESPONSE_INVALID_REQUEST_ID;
    }
  }
}
