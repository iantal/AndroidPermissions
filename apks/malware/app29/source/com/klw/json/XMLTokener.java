package com.klw.json;

import java.util.HashMap;

public class XMLTokener
  extends JSONTokener
{
  public static final HashMap<String, Character> entity = new HashMap(8);
  
  static
  {
    entity.put("amp", XML.AMP);
    entity.put("apos", XML.APOS);
    entity.put("gt", XML.GT);
    entity.put("lt", XML.LT);
    entity.put("quot", XML.QUOT);
  }
  
  public XMLTokener(String paramString)
  {
    super(paramString);
  }
  
  public String nextCDATA()
  {
    StringBuilder localStringBuilder = new StringBuilder();
    int i;
    do
    {
      char c = next();
      if (end()) {
        throw syntaxError("Unclosed CDATA");
      }
      localStringBuilder.append(c);
      i = localStringBuilder.length() - 3;
    } while ((i < 0) || (localStringBuilder.charAt(i) != ']') || (localStringBuilder.charAt(i + 1) != ']') || (localStringBuilder.charAt(i + 2) != '>'));
    localStringBuilder.setLength(i);
    return localStringBuilder.toString();
  }
  
  public Object nextContent()
  {
    char c;
    do
    {
      c = next();
    } while (Character.isWhitespace(c));
    if (c == 0) {
      return null;
    }
    if (c == '<') {
      return XML.LT;
    }
    StringBuilder localStringBuilder = new StringBuilder();
    if ((c == '<') || (c == 0))
    {
      back();
      return localStringBuilder.toString().trim();
    }
    if (c == '&') {
      localStringBuilder.append(nextEntity(c));
    }
    for (;;)
    {
      c = next();
      break;
      localStringBuilder.append(c);
    }
  }
  
  public Object nextEntity(char paramChar)
  {
    Object localObject1 = new StringBuilder();
    char c;
    for (;;)
    {
      c = next();
      if ((!Character.isLetterOrDigit(c)) && (c != '#')) {
        break;
      }
      ((StringBuilder)localObject1).append(Character.toLowerCase(c));
    }
    if (c == ';')
    {
      localObject1 = ((StringBuilder)localObject1).toString();
      Object localObject2 = entity.get(localObject1);
      if (localObject2 != null) {
        return localObject2;
      }
    }
    else
    {
      throw syntaxError("Missing ';' in XML entity: &" + localObject1);
    }
    return paramChar + (String)localObject1 + ";";
  }
  
  public Object nextMeta()
  {
    char c1;
    do
    {
      c1 = next();
    } while (Character.isWhitespace(c1));
    switch (c1)
    {
    }
    for (;;)
    {
      c1 = next();
      if (Character.isWhitespace(c1))
      {
        return Boolean.TRUE;
        throw syntaxError("Misshaped meta tag");
        return XML.LT;
        return XML.GT;
        return XML.SLASH;
        return XML.EQ;
        return XML.BANG;
        return XML.QUEST;
        char c2;
        do
        {
          c2 = next();
          if (c2 == 0) {
            throw syntaxError("Unterminated string");
          }
        } while (c2 != c1);
        return Boolean.TRUE;
      }
      switch (c1)
      {
      }
    }
    back();
    return Boolean.TRUE;
  }
  
  public Object nextToken()
  {
    char c1;
    do
    {
      c1 = next();
    } while (Character.isWhitespace(c1));
    StringBuilder localStringBuilder;
    switch (c1)
    {
    default: 
      localStringBuilder = new StringBuilder();
    }
    for (;;)
    {
      localStringBuilder.append(c1);
      c1 = next();
      if (Character.isWhitespace(c1))
      {
        return localStringBuilder.toString();
        throw syntaxError("Misshaped element");
        throw syntaxError("Misplaced '<'");
        return XML.GT;
        return XML.SLASH;
        return XML.EQ;
        return XML.BANG;
        return XML.QUEST;
        localStringBuilder = new StringBuilder();
        for (;;)
        {
          char c2 = next();
          if (c2 == 0) {
            throw syntaxError("Unterminated string");
          }
          if (c2 == c1) {
            return localStringBuilder.toString();
          }
          if (c2 == '&') {
            localStringBuilder.append(nextEntity(c2));
          } else {
            localStringBuilder.append(c2);
          }
        }
      }
      switch (c1)
      {
      }
    }
    return localStringBuilder.toString();
    back();
    return localStringBuilder.toString();
    throw syntaxError("Bad character in a name");
  }
  
  public boolean skipPast(String paramString)
  {
    boolean bool2 = false;
    int i1 = paramString.length();
    char[] arrayOfChar = new char[i1];
    int j = 0;
    if (j >= i1) {
      j = 0;
    }
    for (;;)
    {
      int m = 0;
      int k = j;
      label31:
      label41:
      boolean bool1;
      if (m >= i1)
      {
        k = 1;
        if (k == 0) {
          break label130;
        }
        bool1 = true;
      }
      int i;
      label130:
      do
      {
        do
        {
          return bool1;
          i = next();
          bool1 = bool2;
        } while (i == 0);
        arrayOfChar[j] = i;
        j += 1;
        break;
        if (arrayOfChar[k] != paramString.charAt(m))
        {
          k = 0;
          break label41;
        }
        int n = k + 1;
        k = n;
        if (n >= i1) {
          k = n - i1;
        }
        m += 1;
        break label31;
        i = next();
        bool1 = bool2;
      } while (i == 0);
      arrayOfChar[j] = i;
      k = j + 1;
      j = k;
      if (k >= i1) {
        j = k - i1;
      }
    }
  }
}
