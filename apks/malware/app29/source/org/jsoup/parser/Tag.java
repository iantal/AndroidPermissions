package org.jsoup.parser;

import java.util.HashMap;
import java.util.Map;
import org.jsoup.helper.Validate;

public class Tag
{
  private static final String[] blockTags;
  private static final String[] emptyTags;
  private static final String[] formatAsInlineTags;
  private static final String[] inlineTags;
  private static final String[] preserveWhitespaceTags;
  private static final Map<String, Tag> tags;
  private boolean canContainBlock = true;
  private boolean canContainInline = true;
  private boolean empty = false;
  private boolean formatAsBlock = true;
  private boolean isBlock = true;
  private boolean preserveWhitespace = false;
  private boolean selfClosing = false;
  private String tagName;
  
  static
  {
    int j = 0;
    tags = new HashMap();
    blockTags = new String[] { "html", "head", "body", "frameset", "script", "noscript", "style", "meta", "link", "title", "frame", "noframes", "section", "nav", "aside", "hgroup", "header", "footer", "p", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", "ins", "del", "s", "dl", "dt", "dd", "li", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col", "tr", "th", "td", "video", "audio", "canvas", "details", "menu", "plaintext" };
    inlineTags = new String[] { "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd", "var", "cite", "abbr", "time", "acronym", "mark", "ruby", "rt", "rp", "a", "img", "br", "wbr", "map", "q", "sub", "sup", "bdo", "iframe", "embed", "span", "input", "select", "textarea", "label", "button", "optgroup", "option", "legend", "datalist", "keygen", "output", "progress", "meter", "area", "param", "source", "track", "summary", "command", "device" };
    emptyTags = new String[] { "meta", "link", "base", "frame", "img", "br", "wbr", "embed", "hr", "input", "keygen", "col", "command", "device" };
    formatAsInlineTags = new String[] { "title", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6", "pre", "address", "li", "th", "td", "script", "style", "ins", "del", "s" };
    preserveWhitespaceTags = new String[] { "pre", "plaintext", "title", "textarea" };
    String[] arrayOfString = blockTags;
    int k = arrayOfString.length;
    int i = 0;
    while (i < k)
    {
      register(new Tag(arrayOfString[i]));
      i += 1;
    }
    arrayOfString = inlineTags;
    k = arrayOfString.length;
    i = 0;
    Object localObject;
    while (i < k)
    {
      localObject = new Tag(arrayOfString[i]);
      ((Tag)localObject).isBlock = false;
      ((Tag)localObject).canContainBlock = false;
      ((Tag)localObject).formatAsBlock = false;
      register((Tag)localObject);
      i += 1;
    }
    arrayOfString = emptyTags;
    k = arrayOfString.length;
    i = 0;
    while (i < k)
    {
      localObject = arrayOfString[i];
      localObject = (Tag)tags.get(localObject);
      Validate.notNull(localObject);
      ((Tag)localObject).canContainBlock = false;
      ((Tag)localObject).canContainInline = false;
      ((Tag)localObject).empty = true;
      i += 1;
    }
    arrayOfString = formatAsInlineTags;
    k = arrayOfString.length;
    i = 0;
    while (i < k)
    {
      localObject = arrayOfString[i];
      localObject = (Tag)tags.get(localObject);
      Validate.notNull(localObject);
      ((Tag)localObject).formatAsBlock = false;
      i += 1;
    }
    arrayOfString = preserveWhitespaceTags;
    k = arrayOfString.length;
    i = j;
    while (i < k)
    {
      localObject = arrayOfString[i];
      localObject = (Tag)tags.get(localObject);
      Validate.notNull(localObject);
      ((Tag)localObject).preserveWhitespace = true;
      i += 1;
    }
  }
  
  private Tag(String paramString)
  {
    this.tagName = paramString.toLowerCase();
  }
  
  public static boolean isKnownTag(String paramString)
  {
    return tags.containsKey(paramString);
  }
  
  private static void register(Tag paramTag)
  {
    tags.put(paramTag.tagName, paramTag);
  }
  
  public static Tag valueOf(String paramString)
  {
    Validate.notNull(paramString);
    Object localObject2 = (Tag)tags.get(paramString);
    Object localObject1 = localObject2;
    if (localObject2 == null)
    {
      localObject2 = paramString.trim().toLowerCase();
      Validate.notEmpty((String)localObject2);
      paramString = (Tag)tags.get(localObject2);
      localObject1 = paramString;
      if (paramString == null)
      {
        localObject1 = new Tag((String)localObject2);
        ((Tag)localObject1).isBlock = false;
        ((Tag)localObject1).canContainBlock = true;
      }
    }
    return localObject1;
  }
  
  public boolean canContainBlock()
  {
    return this.canContainBlock;
  }
  
  public boolean equals(Object paramObject)
  {
    boolean bool2 = false;
    if (this == paramObject) {}
    do
    {
      boolean bool1 = true;
      do
      {
        do
        {
          do
          {
            do
            {
              do
              {
                do
                {
                  do
                  {
                    do
                    {
                      return bool1;
                      bool1 = bool2;
                    } while (!(paramObject instanceof Tag));
                    paramObject = (Tag)paramObject;
                    bool1 = bool2;
                  } while (this.canContainBlock != paramObject.canContainBlock);
                  bool1 = bool2;
                } while (this.canContainInline != paramObject.canContainInline);
                bool1 = bool2;
              } while (this.empty != paramObject.empty);
              bool1 = bool2;
            } while (this.formatAsBlock != paramObject.formatAsBlock);
            bool1 = bool2;
          } while (this.isBlock != paramObject.isBlock);
          bool1 = bool2;
        } while (this.preserveWhitespace != paramObject.preserveWhitespace);
        bool1 = bool2;
      } while (this.selfClosing != paramObject.selfClosing);
    } while (this.tagName.equals(paramObject.tagName));
    return false;
  }
  
  public boolean formatAsBlock()
  {
    return this.formatAsBlock;
  }
  
  public String getName()
  {
    return this.tagName;
  }
  
  public int hashCode()
  {
    int i2 = 0;
    int i3 = this.tagName.hashCode();
    int i;
    int j;
    label30:
    int k;
    label39:
    int m;
    label49:
    int n;
    if (this.isBlock)
    {
      i = 1;
      if (!this.formatAsBlock) {
        break label126;
      }
      j = 1;
      if (!this.canContainBlock) {
        break label131;
      }
      k = 1;
      if (!this.canContainInline) {
        break label136;
      }
      m = 1;
      if (!this.empty) {
        break label142;
      }
      n = 1;
      label59:
      if (!this.selfClosing) {
        break label148;
      }
    }
    label126:
    label131:
    label136:
    label142:
    label148:
    for (int i1 = 1;; i1 = 0)
    {
      if (this.preserveWhitespace) {
        i2 = 1;
      }
      return (i1 + (n + (m + (k + (j + (i + i3 * 31) * 31) * 31) * 31) * 31) * 31) * 31 + i2;
      i = 0;
      break;
      j = 0;
      break label30;
      k = 0;
      break label39;
      m = 0;
      break label49;
      n = 0;
      break label59;
    }
  }
  
  public boolean isBlock()
  {
    return this.isBlock;
  }
  
  public boolean isData()
  {
    return (!this.canContainInline) && (!isEmpty());
  }
  
  public boolean isEmpty()
  {
    return this.empty;
  }
  
  public boolean isInline()
  {
    return !this.isBlock;
  }
  
  public boolean isKnownTag()
  {
    return tags.containsKey(this.tagName);
  }
  
  public boolean isSelfClosing()
  {
    return (this.empty) || (this.selfClosing);
  }
  
  public boolean preserveWhitespace()
  {
    return this.preserveWhitespace;
  }
  
  Tag setSelfClosing()
  {
    this.selfClosing = true;
    return this;
  }
  
  public String toString()
  {
    return this.tagName;
  }
}
