package de.tavendo.autobahn;

import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.util.Pair;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.HashMap;
import java.util.Map;

public class WebSocketReader
  extends Thread
{
  private static final boolean DEBUG = true;
  private static final int STATE_CLOSED = 0;
  private static final int STATE_CLOSING = 2;
  private static final int STATE_CONNECTING = 1;
  private static final int STATE_OPEN = 3;
  private static final String TAG = WebSocketReader.class.getName();
  private final ByteBuffer mFrameBuffer;
  private WebSocketReader.FrameHeader mFrameHeader;
  private boolean mInsideMessage = false;
  private final Handler mMaster;
  private int mMessageOpcode;
  private NoCopyByteArrayOutputStream mMessagePayload;
  private final WebSocketOptions mOptions;
  private final SocketChannel mSocket;
  private int mState;
  private boolean mStopped = false;
  private Utf8Validator mUtf8Validator = new Utf8Validator();
  
  public WebSocketReader(Handler paramHandler, SocketChannel paramSocketChannel, WebSocketOptions paramWebSocketOptions, String paramString)
  {
    super(paramString);
    this.mMaster = paramHandler;
    this.mSocket = paramSocketChannel;
    this.mOptions = paramWebSocketOptions;
    this.mFrameBuffer = ByteBuffer.allocateDirect(paramWebSocketOptions.getMaxFramePayloadSize() + 14);
    this.mMessagePayload = new NoCopyByteArrayOutputStream(paramWebSocketOptions.getMaxMessagePayloadSize());
    this.mFrameHeader = null;
    this.mState = 1;
    Log.d(TAG, "created");
  }
  
  private boolean consumeData()
  {
    boolean bool = false;
    if ((this.mState == 3) || (this.mState == 2)) {
      bool = processData();
    }
    do
    {
      return bool;
      if (this.mState == 1) {
        return processHandshake();
      }
    } while (this.mState != 0);
    return false;
  }
  
  private Map<String, String> parseHttpHeaders(byte[] paramArrayOfByte)
  {
    Object localObject = new String(paramArrayOfByte, "UTF-8");
    paramArrayOfByte = new HashMap();
    localObject = ((String)localObject).split("\r\n");
    int j = localObject.length;
    int i = 0;
    for (;;)
    {
      if (i >= j) {
        return paramArrayOfByte;
      }
      String[] arrayOfString = localObject[i];
      if (arrayOfString.length() > 0)
      {
        arrayOfString = arrayOfString.split(": ");
        if (arrayOfString.length == 2)
        {
          paramArrayOfByte.put(arrayOfString[0], arrayOfString[1]);
          Log.w(TAG, String.format("'%s'='%s'", new Object[] { arrayOfString[0], arrayOfString[1] }));
        }
      }
      i += 1;
    }
  }
  
  private Pair<Integer, String> parseHttpStatus()
  {
    int i = 4;
    label13:
    int j;
    label17:
    label28:
    int m;
    int k;
    if (i >= this.mFrameBuffer.position())
    {
      j = i + 1;
      if (j < this.mFrameBuffer.position()) {
        break label167;
      }
      m = i + 1;
      k = 0;
      i = 0;
      label37:
      if (m + k < j) {
        break label187;
      }
      k = j + 1;
      j = k;
    }
    for (;;)
    {
      if (j >= this.mFrameBuffer.position()) {}
      label167:
      label187:
      while (this.mFrameBuffer.get(j) == 13)
      {
        j -= k;
        Object localObject = new byte[j];
        this.mFrameBuffer.position(k);
        this.mFrameBuffer.get((byte[])localObject, 0, j);
        localObject = new String((byte[])localObject, "UTF-8");
        Log.w(TAG, String.format("Status: %d (%s)", new Object[] { Integer.valueOf(i), localObject }));
        return new Pair(Integer.valueOf(i), localObject);
        if (this.mFrameBuffer.get(i) == 32) {
          break label13;
        }
        i += 1;
        break;
        if (this.mFrameBuffer.get(j) == 32) {
          break label28;
        }
        j += 1;
        break label17;
        i = i * 10 + (this.mFrameBuffer.get(m + k) - 48);
        k += 1;
        break label37;
      }
      j += 1;
    }
  }
  
  private boolean processData()
  {
    int j = 2;
    if (this.mFrameHeader == null) {
      if (this.mFrameBuffer.position() >= 2)
      {
        i = this.mFrameBuffer.get(0);
        if ((i & 0x80) != 0)
        {
          bool = true;
          m = (i & 0x70) >> 4;
          n = i & 0xF;
          i = this.mFrameBuffer.get(1);
          if ((i & 0x80) == 0) {
            break label100;
          }
        }
        label100:
        for (k = 1;; k = 0)
        {
          i1 = i & 0x7F;
          if (m == 0) {
            break label105;
          }
          throw new WebSocketException("RSV != 0 and no extension negotiated");
          bool = false;
          break;
        }
        label105:
        if (k != 0) {
          throw new WebSocketException("masked server frame");
        }
        if (n > 7)
        {
          if (!bool) {
            throw new WebSocketException("fragmented control frame");
          }
          if (i1 > 125) {
            throw new WebSocketException("control frame with payload length > 125 octets");
          }
          if ((n != 8) && (n != 9) && (n != 10)) {
            throw new WebSocketException("control frame using reserved opcode " + n);
          }
          if ((n == 8) && (i1 == 1)) {
            throw new WebSocketException("received close control frame with payload len 1");
          }
        }
        else
        {
          if ((n != 0) && (n != 1) && (n != 2)) {
            throw new WebSocketException("data frame using reserved opcode " + n);
          }
          if ((!this.mInsideMessage) && (n == 0)) {
            throw new WebSocketException("received continuation data frame outside fragmented message");
          }
          if ((this.mInsideMessage) && (n != 0)) {
            throw new WebSocketException("received non-continuation data frame while inside fragmented message");
          }
        }
        if (k != 0)
        {
          i = 4;
          if (i1 >= 126) {
            break label403;
          }
          i += 2;
        }
        for (;;)
        {
          if (this.mFrameBuffer.position() >= i)
          {
            if (i1 == 126)
            {
              l = (this.mFrameBuffer.get(2) & 0xFF) << 8 | this.mFrameBuffer.get(3) & 0xFF;
              if (l < 126L)
              {
                throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
                i = 0;
                break;
                label403:
                if (i1 == 126)
                {
                  i += 4;
                  continue;
                }
                if (i1 == 127)
                {
                  i += 10;
                  continue;
                }
                throw new Exception("logic error");
              }
              j = 4;
            }
            while (l > this.mOptions.getMaxFramePayloadSize())
            {
              throw new WebSocketException("frame payload too large");
              if (i1 == 127)
              {
                if ((this.mFrameBuffer.get(2) & 0x80) != 0) {
                  throw new WebSocketException("invalid data frame length (> 2^63)");
                }
                l = (this.mFrameBuffer.get(2) & 0xFF) << 56 | (this.mFrameBuffer.get(3) & 0xFF) << 48 | (this.mFrameBuffer.get(4) & 0xFF) << 40 | (this.mFrameBuffer.get(5) & 0xFF) << 32 | (this.mFrameBuffer.get(6) & 0xFF) << 24 | (this.mFrameBuffer.get(7) & 0xFF) << 16 | (this.mFrameBuffer.get(8) & 0xFF) << 8 | this.mFrameBuffer.get(9) & 0xFF;
                if (l < 65536L) {
                  throw new WebSocketException("invalid data frame length (not using minimal length encoding)");
                }
                j = 10;
              }
              else
              {
                l = i1;
              }
            }
            this.mFrameHeader = new WebSocketReader.FrameHeader(null);
            this.mFrameHeader.mOpcode = n;
            this.mFrameHeader.mFin = bool;
            this.mFrameHeader.mReserved = m;
            this.mFrameHeader.mPayloadLen = ((int)l);
            this.mFrameHeader.mHeaderLen = i;
            this.mFrameHeader.mTotalLen = (this.mFrameHeader.mHeaderLen + this.mFrameHeader.mPayloadLen);
            if (k == 0) {
              break label831;
            }
            this.mFrameHeader.mMask = new byte[4];
            i = 0;
            if (i < 4) {
              break label800;
            }
            if ((this.mFrameHeader.mPayloadLen == 0) || (this.mFrameBuffer.position() >= this.mFrameHeader.mTotalLen)) {
              break label842;
            }
          }
        }
      }
    }
    label800:
    label831:
    label842:
    while (this.mFrameBuffer.position() < this.mFrameHeader.mTotalLen)
    {
      for (;;)
      {
        boolean bool;
        int m;
        int n;
        int k;
        int i1;
        long l;
        return false;
        this.mFrameHeader.mMask[j] = ((byte)(this.mFrameBuffer.get(j + i) & 0xFF));
        i += 1;
        continue;
        this.mFrameHeader.mMask = null;
      }
      return true;
    }
    int i = this.mFrameBuffer.position();
    Object localObject;
    if (this.mFrameHeader.mPayloadLen > 0)
    {
      localObject = new byte[this.mFrameHeader.mPayloadLen];
      this.mFrameBuffer.position(this.mFrameHeader.mHeaderLen);
      this.mFrameBuffer.get((byte[])localObject, 0, this.mFrameHeader.mPayloadLen);
    }
    for (;;)
    {
      this.mFrameBuffer.position(this.mFrameHeader.mTotalLen);
      this.mFrameBuffer.limit(i);
      this.mFrameBuffer.compact();
      if (this.mFrameHeader.mOpcode > 7) {
        if (this.mFrameHeader.mOpcode == 8)
        {
          i = 1005;
          if (this.mFrameHeader.mPayloadLen < 2) {
            break label1578;
          }
          j = (localObject[0] & 0xFF) * 256 + (localObject[1] & 0xFF);
          if ((j < 1000) || ((j >= 1000) && (j <= 2999) && (j != 1000) && (j != 1001) && (j != 1002) && (j != 1003) && (j != 1007) && (j != 1008) && (j != 1009) && (j != 1010) && (j != 1011)) || (j >= 5000)) {
            throw new WebSocketException("invalid close code " + j);
          }
          i = j;
          if (this.mFrameHeader.mPayloadLen <= 2) {
            break label1578;
          }
          byte[] arrayOfByte = new byte[this.mFrameHeader.mPayloadLen - 2];
          System.arraycopy(localObject, 2, arrayOfByte, 0, this.mFrameHeader.mPayloadLen - 2);
          localObject = new Utf8Validator();
          ((Utf8Validator)localObject).validate(arrayOfByte);
          if (!((Utf8Validator)localObject).isValid()) {
            throw new WebSocketException("invalid close reasons (not UTF-8)");
          }
          localObject = new String(arrayOfByte, "UTF-8");
          i = j;
        }
      }
      for (;;)
      {
        onClose(i, (String)localObject);
        label1293:
        do
        {
          for (;;)
          {
            this.mFrameHeader = null;
            if (this.mFrameBuffer.position() <= 0) {
              break;
            }
            return true;
            if (this.mFrameHeader.mOpcode == 9)
            {
              onPing((byte[])localObject);
            }
            else
            {
              if (this.mFrameHeader.mOpcode != 10) {
                break label1293;
              }
              onPong((byte[])localObject);
            }
          }
          throw new Exception("logic error");
          if (!this.mInsideMessage)
          {
            this.mInsideMessage = true;
            this.mMessageOpcode = this.mFrameHeader.mOpcode;
            if ((this.mMessageOpcode == 1) && (this.mOptions.getValidateIncomingUtf8())) {
              this.mUtf8Validator.reset();
            }
          }
          if (localObject != null)
          {
            if (this.mMessagePayload.size() + localObject.length > this.mOptions.getMaxMessagePayloadSize()) {
              throw new WebSocketException("message payload too large");
            }
            if ((this.mMessageOpcode == 1) && (this.mOptions.getValidateIncomingUtf8()) && (!this.mUtf8Validator.validate((byte[])localObject))) {
              throw new WebSocketException("invalid UTF-8 in text message payload");
            }
            this.mMessagePayload.write((byte[])localObject);
          }
        } while (!this.mFrameHeader.mFin);
        if (this.mMessageOpcode == 1)
        {
          if ((this.mOptions.getValidateIncomingUtf8()) && (!this.mUtf8Validator.isValid())) {
            throw new WebSocketException("UTF-8 text message payload ended within Unicode code point");
          }
          if (this.mOptions.getReceiveTextMessagesRaw()) {
            onRawTextMessage(this.mMessagePayload.toByteArray());
          }
        }
        for (;;)
        {
          this.mInsideMessage = false;
          this.mMessagePayload.reset();
          break;
          onTextMessage(new String(this.mMessagePayload.toByteArray(), "UTF-8"));
          continue;
          if (this.mMessageOpcode != 2) {
            break label1568;
          }
          onBinaryMessage(this.mMessagePayload.toByteArray());
        }
        label1568:
        throw new Exception("logic error");
        label1578:
        localObject = null;
      }
      localObject = null;
    }
  }
  
  private boolean processHandshake()
  {
    boolean bool2 = true;
    int i = this.mFrameBuffer.position() - 4;
    if (i < 0) {
      return false;
    }
    int k;
    if ((this.mFrameBuffer.get(i + 0) == 13) && (this.mFrameBuffer.get(i + 1) == 10) && (this.mFrameBuffer.get(i + 2) == 13) && (this.mFrameBuffer.get(i + 3) == 10))
    {
      k = this.mFrameBuffer.position();
      if ((this.mFrameBuffer.get(0) != 72) || (this.mFrameBuffer.get(1) != 84) || (this.mFrameBuffer.get(2) != 84) || (this.mFrameBuffer.get(3) != 80)) {
        break label289;
      }
      Pair localPair = parseHttpStatus();
      if (((Integer)localPair.first).intValue() < 300) {
        break label289;
      }
      notify(new WebSocketMessage.ServerError(((Integer)localPair.first).intValue(), (String)localPair.second));
    }
    label289:
    for (int j = 1;; j = 0)
    {
      this.mFrameBuffer.position(i + 4);
      this.mFrameBuffer.limit(k);
      this.mFrameBuffer.compact();
      boolean bool1;
      if (j == 0) {
        if (this.mFrameBuffer.position() > 0)
        {
          bool1 = true;
          this.mState = 3;
        }
      }
      for (;;)
      {
        if (j != 0) {
          bool2 = false;
        }
        onHandshake(bool2);
        return bool1;
        bool1 = false;
        break;
        this.mState = 0;
        this.mStopped = true;
        bool1 = true;
      }
      i -= 1;
      break;
    }
  }
  
  protected void notify(Object paramObject)
  {
    Message localMessage = this.mMaster.obtainMessage();
    localMessage.obj = paramObject;
    this.mMaster.sendMessage(localMessage);
  }
  
  protected void onBinaryMessage(byte[] paramArrayOfByte)
  {
    notify(new WebSocketMessage.BinaryMessage(paramArrayOfByte));
  }
  
  protected void onClose(int paramInt, String paramString)
  {
    notify(new WebSocketMessage.Close(paramInt, paramString));
  }
  
  protected void onHandshake(boolean paramBoolean)
  {
    notify(new WebSocketMessage.ServerHandshake(paramBoolean));
  }
  
  protected void onPing(byte[] paramArrayOfByte)
  {
    notify(new WebSocketMessage.Ping(paramArrayOfByte));
  }
  
  protected void onPong(byte[] paramArrayOfByte)
  {
    notify(new WebSocketMessage.Pong(paramArrayOfByte));
  }
  
  protected void onRawTextMessage(byte[] paramArrayOfByte)
  {
    notify(new WebSocketMessage.RawTextMessage(paramArrayOfByte));
  }
  
  protected void onTextMessage(String paramString)
  {
    notify(new WebSocketMessage.TextMessage(paramString));
  }
  
  public void quit()
  {
    this.mState = 0;
    Log.d(TAG, "quit");
  }
  
  public void run()
  {
    Log.d(TAG, "running");
    for (;;)
    {
      try
      {
        this.mFrameBuffer.clear();
        i = this.mSocket.read(this.mFrameBuffer);
        if (i <= 0) {
          continue;
        }
        if (consumeData()) {
          continue;
        }
      }
      catch (WebSocketException localWebSocketException)
      {
        int i;
        boolean bool;
        Log.d(TAG, "run() : WebSocketException (" + localWebSocketException.toString() + ")");
        notify(new WebSocketMessage.ProtocolViolation(localWebSocketException));
        this.mStopped = true;
        continue;
        if (i >= 0) {
          continue;
        }
        Log.d(TAG, "run() : ConnectionLost");
        notify(new WebSocketMessage.ConnectionLost());
        this.mStopped = true;
        continue;
      }
      catch (SocketException localSocketException)
      {
        Log.d(TAG, "run() : SocketException (" + localSocketException.toString() + ")");
        notify(new WebSocketMessage.ConnectionLost());
        this.mStopped = true;
        continue;
      }
      catch (Exception localException)
      {
        Log.d(TAG, "run() : Exception (" + localException.toString() + ")");
        notify(new WebSocketMessage.Error(localException));
        this.mStopped = true;
        continue;
      }
      finally
      {
        this.mStopped = true;
      }
      bool = this.mStopped;
      if (bool)
      {
        this.mStopped = true;
        Log.d(TAG, "ended");
        return;
        if (this.mState != 0) {
          continue;
        }
        notify(new WebSocketMessage.Close(1000));
        this.mStopped = true;
      }
    }
  }
}
