package com.chartboost.sdk.impl;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Proxy;
import java.net.Proxy.Type;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.List;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

public final class cd
  implements Closeable
{
  private final ce a;
  private final cl b;
  private Socket c;
  private InputStream d;
  private OutputStream e;
  private dr f;
  private dq g;
  private boolean h = false;
  private cy i;
  private eu j;
  private int k = 1;
  private long l;
  private cf m;
  private int n;
  
  public cd(ce paramCe, cl paramCl)
  {
    this.a = paramCe;
    this.b = paramCl;
  }
  
  private void a(cn paramCn)
  {
    Object localObject = cr.a();
    if (l()) {
      b(paramCn);
    }
    this.c = this.b.a.d.createSocket(this.c, this.b.a.b, this.b.a.c, true);
    SSLSocket localSSLSocket = (SSLSocket)this.c;
    int i1;
    if (this.b.d)
    {
      ((cr)localObject).a(localSSLSocket, this.b.a.b);
      if ((!this.b.d) || ((!this.b.a.g.contains(cj.a)) && (!this.b.a.g.contains(cj.b)))) {
        break label294;
      }
      i1 = 1;
      label149:
      if (i1 != 0)
      {
        if ((!this.b.a.g.contains(cj.a)) || (!this.b.a.g.contains(cj.b))) {
          break label299;
        }
        ((cr)localObject).a(localSSLSocket, cs.f);
      }
    }
    for (;;)
    {
      localSSLSocket.startHandshake();
      if (this.b.a.e.verify(this.b.a.b, localSSLSocket.getSession())) {
        break label346;
      }
      throw new IOException("Hostname '" + this.b.a.b + "' was not verified");
      ((cr)localObject).a(localSSLSocket);
      break;
      label294:
      i1 = 0;
      break label149;
      label299:
      if (this.b.a.g.contains(cj.a)) {
        ((cr)localObject).a(localSSLSocket, cs.h);
      } else {
        ((cr)localObject).a(localSSLSocket, cs.g);
      }
    }
    label346:
    this.e = localSSLSocket.getOutputStream();
    this.d = localSSLSocket.getInputStream();
    this.m = cf.a(localSSLSocket.getSession());
    o();
    cj localCj = cj.c;
    paramCn = localCj;
    if (i1 != 0)
    {
      localObject = ((cr)localObject).b(localSSLSocket);
      paramCn = localCj;
      if (localObject != null) {
        paramCn = cs.a((ds)localObject);
      }
    }
    if (paramCn.e)
    {
      localSSLSocket.setSoTimeout(0);
      this.j = new eu.a(this.b.a.a(), true, this.f, this.g).a(paramCn).a();
      this.j.e();
      return;
    }
    this.i = new cy(this.a, this, this.f, this.g);
  }
  
  private void b(cn paramCn)
  {
    dr localDr = dy.a(dy.a(this.d));
    Object localObject = dy.a(dy.a(this.e));
    cy localCy = new cy(this.a, this, localDr, (dq)localObject);
    localObject = paramCn.b();
    String str = paramCn.a();
    paramCn = (cn)localObject;
    do
    {
      localCy.a(paramCn.d(), str);
      localCy.d();
      paramCn = localCy.e().a(paramCn).a();
      localCy.g();
      switch (paramCn.c())
      {
      default: 
        throw new IOException("Unexpected response code for CONNECT: " + paramCn.c());
      case 200: 
        if (localDr.b().l() <= 0L) {
          break;
        }
        throw new IOException("TLS tunnel buffered too many bytes!");
      case 407: 
        localObject = cx.a(this.b.a.f, paramCn, this.b.b);
        paramCn = (cn)localObject;
      }
    } while (localObject != null);
    throw new IOException("Failed to authenticate with proxy");
  }
  
  private void o()
  {
    this.f = dy.a(dy.a(this.d));
    this.g = dy.a(dy.a(this.e));
  }
  
  public Object a(da paramDa)
  {
    if (this.j != null) {
      return new dm(paramDa, this.j);
    }
    return new dc(paramDa, this.i);
  }
  
  public void a(int paramInt)
  {
    this.k = paramInt;
  }
  
  public void a(int paramInt1, int paramInt2, cn paramCn)
  {
    if (this.h) {
      throw new IllegalStateException("already connected");
    }
    Socket localSocket;
    if (this.b.b.type() != Proxy.Type.HTTP)
    {
      localSocket = new Socket(this.b.b);
      this.c = localSocket;
      cr.a().a(this.c, this.b.c, paramInt1);
      this.c.setSoTimeout(paramInt2);
      this.d = this.c.getInputStream();
      this.e = this.c.getOutputStream();
      if (this.b.a.d == null) {
        break label140;
      }
      a(paramCn);
    }
    for (;;)
    {
      this.h = true;
      return;
      localSocket = new Socket();
      break;
      label140:
      o();
      this.i = new cy(this.a, this, this.f, this.g);
    }
  }
  
  public boolean a()
  {
    return this.h;
  }
  
  public boolean a(long paramLong)
  {
    return h() < System.nanoTime() - paramLong;
  }
  
  public cl b()
  {
    return this.b;
  }
  
  public void b(int paramInt)
  {
    if (!this.h) {
      throw new IllegalStateException("updateReadTimeout - not connected");
    }
    this.c.setSoTimeout(paramInt);
  }
  
  public Socket c()
  {
    return this.c;
  }
  
  public void close()
  {
    this.c.close();
  }
  
  public boolean d()
  {
    return (!this.c.isClosed()) && (!this.c.isInputShutdown()) && (!this.c.isOutputShutdown());
  }
  
  public boolean e()
  {
    if (this.f == null) {}
    while (j()) {
      return true;
    }
    try
    {
      int i1 = this.c.getSoTimeout();
      try
      {
        this.c.setSoTimeout(1);
        boolean bool = this.f.e();
        return !bool;
      }
      finally
      {
        this.c.setSoTimeout(i1);
      }
      return true;
    }
    catch (IOException localIOException)
    {
      return false;
    }
    catch (SocketTimeoutException localSocketTimeoutException) {}
  }
  
  public void f()
  {
    if (this.j != null) {
      throw new IllegalStateException("spdyConnection != null");
    }
    this.l = System.nanoTime();
  }
  
  public boolean g()
  {
    return (this.j == null) || (this.j.b());
  }
  
  public long h()
  {
    if (this.j == null) {
      return this.l;
    }
    return this.j.c();
  }
  
  public cf i()
  {
    return this.m;
  }
  
  public boolean j()
  {
    return this.j != null;
  }
  
  public int k()
  {
    return this.k;
  }
  
  public boolean l()
  {
    return (this.b.a.d != null) && (this.b.b.type() == Proxy.Type.HTTP);
  }
  
  public void m()
  {
    this.n += 1;
  }
  
  public int n()
  {
    return this.n;
  }
}
