package com.tencent.android.tpush.service.channel.c;

import com.tencent.android.tpush.service.channel.exception.IORefusedException;
import java.io.IOException;
import java.io.OutputStream;

public class c
  extends OutputStream
{
  protected c(a paramA) {}
  
  public void close()
  {
    synchronized (this.a)
    {
      if (!this.a.k) {
        flush();
      }
      this.a.k = true;
      return;
    }
  }
  
  public void flush()
  {
    if (this.a.k) {
      throw new IOException("OutputStream has been closed; cannot flush a closed OutputStream.");
    }
    if (this.a.i) {
      throw new IOException("Buffer closed by inputStream; cannot flush.");
    }
  }
  
  public void write(int paramInt)
  {
    int i = 0;
    int k;
    if (i == 0)
    {
      synchronized (this.a)
      {
        if (this.a.k) {
          throw new IOException("OutputStream has been closed; cannot write to a closed OutputStream.");
        }
      }
      if (this.a.i) {
        throw new IOException("Buffer closed by InputStream; cannot write to a closed buffer.");
      }
      for (int j = a.c(this.a); (this.a.f) && (j < 1); j = a.c(this.a)) {
        a.d(this.a);
      }
      if ((!this.a.g) && (j < 1)) {
        throw new IORefusedException("CircularByteBuffer is full; cannot write 1 byte");
      }
      k = i;
      if (j > 0)
      {
        this.a.a[this.a.c] = ((byte)(paramInt & 0xFF));
        a localA2 = this.a;
        localA2.c += 1;
        if (this.a.c != this.a.a.length) {
          break label240;
        }
        this.a.c = 0;
        break label240;
      }
    }
    for (;;)
    {
      i = k;
      if (k != 0) {
        break;
      }
      try
      {
        Thread.sleep(100L);
        i = k;
      }
      catch (Exception localException)
      {
        throw new IOException("Waiting for available space in buffer interrupted.");
      }
      return;
      label240:
      k = 1;
    }
  }
  
  public void write(byte[] paramArrayOfByte)
  {
    write(paramArrayOfByte, 0, paramArrayOfByte.length);
  }
  
  public void write(byte[] paramArrayOfByte, int paramInt1, int paramInt2)
  {
    if (paramInt2 > 0)
    {
      synchronized (this.a)
      {
        if (this.a.k) {
          throw new IOException("OutputStream has been closed; cannot write to a closed OutputStream.");
        }
      }
      if (this.a.i) {
        throw new IOException("Buffer closed by InputStream; cannot write to a closed buffer.");
      }
      for (int i = a.c(this.a); (this.a.f) && (i < paramInt2); i = a.c(this.a)) {
        a.d(this.a);
      }
      if ((!this.a.g) && (i < paramInt2)) {
        throw new IORefusedException("CircularByteBuffer is full; cannot write " + paramInt2 + " bytes");
      }
      int j = Math.min(paramInt2, i);
      i = Math.min(j, this.a.a.length - this.a.c);
      int k = Math.min(j - i, this.a.a.length - this.a.d - 1);
      j = i + k;
      if (i > 0) {
        System.arraycopy(paramArrayOfByte, paramInt1, this.a.a, this.a.c, i);
      }
      if (k > 0) {
        System.arraycopy(paramArrayOfByte, i + paramInt1, this.a.a, 0, k);
      }
      a localA2;
      for (this.a.c = k;; localA2.c += j)
      {
        if (this.a.c == this.a.a.length) {
          this.a.c = 0;
        }
        i = paramInt1 + j;
        j = paramInt2 - j;
        paramInt1 = i;
        paramInt2 = j;
        if (j <= 0) {
          break;
        }
        try
        {
          Thread.sleep(100L);
          paramInt1 = i;
          paramInt2 = j;
        }
        catch (Exception paramArrayOfByte)
        {
          throw new IOException("Waiting for available space in buffer interrupted.");
        }
        localA2 = this.a;
      }
    }
  }
}
