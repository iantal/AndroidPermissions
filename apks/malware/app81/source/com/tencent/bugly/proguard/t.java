package com.tencent.bugly.proguard;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

public final class t
{
  private static t a;
  private ScheduledExecutorService b = null;
  
  protected t()
  {
    this(Executors.newScheduledThreadPool(3, new ThreadFactory()
    {
      public final Thread newThread(Runnable paramAnonymousRunnable)
      {
        paramAnonymousRunnable = new Thread(paramAnonymousRunnable);
        paramAnonymousRunnable.setName("BUGLY_THREAD");
        return paramAnonymousRunnable;
      }
    }));
  }
  
  private t(ScheduledExecutorService paramScheduledExecutorService)
  {
    if ((paramScheduledExecutorService == null) || (paramScheduledExecutorService.isShutdown())) {
      throw new IllegalArgumentException("ScheduledExecutorService is not valiable!");
    }
    this.b = paramScheduledExecutorService;
  }
  
  public static t a()
  {
    try
    {
      if (a == null) {
        a = new t();
      }
      t localT = a;
      return localT;
    }
    finally {}
  }
  
  /* Error */
  private boolean b()
  {
    // Byte code:
    //   0: aload_0
    //   1: monitorenter
    //   2: aload_0
    //   3: getfield 27	com/tencent/bugly/proguard/t:b	Ljava/util/concurrent/ScheduledExecutorService;
    //   6: ifnull +23 -> 29
    //   9: aload_0
    //   10: getfield 27	com/tencent/bugly/proguard/t:b	Ljava/util/concurrent/ScheduledExecutorService;
    //   13: invokeinterface 33 1 0
    //   18: istore_1
    //   19: iload_1
    //   20: ifne +9 -> 29
    //   23: iconst_1
    //   24: istore_1
    //   25: aload_0
    //   26: monitorexit
    //   27: iload_1
    //   28: ireturn
    //   29: iconst_0
    //   30: istore_1
    //   31: goto -6 -> 25
    //   34: astore_2
    //   35: aload_0
    //   36: monitorexit
    //   37: aload_2
    //   38: athrow
    // Local variable table:
    //   start	length	slot	name	signature
    //   0	39	0	this	t
    //   18	13	1	bool	boolean
    //   34	4	2	localObject	Object
    // Exception table:
    //   from	to	target	type
    //   2	19	34	finally
  }
  
  public final boolean a(Runnable paramRunnable)
  {
    boolean bool = false;
    for (;;)
    {
      try
      {
        if (!b())
        {
          u.b("async handler was closed , should not post task!", new Object[0]);
          return bool;
        }
        if (paramRunnable == null)
        {
          u.b("async task == null", new Object[0]);
          continue;
        }
        paramRunnable.getClass().getName();
      }
      finally {}
      u.a();
      this.b.execute(paramRunnable);
      bool = true;
    }
  }
  
  public final boolean a(Runnable paramRunnable, long paramLong)
  {
    boolean bool = false;
    try
    {
      if (!b()) {
        u.b("async handler was closed , should not post task!", new Object[0]);
      }
      for (;;)
      {
        return bool;
        if (paramRunnable != null) {
          break;
        }
        u.b("async task == null", new Object[0]);
      }
      if (paramLong <= 0L) {}
    }
    finally {}
    for (;;)
    {
      paramRunnable.getClass().getName();
      u.a();
      this.b.schedule(paramRunnable, paramLong, TimeUnit.MILLISECONDS);
      bool = true;
      break;
      paramLong = 0L;
    }
  }
}
