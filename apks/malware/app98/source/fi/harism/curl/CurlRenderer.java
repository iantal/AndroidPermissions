package fi.harism.curl;

import android.graphics.Color;
import android.graphics.PointF;
import android.graphics.RectF;
import android.opengl.GLSurfaceView.Renderer;
import android.opengl.GLU;
import java.util.Vector;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

public class CurlRenderer
  implements GLSurfaceView.Renderer
{
  public static final int PAGE_LEFT = 1;
  public static final int PAGE_RIGHT = 2;
  public static final int SHOW_ONE_PAGE = 1;
  public static final int SHOW_TWO_PAGES = 2;
  private static final boolean USE_PERSPECTIVE_PROJECTION = false;
  private int mBackgroundColor;
  private Vector<CurlMesh> mCurlMeshes;
  private RectF mMargins = new RectF();
  private Observer mObserver;
  private RectF mPageRectLeft;
  private RectF mPageRectRight;
  private int mViewMode = 1;
  private RectF mViewRect = new RectF();
  private int mViewportHeight;
  private int mViewportWidth;
  
  public CurlRenderer(Observer paramObserver)
  {
    this.mObserver = paramObserver;
    this.mCurlMeshes = new Vector();
    this.mPageRectLeft = new RectF();
    this.mPageRectRight = new RectF();
  }
  
  private void updatePageRects()
  {
    if ((this.mViewRect.width() == 0.0F) || (this.mViewRect.height() == 0.0F)) {}
    do
    {
      return;
      if (this.mViewMode == 1)
      {
        this.mPageRectRight.set(this.mViewRect);
        localRectF = this.mPageRectRight;
        localRectF.left += this.mViewRect.width() * this.mMargins.left;
        localRectF = this.mPageRectRight;
        localRectF.right -= this.mViewRect.width() * this.mMargins.right;
        localRectF = this.mPageRectRight;
        localRectF.top += this.mViewRect.height() * this.mMargins.top;
        localRectF = this.mPageRectRight;
        localRectF.bottom -= this.mViewRect.height() * this.mMargins.bottom;
        this.mPageRectLeft.set(this.mPageRectRight);
        this.mPageRectLeft.offset(-this.mPageRectRight.width(), 0.0F);
        i = (int)(this.mPageRectRight.width() * this.mViewportWidth / this.mViewRect.width());
        j = (int)(this.mPageRectRight.height() * this.mViewportHeight / this.mViewRect.height());
        this.mObserver.onPageSizeChanged(i, j);
        return;
      }
    } while (this.mViewMode != 2);
    this.mPageRectRight.set(this.mViewRect);
    RectF localRectF = this.mPageRectRight;
    localRectF.left += this.mViewRect.width() * this.mMargins.left;
    localRectF = this.mPageRectRight;
    localRectF.right -= this.mViewRect.width() * this.mMargins.right;
    localRectF = this.mPageRectRight;
    localRectF.top += this.mViewRect.height() * this.mMargins.top;
    localRectF = this.mPageRectRight;
    localRectF.bottom -= this.mViewRect.height() * this.mMargins.bottom;
    this.mPageRectLeft.set(this.mPageRectRight);
    this.mPageRectLeft.right = ((this.mPageRectLeft.right + this.mPageRectLeft.left) / 2.0F);
    this.mPageRectRight.left = this.mPageRectLeft.right;
    int i = (int)(this.mPageRectRight.width() * this.mViewportWidth / this.mViewRect.width());
    int j = (int)(this.mPageRectRight.height() * this.mViewportHeight / this.mViewRect.height());
    this.mObserver.onPageSizeChanged(i, j);
  }
  
  public void addCurlMesh(CurlMesh paramCurlMesh)
  {
    try
    {
      removeCurlMesh(paramCurlMesh);
      this.mCurlMeshes.add(paramCurlMesh);
      return;
    }
    finally
    {
      paramCurlMesh = finally;
      throw paramCurlMesh;
    }
  }
  
  public RectF getPageRect(int paramInt)
  {
    if (paramInt == 1) {
      return this.mPageRectLeft;
    }
    if (paramInt == 2) {
      return this.mPageRectRight;
    }
    return null;
  }
  
  public void onDrawFrame(GL10 paramGL10)
  {
    try
    {
      this.mObserver.onDrawFrame();
      paramGL10.glClearColor(Color.red(this.mBackgroundColor) / 255.0F, Color.green(this.mBackgroundColor) / 255.0F, Color.blue(this.mBackgroundColor) / 255.0F, Color.alpha(this.mBackgroundColor) / 255.0F);
      paramGL10.glClear(16384);
      paramGL10.glLoadIdentity();
      int i = 0;
      while (i < this.mCurlMeshes.size())
      {
        ((CurlMesh)this.mCurlMeshes.get(i)).onDrawFrame(paramGL10);
        i += 1;
      }
      return;
    }
    finally {}
  }
  
  public void onSurfaceChanged(GL10 paramGL10, int paramInt1, int paramInt2)
  {
    paramGL10.glViewport(0, 0, paramInt1, paramInt2);
    this.mViewportWidth = paramInt1;
    this.mViewportHeight = paramInt2;
    float f = paramInt1 / paramInt2;
    this.mViewRect.top = 1.0F;
    this.mViewRect.bottom = -1.0F;
    this.mViewRect.left = (-f);
    this.mViewRect.right = f;
    updatePageRects();
    paramGL10.glMatrixMode(5889);
    paramGL10.glLoadIdentity();
    GLU.gluOrtho2D(paramGL10, this.mViewRect.left, this.mViewRect.right, this.mViewRect.bottom, this.mViewRect.top);
    paramGL10.glMatrixMode(5888);
    paramGL10.glLoadIdentity();
  }
  
  public void onSurfaceCreated(GL10 paramGL10, EGLConfig paramEGLConfig)
  {
    paramGL10.glClearColor(0.0F, 0.0F, 0.0F, 1.0F);
    paramGL10.glShadeModel(7425);
    paramGL10.glHint(3152, 4354);
    paramGL10.glHint(3154, 4354);
    paramGL10.glHint(3155, 4354);
    paramGL10.glEnable(2848);
    paramGL10.glDisable(2929);
    paramGL10.glDisable(2884);
    this.mObserver.onSurfaceCreated();
  }
  
  public void removeCurlMesh(CurlMesh paramCurlMesh)
  {
    try
    {
      boolean bool;
      do
      {
        bool = this.mCurlMeshes.remove(paramCurlMesh);
      } while (bool);
      return;
    }
    finally
    {
      paramCurlMesh = finally;
      throw paramCurlMesh;
    }
  }
  
  public void setBackgroundColor(int paramInt)
  {
    this.mBackgroundColor = paramInt;
  }
  
  public void setMargins(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    try
    {
      this.mMargins.left = paramFloat1;
      this.mMargins.top = paramFloat2;
      this.mMargins.right = paramFloat3;
      this.mMargins.bottom = paramFloat4;
      updatePageRects();
      return;
    }
    finally
    {
      localObject = finally;
      throw localObject;
    }
  }
  
  public void setViewMode(int paramInt)
  {
    if (paramInt == 1) {}
    for (;;)
    {
      try
      {
        this.mViewMode = paramInt;
        updatePageRects();
        return;
      }
      finally {}
      if (paramInt == 2)
      {
        this.mViewMode = paramInt;
        updatePageRects();
      }
    }
  }
  
  public void translate(PointF paramPointF)
  {
    paramPointF.x = (this.mViewRect.left + this.mViewRect.width() * paramPointF.x / this.mViewportWidth);
    paramPointF.y = (this.mViewRect.top - -this.mViewRect.height() * paramPointF.y / this.mViewportHeight);
  }
  
  public static abstract interface Observer
  {
    public abstract void onDrawFrame();
    
    public abstract void onPageSizeChanged(int paramInt1, int paramInt2);
    
    public abstract void onSurfaceCreated();
  }
}
