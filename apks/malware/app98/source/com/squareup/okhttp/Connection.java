package com.squareup.okhttp;

import com.squareup.okhttp.internal.Platform;
import com.squareup.okhttp.internal.http.HttpAuthenticator;
import com.squareup.okhttp.internal.http.HttpEngine;
import com.squareup.okhttp.internal.http.HttpTransport;
import com.squareup.okhttp.internal.http.RawHeaders;
import com.squareup.okhttp.internal.http.SpdyTransport;
import com.squareup.okhttp.internal.spdy.SpdyConnection;
import com.squareup.okhttp.internal.spdy.SpdyConnection.Builder;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Proxy;
import java.net.Proxy.Type;
import java.net.Socket;
import java.net.URL;
import java.util.Arrays;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

public final class Connection
  implements Closeable
{
  private static final byte[] HTTP_11 = { 104, 116, 116, 112, 47, 49, 46, 49 };
  private static final byte[] NPN_PROTOCOLS = { 6, 115, 112, 100, 121, 47, 51, 8, 104, 116, 116, 112, 47, 49, 46, 49 };
  private static final byte[] SPDY3 = { 115, 112, 100, 121, 47, 51 };
  private boolean connected = false;
  private int httpMinorVersion = 1;
  private long idleStartTimeNs;
  private InputStream in;
  private OutputStream out;
  private final Route route;
  private Socket socket;
  private SpdyConnection spdyConnection;
  
  public Connection(Route paramRoute)
  {
    this.route = paramRoute;
  }
  
  private void makeTunnel(TunnelRequest paramTunnelRequest)
    throws IOException
  {
    RawHeaders localRawHeaders1 = paramTunnelRequest.getRequestHeaders();
    RawHeaders localRawHeaders2;
    URL localURL;
    do
    {
      this.out.write(localRawHeaders1.toBytes());
      localRawHeaders2 = RawHeaders.fromBytes(this.in);
      switch (localRawHeaders2.getResponseCode())
      {
      default: 
        throw new IOException("Unexpected response code for CONNECT: " + localRawHeaders2.getResponseCode());
      case 407: 
        localRawHeaders1 = new RawHeaders(localRawHeaders1);
        localURL = new URL("https", paramTunnelRequest.host, paramTunnelRequest.port, "/");
      }
    } while (HttpAuthenticator.processAuthHeader(407, localRawHeaders2, localRawHeaders1, this.route.proxy, localURL));
    throw new IOException("Failed to authenticate with proxy");
  }
  
  private void upgradeToTls(TunnelRequest paramTunnelRequest)
    throws IOException
  {
    Object localObject = Platform.get();
    if (requiresTunnel()) {
      makeTunnel(paramTunnelRequest);
    }
    this.socket = this.route.address.sslSocketFactory.createSocket(this.socket, this.route.address.uriHost, this.route.address.uriPort, true);
    paramTunnelRequest = (SSLSocket)this.socket;
    if (this.route.modernTls) {
      ((Platform)localObject).enableTlsExtensions(paramTunnelRequest, this.route.address.uriHost);
    }
    for (;;)
    {
      if (this.route.modernTls) {
        ((Platform)localObject).setNpnProtocols(paramTunnelRequest, NPN_PROTOCOLS);
      }
      paramTunnelRequest.startHandshake();
      if (this.route.address.hostnameVerifier.verify(this.route.address.uriHost, paramTunnelRequest.getSession())) {
        break;
      }
      throw new IOException("Hostname '" + this.route.address.uriHost + "' was not verified");
      ((Platform)localObject).supportTlsIntolerantServer(paramTunnelRequest);
    }
    this.out = paramTunnelRequest.getOutputStream();
    this.in = paramTunnelRequest.getInputStream();
    if (this.route.modernTls)
    {
      localObject = ((Platform)localObject).getNpnSelectedProtocol(paramTunnelRequest);
      if (localObject != null)
      {
        if (!Arrays.equals((byte[])localObject, SPDY3)) {
          break label279;
        }
        paramTunnelRequest.setSoTimeout(0);
        this.spdyConnection = new SpdyConnection.Builder(this.route.address.getUriHost(), true, this.in, this.out).build();
      }
    }
    label279:
    while (Arrays.equals((byte[])localObject, HTTP_11)) {
      return;
    }
    throw new IOException("Unexpected NPN transport " + new String((byte[])localObject, "ISO-8859-1"));
  }
  
  public void close()
    throws IOException
  {
    this.socket.close();
  }
  
  public void connect(int paramInt1, int paramInt2, TunnelRequest paramTunnelRequest)
    throws IOException
  {
    if (this.connected) {
      throw new IllegalStateException("already connected");
    }
    this.connected = true;
    if (this.route.proxy.type() != Proxy.Type.HTTP) {}
    for (Socket localSocket = new Socket(this.route.proxy);; localSocket = new Socket())
    {
      this.socket = localSocket;
      this.socket.connect(this.route.inetSocketAddress, paramInt1);
      this.socket.setSoTimeout(paramInt2);
      this.in = this.socket.getInputStream();
      this.out = this.socket.getOutputStream();
      if (this.route.address.sslSocketFactory != null) {
        upgradeToTls(paramTunnelRequest);
      }
      paramInt1 = Platform.get().getMtu(this.socket);
      this.in = new BufferedInputStream(this.in, paramInt1);
      this.out = new BufferedOutputStream(this.out, paramInt1);
      return;
    }
  }
  
  public int getHttpMinorVersion()
  {
    return this.httpMinorVersion;
  }
  
  public long getIdleStartTimeNs()
  {
    if (this.spdyConnection == null) {
      return this.idleStartTimeNs;
    }
    return this.spdyConnection.getIdleStartTimeNs();
  }
  
  public Route getRoute()
  {
    return this.route;
  }
  
  public Socket getSocket()
  {
    return this.socket;
  }
  
  public SpdyConnection getSpdyConnection()
  {
    return this.spdyConnection;
  }
  
  public boolean isAlive()
  {
    return (!this.socket.isClosed()) && (!this.socket.isInputShutdown()) && (!this.socket.isOutputShutdown());
  }
  
  public boolean isConnected()
  {
    return this.connected;
  }
  
  public boolean isExpired(long paramLong)
  {
    return (isIdle()) && (System.nanoTime() - getIdleStartTimeNs() > paramLong);
  }
  
  public boolean isIdle()
  {
    return (this.spdyConnection == null) || (this.spdyConnection.isIdle());
  }
  
  public boolean isSpdy()
  {
    return this.spdyConnection != null;
  }
  
  public Object newTransport(HttpEngine paramHttpEngine)
    throws IOException
  {
    if (this.spdyConnection != null) {
      return new SpdyTransport(paramHttpEngine, this.spdyConnection);
    }
    return new HttpTransport(paramHttpEngine, this.out, this.in);
  }
  
  public boolean requiresTunnel()
  {
    return (this.route.address.sslSocketFactory != null) && (this.route.proxy.type() == Proxy.Type.HTTP);
  }
  
  public void resetIdleStartTime()
  {
    if (this.spdyConnection != null) {
      throw new IllegalStateException("spdyConnection != null");
    }
    this.idleStartTimeNs = System.nanoTime();
  }
  
  public void setHttpMinorVersion(int paramInt)
  {
    this.httpMinorVersion = paramInt;
  }
}
