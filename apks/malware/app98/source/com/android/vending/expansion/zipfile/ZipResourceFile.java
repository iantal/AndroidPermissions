package com.android.vending.expansion.zipfile;

import android.content.res.AssetFileDescriptor;
import android.os.ParcelFileDescriptor;
import android.util.Log;
import java.io.EOFException;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileChannel.MapMode;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;
import java.util.zip.ZipFile;

public class ZipResourceFile
{
  static final boolean LOGV = false;
  static final String LOG_TAG = "zipro";
  static final int kCDECRC = 16;
  static final int kCDECommentLen = 32;
  static final int kCDECompLen = 20;
  static final int kCDEExtraLen = 30;
  static final int kCDELen = 46;
  static final int kCDELocalOffset = 42;
  static final int kCDEMethod = 10;
  static final int kCDEModWhen = 12;
  static final int kCDENameLen = 28;
  static final int kCDESignature = 33639248;
  static final int kCDEUncompLen = 24;
  static final int kCompressDeflated = 8;
  static final int kCompressStored = 0;
  static final int kEOCDFileOffset = 16;
  static final int kEOCDLen = 22;
  static final int kEOCDNumEntries = 8;
  static final int kEOCDSignature = 101010256;
  static final int kEOCDSize = 12;
  static final int kLFHExtraLen = 28;
  static final int kLFHLen = 30;
  static final int kLFHNameLen = 26;
  static final int kLFHSignature = 67324752;
  static final int kMaxCommentLen = 65535;
  static final int kMaxEOCDSearch = 65557;
  static final int kZipEntryAdj = 10000;
  private HashMap<String, ZipEntryRO> mHashMap = new HashMap();
  ByteBuffer mLEByteBuffer = ByteBuffer.allocate(4);
  public HashMap<File, ZipFile> mZipFiles = new HashMap();
  
  public ZipResourceFile(String paramString)
    throws IOException
  {
    addPatchFile(paramString);
  }
  
  private static int read4LE(RandomAccessFile paramRandomAccessFile)
    throws EOFException, IOException
  {
    return swapEndian(paramRandomAccessFile.readInt());
  }
  
  private static int swapEndian(int paramInt)
  {
    return ((paramInt & 0xFF) << 24) + ((0xFF00 & paramInt) << 8) + ((0xFF0000 & paramInt) >>> 8) + (paramInt >>> 24 & 0xFF);
  }
  
  void addPatchFile(String paramString)
    throws IOException
  {
    File localFile = new File(paramString);
    RandomAccessFile localRandomAccessFile = new RandomAccessFile(localFile, "r");
    long l2 = localRandomAccessFile.length();
    if (l2 < 22L) {
      throw new IOException();
    }
    long l1 = 65557L;
    if (65557L > l2) {
      l1 = l2;
    }
    localRandomAccessFile.seek(0L);
    int i = read4LE(localRandomAccessFile);
    if (i == 101010256)
    {
      Log.i("zipro", "Found Zip archive, but it looks empty");
      throw new IOException();
    }
    if (i != 67324752)
    {
      Log.v("zipro", "Not a Zip archive");
      throw new IOException();
    }
    localRandomAccessFile.seek(l2 - l1);
    Object localObject = ByteBuffer.allocate((int)l1);
    byte[] arrayOfByte = ((ByteBuffer)localObject).array();
    localRandomAccessFile.readFully(arrayOfByte);
    ((ByteBuffer)localObject).order(ByteOrder.LITTLE_ENDIAN);
    i = arrayOfByte.length - 22;
    int k;
    long l3;
    for (;;)
    {
      if ((i < 0) || ((arrayOfByte[i] == 80) && (((ByteBuffer)localObject).getInt(i) == 101010256)))
      {
        if (i < 0) {
          Log.d("zipro", "Zip: EOCD not found, " + paramString + " is not zip");
        }
        k = ((ByteBuffer)localObject).getShort(i + 8);
        l1 = ((ByteBuffer)localObject).getInt(i + 12) & 0xFFFFFFFF;
        l3 = ((ByteBuffer)localObject).getInt(i + 16) & 0xFFFFFFFF;
        if (l3 + l1 <= l2) {
          break;
        }
        Log.w("zipro", "bad offsets (dir " + l3 + ", size " + l1 + ", eocd " + i + ")");
        throw new IOException();
      }
      i -= 1;
    }
    if (k == 0)
    {
      Log.w("zipro", "empty archive?");
      throw new IOException();
    }
    localObject = localRandomAccessFile.getChannel().map(FileChannel.MapMode.READ_ONLY, l3, l1);
    ((MappedByteBuffer)localObject).order(ByteOrder.LITTLE_ENDIAN);
    arrayOfByte = new byte[65535];
    int j = 0;
    ByteBuffer localByteBuffer = ByteBuffer.allocate(30);
    localByteBuffer.order(ByteOrder.LITTLE_ENDIAN);
    i = 0;
    while (i < k)
    {
      if (((MappedByteBuffer)localObject).getInt(j) != 33639248)
      {
        Log.w("zipro", "Missed a central dir sig (at " + j + ")");
        throw new IOException();
      }
      int m = ((MappedByteBuffer)localObject).getShort(j + 28) & 0xFFFF;
      int n = ((MappedByteBuffer)localObject).getShort(j + 30);
      int i1 = ((MappedByteBuffer)localObject).getShort(j + 32);
      ((MappedByteBuffer)localObject).position(j + 46);
      ((MappedByteBuffer)localObject).get(arrayOfByte, 0, m);
      ((MappedByteBuffer)localObject).position(0);
      String str = new String(arrayOfByte, 0, m);
      ZipEntryRO localZipEntryRO = new ZipEntryRO(paramString, localFile, str);
      localZipEntryRO.mMethod = (((MappedByteBuffer)localObject).getShort(j + 10) & 0xFFFF);
      localZipEntryRO.mWhenModified = (((MappedByteBuffer)localObject).getInt(j + 12) & 0xFFFFFFFF);
      localZipEntryRO.mCRC32 = (((MappedByteBuffer)localObject).getLong(j + 16) & 0xFFFFFFFF);
      localZipEntryRO.mCompressedLength = (((MappedByteBuffer)localObject).getLong(j + 20) & 0xFFFFFFFF);
      localZipEntryRO.mUncompressedLength = (((MappedByteBuffer)localObject).getLong(j + 24) & 0xFFFFFFFF);
      localZipEntryRO.mLocalHdrOffset = (((MappedByteBuffer)localObject).getInt(j + 42) & 0xFFFFFFFF);
      localByteBuffer.clear();
      localZipEntryRO.setOffsetFromFile(localRandomAccessFile, localByteBuffer);
      this.mHashMap.put(str, localZipEntryRO);
      j += m + 46 + (n & 0xFFFF) + (i1 & 0xFFFF);
      i += 1;
    }
  }
  
  public ZipEntryRO[] getAllEntries()
  {
    Collection localCollection = this.mHashMap.values();
    return (ZipEntryRO[])localCollection.toArray(new ZipEntryRO[localCollection.size()]);
  }
  
  public AssetFileDescriptor getAssetFileDescriptor(String paramString)
  {
    paramString = (ZipEntryRO)this.mHashMap.get(paramString);
    if (paramString != null) {
      return paramString.getAssetFileDescriptor();
    }
    return null;
  }
  
  ZipEntryRO[] getEntriesAt(String paramString)
  {
    Vector localVector = new Vector();
    Object localObject = this.mHashMap.values();
    String str = paramString;
    if (paramString == null) {
      str = "";
    }
    int i = str.length();
    paramString = ((Collection)localObject).iterator();
    while (paramString.hasNext())
    {
      localObject = (ZipEntryRO)paramString.next();
      if ((((ZipEntryRO)localObject).mFileName.startsWith(str)) && (-1 == ((ZipEntryRO)localObject).mFileName.indexOf('/', i))) {
        localVector.add(localObject);
      }
    }
    return (ZipEntryRO[])localVector.toArray(new ZipEntryRO[localVector.size()]);
  }
  
  public InputStream getInputStream(String paramString)
    throws IOException
  {
    ZipEntryRO localZipEntryRO = (ZipEntryRO)this.mHashMap.get(paramString);
    if (localZipEntryRO != null)
    {
      if (localZipEntryRO.isUncompressed()) {
        return localZipEntryRO.getAssetFileDescriptor().createInputStream();
      }
      ZipFile localZipFile2 = (ZipFile)this.mZipFiles.get(localZipEntryRO.getZipFile());
      ZipFile localZipFile1 = localZipFile2;
      if (localZipFile2 == null)
      {
        localZipFile1 = new ZipFile(localZipEntryRO.getZipFile(), 1);
        this.mZipFiles.put(localZipEntryRO.getZipFile(), localZipFile1);
      }
      paramString = localZipFile1.getEntry(paramString);
      if (paramString != null) {
        return localZipFile1.getInputStream(paramString);
      }
    }
    return null;
  }
  
  public static final class ZipEntryRO
  {
    public long mCRC32;
    public long mCompressedLength;
    public final File mFile;
    public final String mFileName;
    public long mLocalHdrOffset;
    public int mMethod;
    public long mOffset = -1L;
    public long mUncompressedLength;
    public long mWhenModified;
    public final String mZipFileName;
    
    public ZipEntryRO(String paramString1, File paramFile, String paramString2)
    {
      this.mFileName = paramString2;
      this.mZipFileName = paramString1;
      this.mFile = paramFile;
    }
    
    public AssetFileDescriptor getAssetFileDescriptor()
    {
      if (this.mMethod == 0) {
        try
        {
          AssetFileDescriptor localAssetFileDescriptor = new AssetFileDescriptor(ParcelFileDescriptor.open(this.mFile, 268435456), getOffset(), this.mUncompressedLength);
          return localAssetFileDescriptor;
        }
        catch (FileNotFoundException localFileNotFoundException)
        {
          localFileNotFoundException.printStackTrace();
        }
      }
      return null;
    }
    
    public long getOffset()
    {
      return this.mOffset;
    }
    
    public File getZipFile()
    {
      return this.mFile;
    }
    
    public String getZipFileName()
    {
      return this.mZipFileName;
    }
    
    public boolean isUncompressed()
    {
      return this.mMethod == 0;
    }
    
    public void setOffsetFromFile(RandomAccessFile paramRandomAccessFile, ByteBuffer paramByteBuffer)
      throws IOException
    {
      long l = this.mLocalHdrOffset;
      try
      {
        paramRandomAccessFile.seek(l);
        paramRandomAccessFile.readFully(paramByteBuffer.array());
        if (paramByteBuffer.getInt(0) != 67324752)
        {
          Log.w("zipro", "didn't find signature at start of lfh");
          throw new IOException();
        }
      }
      catch (FileNotFoundException paramRandomAccessFile)
      {
        paramRandomAccessFile.printStackTrace();
        return;
        int i = paramByteBuffer.getShort(26);
        int j = paramByteBuffer.getShort(28);
        this.mOffset = (30L + l + (i & 0xFFFF) + (j & 0xFFFF));
        return;
      }
      catch (IOException paramRandomAccessFile)
      {
        paramRandomAccessFile.printStackTrace();
      }
    }
  }
}
