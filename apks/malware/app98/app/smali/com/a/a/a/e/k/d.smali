.class Lcom/a/a/a/e/k/d;
.super Ljava/lang/Object;
.source "d.java"


# static fields
.field private static a:[C


# direct methods
.method static constructor <clinit>()V
    .locals 1

    const/16 v0, 0x2d

    new-array v0, v0, [C

    fill-array-data v0, :array_0

    sput-object v0, Lcom/a/a/a/e/k/d;->a:[C

    return-void

    :array_0
    .array-data 2
        0x30s
        0x31s
        0x32s
        0x33s
        0x34s
        0x35s
        0x36s
        0x37s
        0x38s
        0x39s
        0x41s
        0x42s
        0x43s
        0x44s
        0x45s
        0x46s
        0x47s
        0x48s
        0x49s
        0x4as
        0x4bs
        0x4cs
        0x4ds
        0x4es
        0x4fs
        0x50s
        0x51s
        0x52s
        0x53s
        0x54s
        0x55s
        0x56s
        0x57s
        0x58s
        0x59s
        0x5as
        0x20s
        0x24s
        0x25s
        0x2as
        0x2bs
        0x2ds
        0x2es
        0x2fs
        0x3as
    .end array-data
.end method

.method constructor <init>()V
    .locals 0

    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method

.method private static a(C)I
    .locals 3

    sget-boolean v1, Lcom/a/a/a/e/k/a;->W:Z

    const/4 v0, 0x0

    :cond_0
    sget-object v2, Lcom/a/a/a/e/k/d;->a:[C

    array-length v2, v2

    if-ge v0, v2, :cond_2

    sget-object v2, Lcom/a/a/a/e/k/d;->a:[C

    aget-char v2, v2, v0

    if-ne p0, v2, :cond_1

    :goto_0
    return v0

    :cond_1
    add-int/lit8 v0, v0, 0x1

    if-eqz v1, :cond_0

    :cond_2
    const/4 v0, -0x1

    goto :goto_0
.end method

.method public static a([IIILcom/a/a/a/e/k/b;Z)V
    .locals 11

    const v10, 0x1a0107

    const v9, 0x1a0102

    const/16 v8, 0x25

    const/4 v1, 0x0

    sget-boolean v4, Lcom/a/a/a/e/k/a;->W:Z

    if-eqz p4, :cond_a

    move v2, v1

    move v0, v1

    :cond_0
    if-ge v2, p2, :cond_2

    add-int v3, p1, v2

    aget v3, p0, v3

    if-lt v3, v9, :cond_1

    add-int v3, p1, v2

    aget v3, p0, v3

    if-gt v3, v10, :cond_1

    add-int/lit8 v0, v0, 0x1

    :cond_1
    add-int/lit8 v2, v2, 0x1

    if-eqz v4, :cond_0

    :cond_2
    :goto_0
    add-int/2addr v0, p2

    new-array v5, v0, [I

    move v3, v1

    move v2, v1

    :goto_1
    if-ge v3, p2, :cond_5

    add-int v0, p1, v3

    aget v0, p0, v0

    if-lt v0, v9, :cond_9

    add-int v0, p1, v3

    aget v0, p0, v0

    if-gt v0, v10, :cond_9

    add-int/lit8 v0, v2, 0x1

    invoke-static {v8}, Lcom/a/a/a/e/k/d;->a(C)I

    move-result v6

    aput v6, v5, v2

    if-eqz v4, :cond_3

    :goto_2
    add-int v2, p1, v3

    aget v2, p0, v2

    const/16 v6, 0xff

    if-ge v2, v6, :cond_3

    add-int v2, p1, v3

    aget v2, p0, v2

    int-to-char v6, v2

    add-int/lit8 v2, v0, 0x1

    invoke-static {v6}, Lcom/a/a/a/e/k/d;->a(C)I

    move-result v7

    aput v7, v5, v0

    if-ne v6, v8, :cond_4

    add-int/lit8 v0, v2, 0x1

    invoke-static {v8}, Lcom/a/a/a/e/k/d;->a(C)I

    move-result v6

    aput v6, v5, v2

    :cond_3
    move v2, v0

    :cond_4
    add-int/lit8 v0, v3, 0x1

    if-eqz v4, :cond_8

    :cond_5
    div-int/lit8 v0, v2, 0x2

    if-ge v1, v0, :cond_6

    mul-int/lit8 v0, v1, 0x2

    aget v0, v5, v0

    mul-int/lit8 v0, v0, 0x2d

    mul-int/lit8 v3, v1, 0x2

    add-int/lit8 v3, v3, 0x1

    aget v3, v5, v3

    add-int/2addr v0, v3

    const/16 v3, 0xb

    invoke-virtual {p3, v0, v3}, Lcom/a/a/a/e/k/b;->a(II)V

    add-int/lit8 v1, v1, 0x1

    if-eqz v4, :cond_5

    :cond_6
    rem-int/lit8 v0, v2, 0x2

    const/4 v1, 0x1

    if-ne v0, v1, :cond_7

    add-int/lit8 v0, v2, -0x1

    aget v0, v5, v0

    const/4 v1, 0x6

    invoke-virtual {p3, v0, v1}, Lcom/a/a/a/e/k/b;->a(II)V

    :cond_7
    return-void

    :cond_8
    move v3, v0

    goto :goto_1

    :cond_9
    move v0, v2

    goto :goto_2

    :cond_a
    move v0, v1

    goto :goto_0
.end method

.method protected static a(I)Z
    .locals 2

    const/4 v0, 0x1

    const v1, 0x1a0102

    if-lt p0, v1, :cond_1

    const v1, 0x1a0107

    if-gt p0, v1, :cond_1

    :cond_0
    :goto_0
    return v0

    :cond_1
    const v1, 0x1a0112

    if-lt p0, v1, :cond_2

    const v1, 0x1a0117

    if-le p0, v1, :cond_0

    :cond_2
    const/16 v1, 0x30

    if-lt p0, v1, :cond_3

    const/16 v1, 0x39

    if-le p0, v1, :cond_0

    :cond_3
    const/16 v1, 0x41

    if-lt p0, v1, :cond_4

    const/16 v1, 0x5a

    if-le p0, v1, :cond_0

    :cond_4
    const/16 v1, 0x20

    if-eq p0, v1, :cond_0

    const/16 v1, 0x24

    if-eq p0, v1, :cond_0

    const/16 v1, 0x25

    if-eq p0, v1, :cond_0

    const/16 v1, 0x2a

    if-eq p0, v1, :cond_0

    const/16 v1, 0x2b

    if-eq p0, v1, :cond_0

    const/16 v1, 0x2d

    if-eq p0, v1, :cond_0

    const/16 v1, 0x2f

    if-eq p0, v1, :cond_0

    const/16 v1, 0x3a

    if-eq p0, v1, :cond_0

    const/4 v0, 0x0

    goto :goto_0
.end method

.method protected static a([I)Z
    .locals 4

    const/4 v1, 0x0

    sget-boolean v2, Lcom/a/a/a/e/k/a;->W:Z

    move v0, v1

    :cond_0
    array-length v3, p0

    if-ge v0, v3, :cond_2

    aget v3, p0, v0

    invoke-static {v3}, Lcom/a/a/a/e/k/d;->a(I)Z

    move-result v3

    if-nez v3, :cond_1

    :goto_0
    return v1

    :cond_1
    add-int/lit8 v0, v0, 0x1

    if-eqz v2, :cond_0

    :cond_2
    const/4 v1, 0x1

    goto :goto_0
.end method
