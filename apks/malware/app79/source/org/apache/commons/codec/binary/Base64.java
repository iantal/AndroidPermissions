package org.apache.commons.codec.binary;

public class Base64
{
  static final int BASELENGTH = 255;
  static final byte[] CHUNK_SEPARATOR;
  static final int CHUNK_SIZE = 76;
  static final int EIGHTBIT = 8;
  static final int FOURBYTE = 4;
  static final int LOOKUPLENGTH = 64;
  static final byte PAD = 61;
  static final int SIGN = -128;
  static final int SIXTEENBIT = 16;
  static final int TWENTYFOURBITGROUP = 24;
  private static byte[] base64Alphabet;
  private static byte[] lookUpBase64Alphabet;
  
  static
  {
    int k = 0;
    CHUNK_SEPARATOR = "\r\n".getBytes();
    base64Alphabet = new byte['Ã¿'];
    lookUpBase64Alphabet = new byte[64];
    int i = 0;
    label37:
    label46:
    label55:
    label79:
    int j;
    if (i >= 255)
    {
      i = 90;
      if (i >= 65) {
        break label137;
      }
      i = 122;
      if (i >= 97) {
        break label154;
      }
      i = 57;
      if (i >= 48) {
        break label174;
      }
      base64Alphabet[43] = 62;
      base64Alphabet[47] = 63;
      i = 0;
      if (i <= 25) {
        break label194;
      }
      j = 26;
      i = 0;
      label90:
      if (j <= 51) {
        break label211;
      }
      j = 52;
      i = k;
    }
    for (;;)
    {
      if (j > 61)
      {
        lookUpBase64Alphabet[62] = 43;
        lookUpBase64Alphabet[63] = 47;
        return;
        base64Alphabet[i] = -1;
        i += 1;
        break;
        label137:
        base64Alphabet[i] = ((byte)(i - 65));
        i -= 1;
        break label37;
        label154:
        base64Alphabet[i] = ((byte)(i - 97 + 26));
        i -= 1;
        break label46;
        label174:
        base64Alphabet[i] = ((byte)(i - 48 + 52));
        i -= 1;
        break label55;
        label194:
        lookUpBase64Alphabet[i] = ((byte)(i + 65));
        i += 1;
        break label79;
        label211:
        lookUpBase64Alphabet[j] = ((byte)(i + 97));
        j += 1;
        i += 1;
        break label90;
      }
      lookUpBase64Alphabet[j] = ((byte)(i + 48));
      j += 1;
      i += 1;
    }
  }
  
  public Base64() {}
  
  public static byte[] decodeBase64(byte[] paramArrayOfByte)
  {
    int k = 0;
    byte[] arrayOfByte2 = discardNonBase64(paramArrayOfByte);
    if (arrayOfByte2.length == 0) {
      paramArrayOfByte = new byte[0];
    }
    int m;
    int i;
    byte[] arrayOfByte1;
    int j;
    label54:
    do
    {
      return paramArrayOfByte;
      m = arrayOfByte2.length / 4;
      i = arrayOfByte2.length;
      if (arrayOfByte2[(i - 1)] == 61) {
        break;
      }
      arrayOfByte1 = new byte[i - m];
      j = 0;
      i = k;
      paramArrayOfByte = arrayOfByte1;
    } while (i >= m);
    int n = i << 2;
    int i2 = arrayOfByte2[(n + 2)];
    int i1 = arrayOfByte2[(n + 3)];
    k = base64Alphabet[arrayOfByte2[n]];
    n = base64Alphabet[arrayOfByte2[(n + 1)]];
    if ((i2 != 61) && (i1 != 61))
    {
      i2 = base64Alphabet[i2];
      i1 = base64Alphabet[i1];
      arrayOfByte1[j] = ((byte)(k << 2 | n >> 4));
      arrayOfByte1[(j + 1)] = ((byte)((n & 0xF) << 4 | i2 >> 2 & 0xF));
      arrayOfByte1[(j + 2)] = ((byte)(i2 << 6 | i1));
    }
    for (;;)
    {
      j += 3;
      i += 1;
      break label54;
      j = i - 1;
      i = j;
      if (j != 0) {
        break;
      }
      return new byte[0];
      if (i2 == 61)
      {
        arrayOfByte1[j] = ((byte)(n >> 4 | k << 2));
      }
      else if (i1 == 61)
      {
        i1 = base64Alphabet[i2];
        arrayOfByte1[j] = ((byte)(k << 2 | n >> 4));
        arrayOfByte1[(j + 1)] = ((byte)((n & 0xF) << 4 | i1 >> 2 & 0xF));
      }
    }
  }
  
  static byte[] discardNonBase64(byte[] paramArrayOfByte)
  {
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    int i = 0;
    int k;
    for (int j = 0;; j = k)
    {
      if (i >= paramArrayOfByte.length)
      {
        paramArrayOfByte = new byte[j];
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte, 0, j);
        return paramArrayOfByte;
      }
      k = j;
      if (isBase64(paramArrayOfByte[i]))
      {
        arrayOfByte[j] = paramArrayOfByte[i];
        k = j + 1;
      }
      i += 1;
    }
  }
  
  static byte[] discardWhitespace(byte[] paramArrayOfByte)
  {
    byte[] arrayOfByte = new byte[paramArrayOfByte.length];
    int i = 0;
    int k;
    for (int j = 0;; j = k)
    {
      if (i >= paramArrayOfByte.length)
      {
        paramArrayOfByte = new byte[j];
        System.arraycopy(arrayOfByte, 0, paramArrayOfByte, 0, j);
        return paramArrayOfByte;
      }
      k = j;
      switch (paramArrayOfByte[i])
      {
      default: 
        arrayOfByte[j] = paramArrayOfByte[i];
        k = j + 1;
      }
      i += 1;
    }
  }
  
  public static byte[] encodeBase64(byte[] paramArrayOfByte)
  {
    return encodeBase64(paramArrayOfByte, false);
  }
  
  public static byte[] encodeBase64(byte[] paramArrayOfByte, boolean paramBoolean)
  {
    int i = paramArrayOfByte.length << 3;
    int i5 = i % 24;
    int i6 = i / 24;
    int n = 0;
    int m;
    if (i5 != 0)
    {
      i = i6 + 1 << 2;
      m = i;
      if (paramBoolean) {
        if (CHUNK_SEPARATOR.length != 0) {
          break label205;
        }
      }
    }
    byte[] arrayOfByte;
    int i1;
    int k;
    label121:
    label164:
    label205:
    for (int j = 0;; j = (int)Math.ceil(i / 76.0F))
    {
      m = i + CHUNK_SEPARATOR.length * j;
      n = j;
      arrayOfByte = new byte[m];
      j = 76;
      i = 0;
      i1 = 0;
      k = 0;
      if (i1 < i6) {
        break label219;
      }
      i1 *= 3;
      if (i5 != 8) {
        break label493;
      }
      j = paramArrayOfByte[i1];
      i1 = (byte)(j & 0x3);
      if ((j & 0xFFFFFF80) != 0) {
        break label481;
      }
      j = (byte)(j >> 2);
      arrayOfByte[k] = lookUpBase64Alphabet[j];
      arrayOfByte[(k + 1)] = lookUpBase64Alphabet[(i1 << 4)];
      arrayOfByte[(k + 2)] = 61;
      arrayOfByte[(k + 3)] = 61;
      if ((paramBoolean) && (i < n)) {
        System.arraycopy(CHUNK_SEPARATOR, 0, arrayOfByte, m - CHUNK_SEPARATOR.length, CHUNK_SEPARATOR.length);
      }
      return arrayOfByte;
      i = i6 << 2;
      break;
    }
    label219:
    int i4 = i1 * 3;
    int i2 = paramArrayOfByte[i4];
    int i3 = paramArrayOfByte[(i4 + 1)];
    int i7 = paramArrayOfByte[(i4 + 2)];
    int i8 = (byte)(i3 & 0xF);
    int i9 = (byte)(i2 & 0x3);
    if ((i2 & 0xFFFFFF80) == 0)
    {
      i2 = (byte)(i2 >> 2);
      label277:
      if ((i3 & 0xFFFFFF80) != 0) {
        break label452;
      }
      i3 = (byte)(i3 >> 4);
      label292:
      if ((i7 & 0xFFFFFF80) != 0) {
        break label466;
      }
      i4 = (byte)(i7 >> 6);
      label308:
      arrayOfByte[k] = lookUpBase64Alphabet[i2];
      arrayOfByte[(k + 1)] = lookUpBase64Alphabet[(i3 | i9 << 4)];
      arrayOfByte[(k + 2)] = lookUpBase64Alphabet[(i4 | i8 << 2)];
      arrayOfByte[(k + 3)] = lookUpBase64Alphabet[(i7 & 0x3F)];
      k += 4;
      if ((!paramBoolean) || (k != j)) {
        break label635;
      }
      System.arraycopy(CHUNK_SEPARATOR, 0, arrayOfByte, k, CHUNK_SEPARATOR.length);
      i += 1;
      j = (i + 1) * 76 + CHUNK_SEPARATOR.length * i;
      k = CHUNK_SEPARATOR.length + k;
    }
    label452:
    label466:
    label481:
    label493:
    label539:
    label621:
    label635:
    for (;;)
    {
      i1 += 1;
      break;
      i2 = (byte)(i2 >> 2 ^ 0xC0);
      break label277;
      i3 = (byte)(i3 >> 4 ^ 0xF0);
      break label292;
      i4 = (byte)(i7 >> 6 ^ 0xFC);
      break label308;
      j = (byte)(j >> 2 ^ 0xC0);
      break label121;
      if (i5 != 16) {
        break label164;
      }
      j = paramArrayOfByte[i1];
      i1 = paramArrayOfByte[(i1 + 1)];
      i2 = (byte)(i1 & 0xF);
      i3 = (byte)(j & 0x3);
      if ((j & 0xFFFFFF80) == 0)
      {
        j = (byte)(j >> 2);
        if ((i1 & 0xFFFFFF80) != 0) {
          break label621;
        }
      }
      for (i1 = (byte)(i1 >> 4);; i1 = (byte)(i1 >> 4 ^ 0xF0))
      {
        arrayOfByte[k] = lookUpBase64Alphabet[j];
        arrayOfByte[(k + 1)] = lookUpBase64Alphabet[(i1 | i3 << 4)];
        arrayOfByte[(k + 2)] = lookUpBase64Alphabet[(i2 << 2)];
        arrayOfByte[(k + 3)] = 61;
        break;
        j = (byte)(j >> 2 ^ 0xC0);
        break label539;
      }
    }
  }
  
  public static byte[] encodeBase64Chunked(byte[] paramArrayOfByte)
  {
    return encodeBase64(paramArrayOfByte, true);
  }
  
  private static boolean isBase64(byte paramByte)
  {
    if (paramByte == 61) {}
    while (base64Alphabet[paramByte] != -1) {
      return true;
    }
    return false;
  }
}
